/*
 * Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 */

package org.jetbrains.amper.dependency.resolution

import kotlinx.serialization.Serializable
import kotlinx.serialization.Transient
import org.jetbrains.amper.dependency.resolution.diagnostics.Message

interface DependencyNodeHolder: DependencyNode

/**
 * Serves as a higher level holder for other dependency nodes.
 * It's statically defined, thus always resolved and has NO-OP implementations of the interface methods.
 * Its name must be unique to distinguish it from other `ModuleDependencyNode`s.
 * 
 * It's the responsibility of the caller to set a parent for this node if none was provided via the constructor.
 * 
 * @see [MavenDependencyNode]
 */
abstract class DependencyNodeHolderImpl(
    override val graphEntryName: String,
    final override val children: List<DependencyNodeWithResolutionContext>,
    templateContext: Context,
    parentNodes: Set<DependencyNodeWithResolutionContext> = emptySet(),
) : DependencyNodeWithResolutionContext, DependencyNodeHolder {

    init {
        children.forEach { it.context.nodeParents.add(this) }
    }

    override val context: Context = templateContext.copyWithNewNodeCache(parentNodes)
    override val key: Key<*> = Key<DependencyNodeHolder>(graphEntryName)
    override val messages: List<Message> = listOf()

    override fun toString(): String = graphEntryName

    override suspend fun resolveChildren(level: ResolutionLevel, transitive: Boolean) {}

    override suspend fun downloadDependencies(downloadSources: Boolean) {}
}

@Serializable
abstract class DependencyNodeHolderPlainBase(
    @Transient
    private val graphContext: DependencyGraphContext = currentGraphContext()
): DependencyNodeHolder, DependencyNodePlainBase(graphContext) {
    override val key: Key<*> by lazy { Key<DependencyNodeHolder>(graphEntryName) }
}

class RootDependencyNodeInput(
    graphEntryName: String = "root",
    /**
     * This field is an ID of cache entry corresponding to the dependency graph defined by this node.
     *
     * Semantically different graphs should be supplied with different cache entry keys,
     * otherwise attempts to resolve such graphs from the cache will cause frequent cache entry invalidation,
     * reducing the cache usage to a minimum (due to different inputs of different graphs).
     *
     * Note: To avoid unintended cache entry invalidation,
     * Idea plugin and CLI should either use different [cacheEntryKey] for the same dependency graph (and resolution context)
     * or use different incremental cache storages. Idea plugin and CLI have different codeVersions and would recalculate
     * entries calculated by each other (a cache entry generated by plugin code can't be used by CLI and vice versa).
     */
    override val cacheEntryKey: CacheEntryKey = CacheEntryKey.NotCached,
    children: List<DependencyNodeWithResolutionContext>,
    templateContext: Context,
    parentNodes: Set<DependencyNodeWithResolutionContext> = emptySet(),
) : RootDependencyNode,
    DependencyNodeHolderImpl(graphEntryName, children, templateContext, parentNodes = parentNodes)

class RootDependencyNodeStub(
    override val graphEntryName: String = "root",
    override val children: List<DependencyNode> = emptyList(),
    override val parents: Set<DependencyNode> = emptySet(),
): RootDependencyNode {
    override val key: Key<*> = Key<DependencyNodeHolderImpl>(graphEntryName)
    override val messages = emptyList<Message>()

    override fun toString() = graphEntryName
}

interface RootDependencyNode: DependencyNodeHolder {
    override fun toEmptyNodePlain(graphContext: DependencyGraphContext): DependencyNodePlain =
        RootDependencyNodePlain(graphEntryName, graphContext = graphContext)
}

@Serializable
class RootDependencyNodePlain internal constructor(
    override val graphEntryName: String,
    override val childrenRefs: List<DependencyNodeReference> = mutableListOf(),
    @Transient
    private val graphContext: DependencyGraphContext = currentGraphContext(),
): RootDependencyNode, DependencyNodeHolderPlainBase(graphContext) {
    override val parentsRefs = mutableSetOf<DependencyNodeReference>()
    override val messages: List<Message> = listOf()

}
