/*
 * Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 */

package org.jetbrains.amper.dependency.resolution

import kotlinx.serialization.Serializable
import kotlinx.serialization.Transient
import org.jetbrains.amper.dependency.resolution.diagnostics.Message

interface DependencyNodeHolder: DependencyNode

/**
 * Serves as a higher level holder for other dependency nodes.
 * It's statically defined, thus always resolved and has NO-OP implementations of the interface methods.
 * Its name must be unique to distinguish it from other `ModuleDependencyNode`s.
 * 
 * It's the responsibility of the caller to set a parent for this node if none was provided via the constructor.
 * 
 * @see [MavenDependencyNode]
 */
abstract class DependencyNodeHolderWithContext(
    override val graphEntryName: String,
    final override val children: List<DependencyNodeWithContext>,
    templateContext: Context,
    parentNodes: Set<DependencyNodeWithContext> = emptySet(),
) : DependencyNodeWithContext, DependencyNodeHolder {

    init {
        children.forEach { it.context.nodeParents.add(this) }
    }

    override val context: Context = templateContext.copyWithNewNodeCache(parentNodes)
    override val key: Key<*> = Key<DependencyNodeHolder>(graphEntryName)
    override val messages: List<Message> = listOf()

    override fun toString(): String = graphEntryName

    override suspend fun resolveChildren(level: ResolutionLevel, transitive: Boolean) {}

    override suspend fun downloadDependencies(downloadSources: Boolean) {}
}

@Serializable
abstract class SerializableDependencyNodeHolderBase(
    @Transient
    private val graphContext: DependencyGraphContext = currentGraphContext()
): DependencyNodeHolder, SerializableDependencyNodeBase(graphContext) {
    override val key: Key<*> by lazy { Key<DependencyNodeHolder>(graphEntryName) }
}

class RootDependencyNodeWithContext(
    graphEntryName: String = "root",
    /**
     * This field is an ID of cache entry corresponding to the dependency graph defined by this node.
     *
     * Semantically different graphs should be supplied with different cache entry keys,
     * otherwise attempts to resolve such graphs from the cache will cause frequent cache entry invalidation,
     * reducing the cache usage to a minimum (due to different inputs of different graphs).
     *
     * Note: To avoid unintended cache entry invalidation,
     * Idea plugin and CLI should either use different [cacheEntryKey] for the same dependency graph (and resolution context)
     * or use different incremental cache storages. Idea plugin and CLI have different codeVersions and would recalculate
     * entries calculated by each other (a cache entry generated by plugin code can't be used by CLI and vice versa).
     */
    rootCacheEntryKey: RootCacheEntryKey = CacheEntryKey.NotCached.asRootCacheEntryKey(),
    children: List<DependencyNodeWithContext>,
    templateContext: Context
) : RootDependencyNode,
    DependencyNodeHolderWithContext(graphEntryName, children, templateContext)
{
    override val cacheEntryKey: CacheEntryKey = rootCacheEntryKey.toCacheEntryKey(this)
}

sealed class RootCacheEntryKey {
    data class Key(val key: CacheEntryKey): RootCacheEntryKey() {
        override fun toCacheEntryKey(node: RootDependencyNodeWithContext) = key
    }

    object FromChildren: RootCacheEntryKey() {
        override fun toCacheEntryKey(node: RootDependencyNodeWithContext): CacheEntryKey {
            val childrenBasedKey = run {
                node.children.flatMap {
                    when (val childKey = it.getParentAwareCacheEntryKey()) {
                        is CacheEntryKey.NotCached -> return@run CacheEntryKey.NotCached
                        is CacheEntryKey.CompositeCacheEntryKey -> childKey.components
                    }
                }.let { CacheEntryKey.CompositeCacheEntryKey(it) }
            }
            return childrenBasedKey
        }
    }

    abstract fun toCacheEntryKey(node: RootDependencyNodeWithContext): CacheEntryKey
}

fun CacheEntryKey.asRootCacheEntryKey(): RootCacheEntryKey = RootCacheEntryKey.Key(this)

class RootDependencyNodeStub(
    override val graphEntryName: String = "root",
    override val children: List<DependencyNode> = emptyList(),
    override val parents: Set<DependencyNode> = emptySet(),
): RootDependencyNode {
    override val key: Key<*> = Key<DependencyNodeHolderWithContext>(graphEntryName)
    override val messages = emptyList<Message>()

    override fun toString() = graphEntryName
}

interface RootDependencyNode: DependencyNodeHolder

@Serializable
class SerializableRootDependencyNode internal constructor(
    override val graphEntryName: String,
    override val childrenRefs: List<DependencyNodeReference> = mutableListOf(),
    @Transient
    private val graphContext: DependencyGraphContext = currentGraphContext(),
): RootDependencyNode, SerializableDependencyNodeHolderBase(graphContext) {
    override val parentsRefs = mutableSetOf<DependencyNodeReference>()
    override val messages: List<Message> = listOf()

}
