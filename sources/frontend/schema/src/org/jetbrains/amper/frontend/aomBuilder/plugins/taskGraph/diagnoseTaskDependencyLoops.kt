/*
 * Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
 */

package org.jetbrains.amper.frontend.aomBuilder.plugins.taskGraph

import org.jetbrains.amper.frontend.SchemaBundle
import org.jetbrains.amper.frontend.api.Traceable
import org.jetbrains.amper.frontend.asBuildProblemSource
import org.jetbrains.amper.frontend.messages.PsiBuildProblemSource
import org.jetbrains.amper.problems.reporting.BuildProblem
import org.jetbrains.amper.problems.reporting.BuildProblemSource
import org.jetbrains.amper.problems.reporting.BuildProblemType
import org.jetbrains.amper.problems.reporting.Level
import org.jetbrains.amper.problems.reporting.MultipleLocationsBuildProblemSource
import org.jetbrains.amper.problems.reporting.ProblemReporter
import org.jetbrains.amper.stdlib.collections.zipWithNextOrNull
import org.jetbrains.amper.stdlib.graphs.depthFirstDetectLoops
import org.jetbrains.annotations.Nls
import kotlin.math.max

class TaskDependencyLoop(
    override val source: BuildProblemSource,
    val renderedLoop: @Nls String,
) : BuildProblem {
    val baseMessage: @Nls String = SchemaBundle.message("plugin.tasks.dependency.loop")

    override val message: @Nls String = "$baseMessage\n$renderedLoop"
    override val level: Level get() = Level.Error
    override val type: BuildProblemType get() = BuildProblemType.Generic
    override val buildProblemId get() = ID

    companion object {
        const val ID = "plugin.tasks.dependency.loop"
    }
}

context(reporter: ProblemReporter)
internal fun diagnoseTaskDependencyLoops(
    taskGraph: TaskGraph,
) {
    val loops = depthFirstDetectLoops(
        roots = taskGraph.nodes,
        adjacent = { node -> taskGraph[node].mapTo(mutableSetOf()) { it.target } }
    )

    for (loop: List<TaskGraph.Node> in loops) {
        val loopCauses = mutableListOf<Traceable>()
        /*
          Example of such a message:
             1. task `:app:foo@myPlugin` (*)
                ╰───> consumes `/foo/bar/baz/foo/bar/baz/foo/bar/baz/foo/bar/baz/` produced by
             2. task `:app:bar@myPlugin` <───────────────────────────────────────────────────╯
                ╰───> depends on the compilation of its source code
             3. compilation of module `my-plugin` <───────────────╯
                ╰───> needs sources from ──────────────────╮
             4. source generation for module `my-plugin` <─╯
                ╰───> includes the source directory `/foo/bar/generated/` generated by
             5. task `:app:foo@myPlugin` (*) <───────────────────────────────────────╯
        */
        val renderedLoop = buildString {
            var previousReasonLineLength = Int.MAX_VALUE
            (loop + loop.first()).zipWithNextOrNull().forEachIndexed { i, (from: TaskGraph.Node, to: TaskGraph.Node?) ->
                val nodeString = from.stringRepresentation()

                val nodeLine = buildString {
                    append("${i + 1}. $nodeString")
                    // Either for the first or for the last node line
                    if (i == 0 || to == null) append(" (*)")
                }

                val diff = nodeLine.length - previousReasonLineLength
                if (diff >= -3) {
                    // Draw the ` ────╮` segment at the end of the "reason" line
                    // if it's shorter than the next "node" line.
                    append(' ')
                    repeat(max(2, diff + 2)) { append('─') }
                    append('╮')
                }

                if (i != 0) append('\n')

                append(nodeLine)
                if (i != 0) {
                    // Draw the ` <──╯` segment at the end of the "node" line
                    // if it was longer than the previous "reason" line.
                    append(" <")
                    repeat(max(1, 1 - diff) - (if (diff <= -4) 4 else 0)) { append('─') }
                    append('╯')
                }

                if (to == null) {
                    return@buildString
                }

                append('\n')
                append(`╰───v`)

                // There can be more than one edge from `from` to `to`
                val edges = taskGraph[from].filter { it.target == to }

                val reasonStrings = edges.map { it.reason() }
                // Draw all of them with the same indent.
                reasonStrings.joinTo(this, separator = ",\n" + " ".repeat(`╰───v`.length))

                loopCauses.addAll(edges)

                previousReasonLineLength = `╰───v`.length + reasonStrings.last().length
            }
        }
        // TODO: This would really benefit from some structured message format
        //  where traces are incorporated into the message and are presented as links in the IDE.
        val problem = TaskDependencyLoop(
            source = MultipleLocationsBuildProblemSource(
                sources = loopCauses.mapNotNull { it.asBuildProblemSource() as? PsiBuildProblemSource },
                groupingMessage = SchemaBundle.message("plugin.tasks.dependency.loop.grouping"),
            ),
            renderedLoop = renderedLoop,
        )
        reporter.reportMessage(problem)
    }
}

private fun TaskGraph.Node.stringRepresentation(): String = when (this) {
    is TaskGraph.Node.Compilation ->
        FrontendTaskGraphBundle.message("task.graph.node.compilation", module.userReadableName)
    is TaskGraph.Node.ResourceGeneration ->
        FrontendTaskGraphBundle.message("task.graph.node.generation.resources", module.userReadableName)
    is TaskGraph.Node.SourceGeneration ->
        FrontendTaskGraphBundle.message("task.graph.node.generation.sources", module.userReadableName)
    is TaskGraph.Node.PluginTask -> with(description) {
        FrontendTaskGraphBundle.message("task.graph.node.task", name, appliedTo.userReadableName, pluginId.value)
    }
}

@Suppress("ObjectPropertyName", "NonAsciiCharacters")
private const val `╰───v` = "   ╰───> "
