{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Amper","text":"<p>Amper is an experimental build tool for the Kotlin and Java languages.</p> <p>Its goal is to provide a great and smooth user experience and IDE support. We believe that this can be achieved by:</p> <ul> <li>providing a developer- and IDE-friendly declarative configuration DSL - to simplify not only the initial setup but   also improve maintainability and let IDEs assist with automatic configuration reliably;</li> <li>bundling a curated set of compatible toolchains and extensions - to support the majority of the scenarios without the   need to find compatible plugins;</li> <li>carefully choosing the extensibility points - to keep the overall mental model and UX of the configuration consistent   and to avoid unexpected third-party code execution.</li> </ul> <p>In essence, we aim to achieve a similar well-thought-out and well-tested experience as with JetBrains IDEs.</p> <p>We are still in the experimental phase. We\u2019re currently looking at various aspects, including the configuration of projects for building, packaging, publishing, and more. At the current stage, however, the focus is primarily on configuring projects for building. While the current use case is Kotlin and Kotlin Multiplatform, Amper also supports Java and Swift (as a requirement for multiplatform). However, the same approach to configuration could work for other languages and technology stacks in the future.</p> <p>Supported features:</p> <ul> <li>Creating and running JVM, Android, iOS, Linux, and macOS applications.</li> <li>Creating Kotlin Multiplatform libraries.</li> <li>Running tests.</li> <li>Mixing Kotlin, Java and Swift code.</li> <li>Code assistance for module files in IntelliJ IDEA and Fleet.</li> <li>Multi-module projects.</li> <li>Using Compose Multiplatform.</li> <li>Using Compose multiplatform resources.</li> <li>Integration with Gradle version catalogs.</li> </ul> <p>Future directions:</p> <ul> <li>Support for more Kotlin and Kotlin Multiplatform scenarios and configurations.</li> <li>More product types and platforms, such as watchOS, Windows, etc.</li> <li>Platform-specific test types, including android instrumented tests.</li> <li>Native dependencies support, such as CocoaPods, Swift Package Manager.</li> <li>Packaging and publication.</li> <li>Build variants support.</li> <li>Extensibility.</li> </ul> <p>For a quick start:</p> <ul> <li>Setup and usage instructions</li> <li>Tutorial</li> <li>User guide</li> <li>Example projects</li> </ul>"},{"location":"#issues-and-feedback","title":"Issues and feedback","text":"<p>Amper uses YouTrack for issue tracking, create a new issue there to report problems or submit ideas.</p> <p>Before reporting an issue, please check the FAQ.</p> <p>You can also join the Slack channel for discussions, or share your feedback using the feedback form.</p>"},{"location":"#how-to-try","title":"How to Try","text":"<p>There are multiple ways to try Amper:</p> <ul> <li>In the latest IntelliJ IDEA EAP (instructions).</li> <li>Using Amper from the command line.</li> </ul>"},{"location":"#examples","title":"Examples","text":""},{"location":"#basics","title":"Basics","text":"<p>Here is a very basic JVM \"Hello, World!\" project:</p> <p></p> <p>The <code>main.kt</code> and <code>MyTest.kt</code> files are just regular Kotlin files with nothing special in them. The interesting part is <code>module.yaml</code>, which is the Amper module configuration file. For the above project structure, it would simply be:</p> <pre><code># Produce a JVM application \nproduct: jvm/app\n</code></pre> <p>That's it. The Kotlin and Java toolchains, test framework, and other necessary functionality are configured and available straight out of the box. You can build it, run it, write and run tests, and more. For more detailed information, check out the full example.</p> <p></p>"},{"location":"#multiplatform","title":"Multiplatform","text":"<p>Now, let's look at a Compose Multiplatform project with Android, iOS, and desktop JVM apps, with the following project structure in Fleet:</p> <p></p> <p>Notice how the <code>src/</code> folder contains Kotlin and Swift code together. It could, of course, also be Kotlin and Java. Another aspect to highlight is the shared module with the common code in the <code>src</code> folder and the platform-specific code folders <code>src@ios</code> and <code>src@android</code> (learn more about project layout).</p> <p>Here is how <code>ios-app/module.yaml</code> file looks: <pre><code># Produce an iOS application\nproduct: ios/app\n\n# Depend on the shared library module: \ndependencies:\n  - ../shared\n\nsettings:\n  # Enable the Compose Multiplatform framework\n  compose: enabled\n</code></pre></p> <p>This is pretty straightforward: it defines an iOS application with a dependency on a shared module and enables the Compose Multiplatform framework. A more interesting example would be <code>shared/module.yaml</code>:</p> <pre><code># Produce a shared library for the JVM, Android, and iOS platforms:\nproduct:\n  type: lib\n  platforms: [jvm, android, iosArm64, iosSimulatorArm64, iosX64]\n\n# Shared Compose dependencies:\ndependencies:\n  - $compose.foundation: exported\n  - $compose.material3: exported\n\n# Android-only dependencies  \ndependencies@android:\n  # Android-specific integration with Compose\n  - androidx.activity:activity-compose:1.7.2: exported\n  - androidx.appcompat:appcompat:1.6.1: exported\n\nsettings:\n  # Enable Kotlin serialization\n  kotlin:\n    serialization: json\n\n  # Enable the Compose Multiplatform framework\n  compose: enabled\n</code></pre> <p>A couple of things are worth mentioning. Note the platform-specific <code>dependencies@android</code> section with the <code>@&lt;platform&gt;</code> qualifier. The platform qualifier can be used both in the manifest and also in  the file layout. The qualifier organizes the code, dependencies, and settings for a certain platform.</p> <p></p> <p>Naturally, these examples show only a limited set of Amper features. To get more insight into design and functionality, look at the user guide, the tutorial, and example projects.</p>"},{"location":"#more-examples","title":"More examples","text":"<p>Check our these example projects:</p> <ul> <li>JVM \"Hello, World!\"</li> <li>Compose Multiplatform</li> <li>Compose on iOS, Android,   and desktop</li> <li>Kotlin Multiplatform app template with shared Compose UI   and with native Android and iOS UI</li> <li>And other examples</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#general","title":"General","text":""},{"location":"faq/#is-amper-a-brand-new-build-tool-from-jetbrains","title":"Is Amper a brand-new build tool from JetBrains?","text":"<p>Yes, Amper is a new build tool with a focus on user experience and IDE support.</p>"},{"location":"faq/#do-you-plan-to-support-only-kotlin","title":"Do you plan to support only Kotlin?","text":"<p>Amper already supports both Kotlin and Java as first-class citizens. Also, because one of Amper's main targets is Kotlin Multiplatform projects, it supports Swift and Objective-C for iOS.</p> <p>We\u2019ll investigate other tech stacks in the future based on the demand for them.</p>"},{"location":"faq/#which-target-platforms-are-supported","title":"Which target platforms are supported?","text":"<p>Currently, you can create applications for the JVM, Android, iOS, macOS, Linux, Windows, but also JS and WASM (although those cannot be run directly with Amper).</p> <p>Libraries can be created for all Kotlin Multiplatform targets.</p>"},{"location":"faq/#does-amper-support-compose-multiplatform","title":"Does Amper support Compose Multiplatform?","text":"<p>Yes, you can configure Compose for Android, iOS, and desktop.</p>"},{"location":"faq/#does-amper-support-kotlinjs-or-kotlinwasm-projects","title":"Does Amper support Kotlin/JS or Kotlin/Wasm projects?","text":"<p>Yes, but it doesn't provide tooling to work on full stack web projects yet. For instance, Amper doesn't install any  browser or Node.js runtime, doesn't generate or process any HTML entrypoint, and cannot run <code>js/app</code> modules on its own.</p>"},{"location":"faq/#what-functionality-do-you-plan-to-support","title":"What functionality do you plan to support?","text":"<p>We\u2019re working on the project library catalogs, publication, and extensibility.</p>"},{"location":"faq/#will-amper-be-open-source","title":"Will Amper be open source?","text":"<p>Yes, Amper is already open source. The default branch is the latest stable release branch, but you can also take a look at the main branch to see what's cooking!</p>"},{"location":"faq/#when-will-amper-be-released-as-stable","title":"When will Amper be released as stable?","text":"<p>Right now, we\u2019re focusing on getting feedback and understanding your needs. Based on that, we\u2019ll be able to provide a more accurate estimate of a release date sometime in the future.</p>"},{"location":"faq/#should-i-start-my-next-project-with-amper","title":"Should I start my next project with Amper?","text":"<p>You\u2019re welcome to use it in any type of project. However, please understand that Amper is still in the experimental phase, and we expect things to change.</p>"},{"location":"faq/#should-i-migrate-my-existing-projects","title":"Should I migrate my existing projects?","text":"<p>Understanding real-world scenarios is crucial for us to provide a better experience, so from our side we\u2019d love to hear about the challenges you may face porting existing projects. However, please understand that the project is still in the experimental phase, and we cannot guarantee that all scenarios can be supported.</p>"},{"location":"faq/#how-do-i-report-a-bug","title":"How do I report a bug?","text":"<p>Please report problems to our issue tracker. Since this project is in the experimental phase, we would also greatly appreciate feedback and suggestions regarding the configuration experience \u2013 join our Slack channel for discussion.</p>"},{"location":"faq/#why-dont-you-use-kotlin-for-ampers-configuration-files","title":"Why don\u2019t you use Kotlin for Amper's configuration files?","text":"<p>Currently, we use YAML as a simple and readable markup language. It allows us to experiment with the UX and the IDE support much faster. We\u2019ll review the language choice as we proceed with the design and based on demand. The Kotlin DSL, or a limited form thereof, is one of the possible options.</p> <p>Having said that, we believe that the declarative approach to project configuration has significant advantages over the imperative approach. Declarative configuration is easily toolable, recovery from errors is much easier, and interpretation is much faster. These properties are critical for a good UX.</p> <p>Our final language choice will be made based on the overall UX it provides.</p>"},{"location":"faq/#why-did-you-have-a-gradle-based-option-to-use-amper","title":"Why did you have a Gradle-based option to use Amper?","text":"<p>In the initial Amper prototype, our main focus was improving the user experience and toolability of build configuration. Gradle, as a well-tested build engine, allowed us to start experimenting with the UX of the configuration very quickly. What\u2019s more, smooth interoperability with Gradle allowed using Amper in existing projects, which is important if we want to get feedback from real-world use cases.</p> <p>Now, Amper is a standalone build tool, which allows us to improve the IDE support and workflows even further.</p>"},{"location":"faq/#why-not-simply-improve-gradle","title":"Why not simply improve Gradle?","text":"<p>We believe there is room to improve the project configuration experience and IDE support. With Amper, we want to show you our design and get your feedback, as it will help us to decide which direction to take the design.</p> <p>At the same time, we are also working with the Gradle team to improve Gradle support in our IDEs and Gradle itself.</p>"},{"location":"faq/#what-about-gradle-extensibility-and-plugins","title":"What about Gradle extensibility and plugins?","text":"<p>We aim to support most of the Kotlin and Kotlin Multiplatform use cases out of the box  and offer a reasonable level of extensibility.</p>"},{"location":"faq/#how-do-amper-and-declarative-gradle-relate-to-each-other","title":"How do Amper and Declarative Gradle relate to each other?","text":"<p>Both projects aim to improve the developer experience and the IDE support, but from opposite directions and with different constraints. Amper's approach is to design, from the ground up, a tool that is easy to use for the developers regardless of their background, with great IDE support in mind, and focused on specific use-cases. The Declarative Gradle project approaches the same goal from the other end,  improving the developer experience and the IDE support in an already exising powerful tool. </p> <p>While both projects are still experimental, it's important that you provide your feedback to shape the future development.</p>"},{"location":"faq/#usage","title":"Usage","text":""},{"location":"faq/#what-are-the-requirements-to-use-amper","title":"What are the requirements to use Amper?","text":"<p>See the setup instructions.</p> <p>The Amper command line tool doesn't require any software preinstallation, except the Xcode toolchain if you want to  build iOS applications. See the usage instructions.</p> <p>The latest IntelliJ IDEA EAP is advised to work with Amper projects.</p>"},{"location":"faq/#how-do-i-create-a-new-amper-project","title":"How do I create a new Amper project?","text":"<p>You have several options:</p> <ul> <li> <p>Kick-start your project using one of the examples</p> </li> <li> <p>Download the Amper script by following the usage instructions, and generate a project from a template    using the <code>amper init</code> command.</p> </li> </ul>"},{"location":"faq/#how-do-i-create-a-multi-module-project-in-amper","title":"How do I create a multi-module project in Amper?","text":"<p>See the documentation on the project layout.</p>"},{"location":"faq/#is-there-an-automated-migration-tool","title":"Is there an automated migration tool?","text":"<p>Not currently, but it's certainly something we\u2019re looking into.</p>"},{"location":"faq/#feature-x-is-not-yet-supported-what-can-i-do","title":"Feature X is not yet supported, what can I do?","text":"<p>We plan to expand the list of supported use cases based on demand. Please submit your requests and suggestions in the tracker or join the Slack channel for discussions.</p>"},{"location":"faq/#can-i-write-a-custom-task-or-use-a-plugin","title":"Can I write a custom task or use a plugin?","text":"<p>Extensibility is not currently implemented in Amper, but we are working on it.</p>"},{"location":"faq/#how-can-i-use-c-interop-in-amper","title":"How can I use C-interop in Amper?","text":"<p>For now, Amper doesn't directly support C-interop.</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#setup-your-ide","title":"Setup your IDE","text":"<ol> <li> <p>Preferably use the latest IntelliJ IDEA EAP.     The best way to get the most recent IDE versions is by using the Toolbox App.</p> </li> <li> <p>Make sure to install the Amper plugin:</p> </li> </ol> <p></p> <ol> <li> <p>[Optional] If you want to write code for Apple platforms or share code between several platforms, install the    Kotlin Multiplatform plugin</p> </li> <li> <p>[Optional] If you want to write some Android-specific code, also install the    Android plugin</p> </li> </ol>"},{"location":"setup/#check-your-environment-with-kdoctor-macos-only","title":"Check your environment with KDoctor (macOS only)","text":"<p>If you're on macOS, you can use the KDoctor tool to ensure that your development environment is configured correctly:</p> <ol> <li>Install KDoctor with Homebrew:</li> </ol> <pre><code>brew install kdoctor\n</code></pre> <ol> <li>Run KDoctor in your terminal:</li> </ol> <pre><code>kdoctor\n</code></pre> <p>If everything is set up correctly, you'll see valid output:</p> <pre><code>Environment diagnose (to see all details, use -v option):\n[\u2713] Operation System\n[\u2713] Java\n[\u2713] Android Studio\n[\u2713] Xcode\n[\u2713] Cocoapods\n\nConclusion:\n  \u2713 Your system is ready for Kotlin Multiplatform Mobile development!\n</code></pre> <p>Otherwise, KDoctor will highlight which parts of your setup still need to be configured and will suggest a way to fix    them.</p> <p>Note</p> <p>Xcode has to be 16 or newer.</p> <p>Warning</p> <p>KDoctor has a known issue that triggers an incorrect warning: <code>Kotlin Multiplatform Mobile Plugin: not installed</code>. This should be disregarded. The proper plugin to install for multiplatform development is the Kotlin Multiplatform plugin.</p> <p>Info</p> <p>Despite what the KDoctor checks imply, you do not need to install Android Studio to work with Amper. There is no Amper plugin for Android Studio at the moment. As mentioned above, we recommend using IntelliJ IDEA.</p>"},{"location":"setup/#whats-next","title":"What's next","text":"<p>Take your pick:</p> <ul> <li>Discover the ins and outs of Amper in our comprehensive user guide.</li> <li>Create a project from scratch by following the tutorial.</li> <li>Read how to use Amper in IntelliJ IDEA.   Try downloading and opening one of the example projects to see Amper in action.</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial gives a short introduction to Amper and how to create a new project.</p> <p>If you are looking for more detailed information, check the user guide.</p>"},{"location":"tutorial/#before-you-start","title":"Before you start","text":"<p>Check the setup instructions.</p>"},{"location":"tutorial/#step-1-hello-world","title":"Step 1. Hello, World","text":"<p>The first thing you\u2019d want to try when getting familiar with a new tool is just a simple \"Hello, World\" application. Here is what we do:</p> <p>Create a <code>module.yaml</code> file at the root of your project:</p> <pre><code>product: jvm/app\n</code></pre> <p>And add some code in the <code>src/</code> folder:</p> <pre><code>|-src/\n|  |-main.kt\n|-module.yaml\n</code></pre> <p><code>main.kt</code> file: <pre><code>fun main() {\n    println(\"Hello, World!\")\n}\n</code></pre></p> <p>You also need to add the Amper shell scripts to your root project folder.</p> <ul> <li>If you're in IntelliJ IDEA, you can simply use the quick fix in <code>module.yaml</code> to \"Configure standalone Amper\".</li> <li>If not, follow the CLI installation instructions to download them.</li> </ul> <p>Your project should now look like this: <pre><code>|-src/\n|  |-main.kt\n|-module.yaml\n|-amper\n|-amper.bat\n</code></pre></p> <p>That\u2019s it, we\u2019ve just created a simple JVM application.</p> <p>And since it\u2019s a JVM project, you can add Java code. Java and Kotlin files can reside together, no need to create separate Maven-like <code>java/</code> and <code>kotlin/</code> folders:</p> <pre><code>|-src/\n|  |-main.kt\n|  |-JavaClass.java\n|-module.yaml\n</code></pre> <p>Examples: JVM \"Hello, World!\"</p> <p>You can now build your application using <code>./amper build</code>, or run it using <code>./amper run</code>.</p> <p>To go further, you can check these sections of the documentation:</p> <ul> <li>Project layout</li> <li>Module file anatomy</li> <li>Using Amper from the command line</li> </ul>"},{"location":"tutorial/#step-2-add-dependencies","title":"Step 2. Add dependencies","text":"<p>Let's add a dependency on a Kotlin library from the Maven repository:</p> <pre><code>product: jvm/app\n\ndependencies:\n  - org.jetbrains.kotlinx:kotlinx-datetime:0.6.2\n</code></pre> <p>We can now use this library in the <code>main.kt</code> file:</p> <pre><code>import kotlinx.datetime.*\n\nfun main() {\n    println(\"Hello, World!\")\n    println(\"It's ${Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())} here\")\n}\n</code></pre> <p>See the full documentation about Dependencies.</p>"},{"location":"tutorial/#step-3-add-tests","title":"Step 3. Add tests","text":"<p>Now let\u2019s add some tests. Amper configures the testing framework automatically, we only need to add some test code into the <code>test/</code> folder:</p> <pre><code>|-src/\n|  |-...\n|-test/\n|  |-MyTest.kt\n|-module.yaml\n</code></pre> <pre><code>import kotlin.test.*\n\nclass MyTest {\n    @Test\n    fun doTest() {\n        assertTrue(true)\n    }\n}\n</code></pre> <p>To add test-specific dependencies, use the dedicated <code>test-dependencies:</code> section. This should be very familiar to Cargo, Flutter and Poetry users. As an example, let's add the MockK library to the project:</p> <pre><code>product: jvm/app\n\ndependencies:\n  - org.jetbrains.kotlinx:kotlinx-datetime:0.6.2\n\ntest-dependencies:\n  - io.mockk:mockk:1.13.10\n</code></pre> <p>Examples: JVM \"Hello, World!\"</p> <p>See the full documentation about Tests.</p>"},{"location":"tutorial/#step-4-configure-java-and-kotlin","title":"Step 4. Configure Java and Kotlin","text":"<p>Another typical task is configuring compiler settings, such as language level etc. Here is how we do it in Amper:</p> <pre><code>product: jvm/app\n\ndependencies:\n  - org.jetbrains.kotlinx:kotlinx-datetime:0.6.2\n\ntest-dependencies:\n  - io.mockk:mockk:1.13.10\n\nsettings:\n  kotlin:\n    languageVersion: 1.8  # Set Kotlin source compatibility to 1.8\n  jvm:\n    release: 17  # Set the minimum JVM version that the Kotlin and Java code should be compatible with.\n</code></pre> <p>See the full documentation about Settings.</p>"},{"location":"tutorial/#step-5-add-a-ui-with-compose","title":"Step 5. Add a UI with Compose","text":"<p>Now, let's turn the example into a GUI application. To do that we'll add the Compose Multiplatform framework. It allows building plain JVM desktop apps, which are simple for now, and paves the way for turning multiplatform later.</p> <p>Let's change our <code>module.yaml</code> to: <pre><code>product: jvm/app\n\ndependencies:\n  # ...other dependencies...\n\n  # add Compose dependencies\n  - $compose.foundation\n  - $compose.material3\n  - $compose.desktop.currentOs\n\nsettings:\n  # ...other settings...\n\n  # enable the Compose framework toolchain  \n  compose:\n    enabled: true\n</code></pre></p> <p>Note</p> <p>The <code>$compose.*</code> dependencies are declared with a special reference syntax here. These are references to the Compose toolchain library catalog, and are available because we enabled the toolchain. Read more about library catalogs in the documentation.</p> <p>We can then replace the contents of <code>main.kt</code> with the following code:</p> <pre><code>import androidx.compose.foundation.text.BasicText\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\n\nfun main() = application {\n    Window(onCloseRequest = ::exitApplication) {\n        BasicText(\"Hello, World!\")\n    }\n}\n</code></pre> <p>Now we have a GUI application!</p> <p>Examples:</p> <ul> <li>Compose Desktop</li> <li>Compose Android</li> <li>Compose iOS</li> <li>Compose Multiplatform</li> </ul> <p>See the full documentation about Compose.</p>"},{"location":"tutorial/#step-6-modularize","title":"Step 6. Modularize","text":"<p>Let's split our project into a JVM application and a library module, with shared code that we are going to reuse later when making the project multiplatform.</p> <p>Our goal here is to separate our app into a <code>shared</code> library module and a <code>jvm-app</code> application module and reach the  following structure: <pre><code>|-jvm-app/\n|  |-...\n|  |-module.yaml\n|-shared/\n|  |-...\n|  |-module.yaml\n|-amper\n|-amper.bat\n|-project.yaml\n</code></pre></p> <p>First let's move our current <code>src</code>, <code>test</code> and <code>module.yaml</code> files into a new <code>jvm-app</code> directory: <pre><code>|-jvm-app/\n|  |-src/\n|  |  |-main.kt\n|  |-test/\n|  |  |-...\n|  |-module.yaml\n|-amper\n|-amper.bat\n</code></pre></p> <p>Add a <code>project.yaml</code> file in the root, next to the existing <code>amper</code> and <code>amper.bat</code> files, with the following content:</p> <pre><code>modules:\n  - ./jvm-app\n  - ./shared\n</code></pre> <p>If you're using IntelliJ IDEA, you should see a warning that the <code>shared</code> module is missing, and you can automatically create it from here. Otherwise, just create a new <code>shared</code> directory manually, with <code>src</code> and <code>test</code> directories, and a <code>module.yaml</code> with the following content:</p> <pre><code>product:\n  type: lib\n  platforms: [jvm]\n\ndependencies:\n  - $compose.foundation: exported\n  - $compose.material3: exported\n  - $compose.desktop.currentOs: exported\n\nsettings:\n  compose:\n    enabled: true\n</code></pre> <p>Note how the library 'exports' its dependencies. The dependent module will 'see' these dependencies and don't need to explicitly depend on them.</p> <p>We can now change our <code>jvm-app/module.yaml</code> to depend on the <code>shared</code> module:</p> <pre><code>product: jvm/app\n\ndependencies:\n  - ../shared # use the 'shared' module as a dependency\n\nsettings:\n  compose:\n    enabled: true\n</code></pre> <p>Note how the dependency on the <code>shared</code> module is declared using a relative path.</p> <p>Let's extract the common code into a new <code>shared/src/hello.kt</code> file:</p> <pre><code>import androidx.compose.foundation.text.BasicText\nimport androidx.compose.runtime.Composable\n\n@Composable\nfun sayHello() {\n    BasicText(\"Hello, World!\")\n}\n</code></pre> <p>And re-use it in the <code>jvm-app/src/main.kt</code> file: <pre><code>import androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\n\nfun main() = application {\n    Window(onCloseRequest = ::exitApplication) {\n        sayHello()\n    }\n}\n</code></pre></p> <p>We now have a multi-module project with some neatly extracted shared code.</p> <p>Examples: Compose Multiplatform</p> <p>See the full documentation about: - Project layout - Module dependencies - Dependency visibility and scope</p>"},{"location":"tutorial/#step-7-make-project-multiplatform","title":"Step 7. Make project multiplatform","text":"<p>So far we've been working with a JVM platform to create a desktop application. Let's add an Android and an iOS application. It will be straightforward, since we've already prepared a multi-module layout with a shared module that we can reuse.</p> <p>Here is the project structure that we need:</p> <pre><code>|-android-app/\n|  |-src/\n|  |  |-main.kt\n|  |  |-AndroidManifest.xml\n|  |-module.yaml\n|-ios-app/\n|  |-src/\n|  |  |-iosApp.swift\n|  |  |-main.kt\n|  |-module.yaml\n|  |-module.xcodeproj\n|-jvm-app/\n|  |-...\n|-shared/\n|  |-...\n| project.yaml\n</code></pre> <p>Remember to add the new modules into the <code>project.yaml</code> file:</p> <pre><code>modules:\n  - ./android-app\n  - ./ios-app\n  - ./jvm-app\n  - ./shared   \n</code></pre> <p>The <code>android-app/module.yaml</code> will look like this way: <pre><code>product: android/app\n\ndependencies:\n  - ../shared\n\nsettings:\n  compose:\n    enabled: true\n</code></pre></p> <p>And the <code>ios-app/module.yaml</code>:</p> <pre><code>product: ios/app\n\ndependencies:\n  - ../shared\n\nsettings:\n  compose:\n    enabled: true\n</code></pre> <p>Let's update the <code>shared/module.yaml</code> and add the new platforms and a couple of additional dependencies for Android:</p> <pre><code>product:\n  type: lib\n  platforms: [ jvm, android, iosArm64, iosSimulatorArm64, iosX64 ]\n\ndependencies:\n  - $compose.foundation: exported\n  - $compose.material3: exported\n\ndependencies@jvm:\n  - $compose.desktop.currentOs: exported\n\ndependencies@android:\n  # Compose integration with Android activities\n  - androidx.activity:activity-compose:1.7.2: exported\n  - androidx.appcompat:appcompat:1.6.1: exported\n\nsettings:\n  compose:\n    enabled: true\n</code></pre> <p>Note how we used the <code>dependencies@jvm:</code> and <code>dependencies@android:</code> sections to specify JVM- and Android-specific dependencies. These dependencies will be added to the JVM and Android versions of the <code>shared</code> library correspondingly. They will also be available for the <code>jvm-app</code> and <code>android-app</code> modules, since they depend on the <code>shared</code> module. Read more about multiplatform configuration in the documentation.</p> <p>Now, as we have the module structure, we need to add platform-specific application code to the Android and iOS modules. Create a <code>MainActivity.kt</code> file in <code>android-app/src</code> with the following content:</p> <pre><code>package hello.world\n\nimport sayHello\nimport android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            sayHello()\n        }\n    }\n}\n</code></pre> <p>Next, create a <code>ViewController.kt</code> file in <code>ios-app/src</code>:</p> <pre><code>import sayHello\nimport androidx.compose.ui.window.ComposeUIViewController\n\nfun ViewController() = ComposeUIViewController { \n    sayHello() \n}\n</code></pre> <p>And the last step, copy the AndroidManifest.xml file from an example project into <code>android-app/src</code> folder, and the iosApp.swift file into the <code>ios-app/src</code>. These files bind the Compose UI code with the native application entry points.</p> <p>Make sure that your project structure looks like this: <pre><code>|-android-app/\n|  |-src/\n|  |  |-main.kt\n|  |  |-AndroidManifest.xml\n|  |-module.yaml\n|-ios-app/\n|  |-src/\n|  |  |-iosApp.swift\n|  |  |-main.kt\n|  |-module.yaml\n|-jvm-app/\n|-shared/\n|-...\n</code></pre></p> <p>Now you can build and run both apps using the IntelliJ IDEA run configurations.</p> <p>Note</p> <p>After the first build the Xcode project will appear beside the <code>module.yaml</code> in the <code>ios-app</code> module.  It can be checked into the VCS and customized (e.g. Team (<code>DEVELOPMENT_TEAM</code>) setting). See iOS Support to learn more about the Xcode \u2194 Amper interoperability.</p> <p>Examples: Compose Multiplatform</p> <p>See the full documentation about multiplatform configuration and configuring Compose Multiplatform more specifically.</p>"},{"location":"tutorial/#step-8-deduplicate-common-configuration","title":"Step 8. Deduplicate common configuration","text":"<p>You might have noticed that there are some settings present in  the <code>module.yaml</code> files. To redce duplication we can extract them into a template.</p> <p>Let's create a couple of <code>&lt;name&gt;.module-template.yaml</code> files: <pre><code>|-android-app/\n|  |-...\n|-ios-app/\n|  |-...\n|-jvm-app/\n|  |-...\n|-shared/\n|  |-...\n|-compose.module-template.yaml\n|-app.module-template.yaml\n</code></pre></p> <p>A <code>/compose.module-template.yaml</code> with settings common to all modules: <pre><code>settings:\n  compose:\n    enabled: true\n</code></pre></p> <p>and <code>/app.module-template.yaml</code> with dependencies that are used in the application modules: <pre><code>dependencies:\n  - ./shared\n</code></pre></p> <p>Now we will apply these templates to our module files:</p> <p><code>/shared/module.yaml</code>: <pre><code>product:\n  type: lib\n  platforms: [ jvm, android, iosArm64, iosSimulatorArm64, iosX64 ]\n\napply:\n  - ../compose.module-template.yaml\n\ndependencies:\n  - $compose.foundation: exported\n  - $compose.material3: exported\n\ndependencies@jvm:\n  - $compose.desktop.currentOs\n\ndependencies@android:\n  # Compose integration with Android activities\n  - androidx.activity:activity-compose:1.7.2: exported\n  - androidx.appcompat:appcompat:1.6.1: exported\n</code></pre></p> <p><code>/jvm-app/module.yaml</code>: <pre><code>product: jvm/app\n\napply:\n  - ../compose.module-template.yaml\n  - ../app.module-template.yaml\n</code></pre></p> <p><code>/android-app/module.yaml</code>: <pre><code>product: android/app\n\napply:\n  - ../compose.module-template.yaml\n  - ../app.module-template.yaml\n</code></pre></p> <p><code>/ios-app/module.yaml</code>: <pre><code>product: ios/app\n\napply:\n  - ../compose.module-template.yaml\n  - ../app.module-template.yaml\n</code></pre></p> <p>You can put all common dependencies and settings into the template. It's also possible to have multiple templates  for various typical configurations in the project.</p> <p>See the full documentation about Templates.</p>"},{"location":"tutorial/#further-steps","title":"Further steps","text":"<p>Check the user guide and explore example projects.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#using-amper-from-the-command-line","title":"Using Amper from the command line","text":""},{"location":"usage/#installation","title":"Installation","text":"<p>To use the Amper CLI, you need to download the Amper executable script to your project's root folder. The script is a small file that downloads and runs the actual Amper CLI distribution, and serves as an entry point for all Amper commands. It is meant to be checked into your VCS, so your team can build and run your project without any installation, no matter their OS.</p> <p>Use one of the following commands to download the script:</p> Linux / macOSWindows <pre><code>curl -fsSL -o amper https://jb.gg/amper-latest-wrapper.sh &amp;&amp; chmod +x amper &amp;&amp; ./amper update -c\n</code></pre> PowerShell<pre><code>Invoke-WebRequest -OutFile amper.bat -Uri https://jb.gg/amper-latest-wrapper.bat; ./amper update -c\n</code></pre> cmd.exe<pre><code>curl -fsSL -o amper.bat https://jb.gg/amper-latest-wrapper.bat &amp;&amp; call amper update -c\n</code></pre> <p>Note</p> <p>The <code>./amper update -c</code> command will automatically get the wrapper script for the other OS.  You can check both into your VCS so your team can build and run your project without any installation, on any OS.</p> <p>Note</p> <p>The first time you run the Amper script, it will take some time to download the Amper CLI distribution. Subsequent runs will be faster, as the downloaded files will be cached locally.</p>"},{"location":"usage/#exploring-amper-commands","title":"Exploring Amper commands","text":"<p>The root <code>./amper</code> command and all subcommands support the <code>-h</code> (or <code>--help</code>) option to explore what is possible:</p> <pre><code>./amper --help       # shows the available commands and general options\n./amper build --help # shows the options for the 'build' command specifically\n</code></pre> <p>Useful commands:</p> <ul> <li><code>amper init</code> to create a new Amper project</li> <li><code>amper build</code> to compile and link all code in the project</li> <li><code>amper test</code> to run tests in the project</li> <li><code>amper run</code> to run your application </li> <li><code>amper clean</code> to remove the project's build output and caches</li> </ul> <p>For example, to build and run the JVM \"Hello, World\": <pre><code>cd jvm\n./amper run \n</code></pre></p>"},{"location":"usage/#amper-cli-tab-completion","title":"Amper CLI tab-completion","text":"<p>If you\u2019re using <code>bash</code>, <code>zsh</code>, or <code>fish</code>, you can generate a completion script to source as part of your shell\u2019s configuration, to get tab completion for Amper commands.</p> <p>First, generate the completion script using the <code>generate-completion</code> command, specifying the shell you use:</p> <pre><code>./amper generate-completion zsh &gt; ~/amper-completion.sh\n</code></pre> <p>Then load the script in your shell (this can be added to <code>.bashrc</code>, <code>.zshrc</code>, or similar configuration files to load it automatically):</p> <pre><code>source ~/amper-completion.sh\n</code></pre> <p>You should now have tab completion available for Amper subcommands, options, and option values.</p>"},{"location":"usage/#updating-amper-to-a-newer-version","title":"Updating Amper to a newer version","text":"<p>Run <code>./amper update</code> to update the Amper scripts and distribution to the latest released version. Use the <code>--dev</code> option if you want to try the bleeding edge dev build of Amper (no guarantees are made on these builds).</p> <p>See <code>./amper update -h</code> for more information about the available options.</p> <p>Tip</p> <p>If you had generated a completion script before, you need to re-generate it with the new Amper version (see previous section).</p>"},{"location":"usage/#using-amper-in-intellij-idea","title":"Using Amper in IntelliJ IDEA","text":"<p>The latest IntelliJ IDEA EAP can be used to work with  JVM and Android projects.</p> <p>See the setup instructions to configure your IDE and the environment.</p> <p>Open an Amper project as usual by pointing at the root folder.</p> <p>To run an application:</p> <ul> <li> <p>use the 'run' () gutter icon next to the <code>product:</code> section in a <code>module.yaml</code> file:\\  </p> </li> <li> <p>use the 'run' () gutter icon next to the <code>main()</code> function:\\   </p> </li> <li> <p>use Run/Debug configurations:\\   \\   </p> </li> </ul> <p>To run tests, use the 'run' () gutter icon next to the test functions or classes. Read more on testing in IntelliJ IDEA. </p>"},{"location":"dsl-reference/module/","title":"Module file","text":""},{"location":"dsl-reference/module/#aliases","title":"<code>aliases</code>","text":"<p>An alias can be used to share code, dependencies, and/or settings between a group of platforms that doesn't already  have a name (an exclusive common ancestor) in the default hierarchy. Aliases can be used as <code>@platform</code> qualifiers in the settings.</p> <p>Read more about aliases.</p> <p>Examples:</p> <pre><code># Create an alias to share code between JVM and Android platforms.  \nproduct:\n  type: lib\n  platforms: [ jvm, android, iosArm64, iosSimulatorArm64 ]\n\naliases:\n  - jvmAndAndroid: [jvm, android]\n\n# Dependencies for JVM and Android platforms:\ndependencies@jvmAndAndroid:\n  ...\n</code></pre>"},{"location":"dsl-reference/module/#apply","title":"<code>apply</code>","text":"<p><code>apply:</code> section lists the templates applied to the module. Read more about the module templates</p> <p>Use <code>- ./&lt;relative path&gt;</code> or <code>- ../&lt;relative path&gt;</code> notation, where the <code>&lt;relative path&gt;</code> points at a template file.</p> <p>Examples:</p> <pre><code># Apply a `common.module-template.yaml` template to the module\nproduct: jvm/app\n\napply:\n  - ../common.module-template.yaml\n</code></pre>"},{"location":"dsl-reference/module/#dependencies-and-test-dependencies","title":"<code>dependencies</code> and <code>test-dependencies</code>","text":"<p><code>dependencies:</code> section defines the list of modules and libraries necessary to build the module. Certain dependencies can also be exported as part of the module API. Read more about the dependencies.</p> <p><code>test-dependencies:</code> section defines the dependencies necessary to build and run tests of the module. Read more about the module tests.</p> <p>Supported dependency types:</p> Notation Description <code>- ./&lt;relative path&gt;</code><code>- ../&lt;relative path&gt;</code> Dependency on another module in the codebase. <code>- &lt;group ID&gt;:&lt;artifact ID&gt;:&lt;version&gt;</code> Dependency on a Kotlin or Java library in a Maven repository. <code>- $&lt;catalog.key&gt;</code> Dependency from a dependency catalog. <code>- bom: &lt;group ID&gt;:&lt;artifact ID&gt;:&lt;version&gt;</code> Dependency on a BOM. <code>- bom: $&lt;catalog.key&gt;</code> Dependency on a BOM from a dependency catalog. <p>Each dependency (except BOM) has the following attributes:</p> Attribute Description Default <code>exported: boolean</code> Whether a dependency should be visible as a part of a published API. <code>false</code> <code>scope: enum</code> When the dependency should be used. Read more about the dependency scopes. <code>all</code> <p>Available scopes:</p> Scopes Description <code>all</code> The dependency is available during compilation and runtime. <code>compile-only</code> The dependency is only available during compilation. This is a 'provided' dependency in Maven terminology. <code>runtime-only</code> The dependency is not available during compilation, but available during testing and running. <p>Examples:</p> <pre><code># Short form for the dependency attributes\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0                   # Kotlin or Java dependency \n  - org.postgresql:postgresql:42.3.3: runtime-only\n  - ../common-types: exported                        # Dependency on another module in the codebase \n  - $compose.foundation                              # Dependency from the 'compose' catalog\n  - bom: io.ktor:ktor-bom:2.2.0                      # Importing BOM \n  - io.ktor:ktor-serialization-kotlinx-json          # Kotlin or Java dependency with a version resolved from BOM\n</code></pre> <pre><code># Full form for the dependency attributes\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0\n  - ../common-types:\n      exported: true\n      scope: all\n  - org.postgresql:postgresql:42.3.3:\n      exported: false\n      scope: runtime-only\n</code></pre> <p>The <code>dependencies:</code> section can also be qualified with a platform.</p> <p>Examples:</p> <pre><code># Dependencies used to build the common part of the product\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0\n\n# Dependencies used to build the JVM part of the product\ndependencies@jvm:\n  - io.ktor:ktor-client-java:2.2.0\n  - org.postgresql:postgresql:42.3.3: runtime-only\n</code></pre>"},{"location":"dsl-reference/module/#layout","title":"<code>layout</code>","text":"<p><code>layout</code> is a top-level field defines the module file structure. Field can accept values: <code>amper</code> and <code>maven-like</code>. The default value is <code>amper</code> which is the default module file layout.</p> <p>Examples:</p> <pre><code>product: jvm/app\n\nlayout: maven-like\n\nsettings:\n  # ...\n</code></pre>"},{"location":"dsl-reference/module/#product","title":"<code>product</code>","text":"<p>The <code>product:</code> section defines what should be produced out of the module. Read more about the product types.</p> Attribute Description <code>type: enum</code> What type of product to generate. <code>platform: enum list</code> What platforms to generate the product for. <p>Supported product types and platforms:</p> Product Type Description Platforms <code>lib</code> A reusable multiplatform library that other modules can depend on. any (the list must be specified explicitly) <code>jvm/lib</code> A JVM library that other modules can depend on. <code>jvm</code> <code>jvm/app</code> A JVM console or desktop application. <code>jvm</code> <code>linux/app</code> A native Linux application. <code>linuxX86</code>, <code>linuxArm64</code> <code>windows/app</code> A native Windows application. <code>mingwX64</code> <code>macos/app</code> A native macOS application. <code>macosX64</code>, <code>macosArm64</code> <code>android/app</code> An Android VM application. <code>android</code> <code>ios/app</code> An iOS application. device: <code>iosArm64</code>, simulators: <code>iosX64</code>, <code>iosSimulatorArm64</code> <code>js/app</code> A JavaScript application. <code>js</code> <code>wasmJs/app</code> A Wasm (JS) application. <code>wasmJs</code> <code>wasmWasi/app</code> A Wasm (WASI) application. <code>wasmWasi</code> <p>Check the list of all Kotlin Multiplatform targets and the level of their support.</p> <p>Examples:</p> <pre><code># Short form, defaults to all supported platforms for the corresponding target:\nproduct: macos/app\n</code></pre> <pre><code># Full form, with an explicitly specified platform\nproduct:\n  type: macos/app\n  platforms: [ macosArm64, macosArm64 ]\n</code></pre> <pre><code># Multiplatform Library for JVM and Android platforms \nproduct:\n  type: lib\n  platforms: [ jvm, android ]\n</code></pre>"},{"location":"dsl-reference/module/#repositories","title":"<code>repositories</code>","text":"<p><code>repositories:</code> section defines the list of repositories used to look up and download the module dependencies. Read more about the dependency repositories.</p> Attribute Description Default <code>url: string</code> The url of the repository. <code>id: string</code> The ID of the repository, used for to reference it. repository url <code>credentials: object</code> Credentials for the authenticated repositories. empty <p>Read more on the repository configuration Credentials support username/password authentication and have the following attributes:</p> Attribute Description <code>file: path</code> A relative path to a file with the credentials. Currently, only <code>*.property</code> files are supported. <code>usernameKey: string</code> A key in the file that holds the username. <code>passwordKey: string</code> A key in the file that holds the password. <p>Examples:</p> <pre><code># Short form\nrepositories:\n  - https://repo.spring.io/ui/native/release\n  - https://jitpack.io\n</code></pre> <pre><code># Full form\nrepositories:\n  - url: https://repo.spring.io/ui/native/release\n  - id: jitpack\n    url: https://jitpack.io\n</code></pre> <pre><code># Specifying the credentials\nrepositories:\n  - url: https://my.private.repository/\n    credentials:\n      file: ./local.properties\n      usernameKey: my.private.repository.username\n      passwordKey: my.private.repository.password  \n</code></pre>"},{"location":"dsl-reference/module/#settings-and-test-settings","title":"<code>settings</code> and <code>test-settings</code>","text":"<p><code>settings:</code> section configures the toolchains used in the build process. Read more about settings configuration.</p> <p><code>test-settings:</code> section controls building and running the module tests. Read more about the module tests.</p>"},{"location":"dsl-reference/module/#settingsandroid","title":"<code>settings.android</code>","text":"<p><code>settings:android:</code> configures the Android toolchain and platform.</p> Attribute Description Default <code>applicationId: string</code> The ID for the application on a device and in the Google Play Store. Read more. (namespace) <code>namespace: string</code> A Kotlin or Java package name for the generated <code>R</code> and <code>BuildConfig</code> classes. Read more. org.example.namespace <code>compileSdk: int</code> The API level to compile the code. The code can use only the Android APIs up to that API level. Read more. (targetSdk) <code>targetSdk: int</code> The target API level for the application. Read more. 35 <code>minSdk: int</code> Minimum API level needed to run the application. Read more. 21 <code>maxSdk: int</code> Maximum API level on which the application can run. Read more. <code>signing: object</code> Android signing settings. Read more. <code>versionCode: int</code> Version code. Read more. 1 <code>versionName: string</code> Version name. Read more. unspecified <code>parcelize: object \\| string</code> Configure Parcelize."},{"location":"dsl-reference/module/#settingsandroidparcelize","title":"<code>settings.android.parcelize</code>","text":"<p><code>settings:android:parcelize</code> configures Parcelize for the Android platform in the module. The value can be the simple <code>enabled</code> string, or an object with the following attributes:</p> Attribute Description Default <code>enabled: boolean</code> Whether to enable Parcelize. When enabled, an implementation of the <code>Parcelable</code> interface is automatically generated for classes annotated with <code>@Parcelize</code>. <code>additionalAnnotations: string list</code> The full-qualified names of additional annotations that should be considered as <code>@Parcelize</code>. This is useful if you need to annotate classes in common code shared between different platforms, where the real <code>@Parcelize</code> annotation is not available. In that case, create your own common annotation and add its fully-qualified name so that Parcelize recognizes it. (empty) <pre><code># Enables Parcelize to process @Parcelize-annotated classes (short form)\nsettings:\n  android:\n    parcelize: enabled\n</code></pre> <pre><code># Enables Parcelize, and configures it to process a custom @com.example.MyCommonParcelize annotation\nsettings:\n  android:\n    parcelize:\n      enabled: true\n      additionalAnnotations: [ com.example.MyCommonParcelize ]\n</code></pre>"},{"location":"dsl-reference/module/#settingsandroidsigning","title":"<code>settings.android.signing</code>","text":"<p><code>settings:android:signing:</code> configures signing of Android apps Read more</p> Attribute Description Default <code>enabled: boolean</code> Whether signing enabled or not. Read more. false <code>propertiesFile: path</code> Location of properties file. Read more. ./keystore.properties"},{"location":"dsl-reference/module/#settingscompose","title":"<code>settings.compose</code>","text":"<p><code>settings:compose:</code> configures the Compose Multiplatform framework. Read more about Compose configuration.</p> Attribute Description Default <code>enabled: boolean</code> Enable Compose runtime, dependencies and the compiler plugins. <code>false</code> <code>version: string</code> The Compose plugin version to use. <code>1.7.3</code> <code>resources: object</code> Compose Resources settings. <code>experimental: object</code> Experimental Compose settings. <p><code>settings:compose:resources:</code> configures Compose Resources settings.</p> Attribute Description Default <code>packageName: string</code> A unique identifier for the resources in the current module. Used as package for the generated Res class and for isolating resources in the final artifact. <code>\"\"</code> <code>exposedAccessors: boolean</code> Whether the generated resources accessors should be exposed to other modules (public) or internal. <code>false</code> <p><code>settings:compose:experimental:</code> configures experimental Compose features.</p> Attribute Description Default <code>hotReload: object</code> Experimental Compose hot-reload settings. <p><code>settings:compose:experimental:hotReload:</code> configures experimental hot reload.</p> Attribute Description Default <code>enabled: boolean</code> Enable hot reload <code>false</code> <p>Examples:</p> <pre><code># Short form\nsettings:\n  compose: enabled\n</code></pre> <pre><code># Full form\nsettings:\n  compose:\n    enabled: true\n    version: 1.6.10\n</code></pre> <pre><code># Full form with resources configuration\nsettings:\n  compose:\n    enabled: true\n    version: 1.6.10\n    resources:\n      packageName: \"com.example.myapp.resources\"\n      exposedAccessors: true\n</code></pre> <pre><code># With experimental hot reload enabled\nsettings:\n  compose:\n    enabled: true\n    experimental:\n      hotReload: enabled\n</code></pre>"},{"location":"dsl-reference/module/#settingsjava","title":"<code>settings.java</code>","text":"<p><code>settings:java:</code> configures the Java language and the compiler.</p> Attribute Description Default <code>annotationProcessing: object</code> Java annotation processing settings (empty)"},{"location":"dsl-reference/module/#settingsjavaannotationprocessing","title":"<code>settings.java.annotationProcessing</code>","text":"<p><code>settings:java:annotationProcessing:</code> configures Java annotation processing.</p> Attribute Description Default <code>processors: list</code> The list of annotation processors to use. Each item can be a path to a local module, a catalog reference, or maven coordinates (empty) <code>processorOptions: map</code> Options to pass to annotation processors (empty) <p>Examples:</p> <pre><code># Add an annotation processor\nsettings:\n  java:\n    annotationProcessing:\n      processors:\n        - org.mapstruct:mapstruct-processor:1.6.3\n</code></pre> <pre><code># Add an annotation processor with options\nsettings:\n  java:\n    annotationProcessing:\n      processors:\n        - $libs.auto.service # using catalog reference\n      processorOptions:\n        debug: true\n</code></pre>"},{"location":"dsl-reference/module/#settingsjunit","title":"<code>settings.junit</code>","text":"<p><code>settings:junit:</code> configures the JUnit test runner on the JVM and Android platforms. Read more about testing support.</p> <p>By default, JUnit 5 is used.</p> Value Description <code>junit-5</code> JUnit 5 dependencies and the test runner are configured (default). <code>junit-4</code> JUnit 4 dependencies and the test runner are configured. <code>none</code> JUnit is not automatically configured."},{"location":"dsl-reference/module/#settingsjvm","title":"<code>settings.jvm</code>","text":"<p><code>settings:jvm:</code> configures the JVM platform-specific settings.</p> Attribute Description Default <code>release: enum</code> The minimum JVM release version that the code should be compatible with. This enforces compatibility on 3 levels. First, it is used as the target version for the bytecode generated from Kotlin and Java sources. Second, it limits the Java platform APIs available to Kotlin and Java sources. Third, it limits the Java language constructs in Java sources. If this is set to null, these constraints are not applied and the compiler defaults are used. 17 <code>mainClass: string</code> (Only for <code>jvm/app</code> product type) The fully-qualified name of the class used to run the application. auto-detected <code>storeParameterNames: boolean</code> Enables storing formal parameter names of constructors and methods in the generated class files. These can later be accessed using reflection. false"},{"location":"dsl-reference/module/#settingsjvmtest","title":"<code>settings.jvm.test</code>","text":"<p><code>settings:jvm:test:</code> configures the test settings on the JVM and Android platforms. Read more about testing support.</p> Value Description <code>systemProperties: map</code> JVM system properties for the test process. <code>jvmFreeArgs: string list</code> Free JVM arguments for the test process."},{"location":"dsl-reference/module/#settingskotlin","title":"<code>settings.kotlin</code>","text":"<p><code>settings:kotlin:</code> configures the Kotlin language and the compiler.</p> Attribute Description Default <code>languageVersion: enum</code> Provide source compatibility with the specified version of Kotlin. 2.1 <code>apiVersion: enum</code> Allow using declarations only from the specified version of Kotlin bundled libraries. (languageVersion) <code>allWarningsAsErrors: boolean</code> Turn any warnings into a compilation error. <code>false</code> <code>suppressWarnings: boolean</code> Suppress the compiler from displaying warnings during compilation. <code>false</code> <code>verbose: boolean</code> Enable verbose logging output which includes details of the compilation process. <code>false</code> <code>progressiveMode: boolean</code> Enable the progressive mode for the compiler. <code>false</code> <code>optIns: enum list</code> Enable usages of API that requires opt-in with a requirement annotation with the given fully qualified name. (empty) <code>freeCompilerArgs: string list</code> Pass any compiler option directly. <code>debug: boolean</code> (Only for native targets) Enable emitting debug information. <code>true</code> <code>serialization: object \\| enum</code> Configure Kotlin serialization. <code>allOpen: object</code> Configure the Kotlin all-open compiler plugin. <code>noArg: object</code> Configure the Kotlin no-arg compiler plugin. <p>The <code>serialization:</code> attribute is an object with the following properties:</p> Attribute Description Default <code>enabled: boolean</code> Enable the <code>@Serializable</code> annotation processing, and add the core serialization library. When enabled, a built-in catalog for kotlinx.serialization format dependencies is provided. <code>false</code> <code>format: enum</code> A shortcut for <code>enabled: true</code> and adding the given serialization format dependency. For instance, <code>json</code> adds the JSON format in addition to enabling serialization. <code>version: string</code> The version to use for the core serialization library and the serialization formats. <code>1.7.3</code> <p>You can also use a short form and directly specify <code>serialization: enabled</code> or <code>serialization: json</code>.</p> <p>Examples:</p> <pre><code># Set Kotlin language version and opt-ins\nsettings:\n  kotlin:\n    languageVersion: 1.8\n    optIns: [ kotlin.io.path.ExperimentalPathApi ]\n</code></pre> <pre><code># Enable Kotlin Serialization with the JSON format\nsettings:\n  kotlin:\n    serialization: json\n</code></pre> <pre><code># Enable Kotlin Serialization with the JSON format and a specific version \nsettings:\n  kotlin:\n    serialization: \n      format: json\n      version: 1.7.3\n</code></pre> <pre><code># Enable Kotlin Serialization with multiple formats\nsettings:\n  kotlin:\n    serialization: enabled\n\ndependencies:\n  - $kotlin.serialization.json\n  - $kotlin.serialization.protobuf\n</code></pre> <pre><code># Enable Kotlin Serialization with multiple formats and a specific version \nsettings:\n  kotlin:\n    serialization: \n      enabled: true\n      version: 1.7.3\n\ndependencies:\n  - $kotlin.serialization.json\n  - $kotlin.serialization.protobuf\n</code></pre>"},{"location":"dsl-reference/module/#settingskotlinallopen","title":"<code>settings.kotlin.allOpen</code>","text":"<p><code>settings:kotlin:allOpen</code> configures the Kotlin all-open compiler plugin, which makes classes annotated with specific annotations open automatically without the explicit <code>open</code> keyword.</p> Attribute Description Default <code>enabled: boolean</code> Enable the Kotlin all-open compiler plugin <code>false</code> <code>annotations: string list</code> List of annotations that trigger open class/method generation (empty) <code>presets: enum list</code> Predefined sets of annotations for common frameworks (available presets: <code>spring</code>, <code>micronaut</code>, and <code>quarkus</code>) (empty) <p>Examples:</p> <pre><code># Enable all-open with custom annotations\nsettings:\n  kotlin:\n    allOpen:\n      enabled: true\n      annotations: [ com.example.MyOpen, com.example.MyFramework.Open ]\n</code></pre> <pre><code># Enable all-open with Spring preset\nsettings:\n  kotlin:\n    allOpen:\n      enabled: true\n      presets: [ spring ]\n</code></pre>"},{"location":"dsl-reference/module/#settingskotlinnoarg","title":"<code>settings.kotlin.noArg</code>","text":"<p><code>settings:kotlin:noArg</code> configures the Kotlin no-arg compiler plugin, which generates no-arg constructors for classes with specific annotations.</p> Attribute Description Default <code>enabled: boolean</code> Enable the Kotlin no-arg compiler plugin <code>false</code> <code>annotations: string list</code> List of annotations that trigger no-arg constructor generation (empty) <code>invokeInitializers: boolean</code> Whether to call initializers in the synthesized constructor <code>false</code> <code>presets: enum list</code> Predefined sets of annotations (currently only <code>jpa</code> preset for JPA entity annotations) (empty) <p>Examples:</p> <pre><code># Enable no-arg for JPA entities\nsettings:\n  kotlin:\n    noArg:\n      enabled: true\n      presets: [ jpa ]\n</code></pre> <pre><code># Enable no-arg with custom annotations and initializers\nsettings:\n  kotlin:\n    noArg:\n      enabled: true\n      annotations: [ com.example.NoArg ]\n      invokeInitializers: true\n</code></pre>"},{"location":"dsl-reference/module/#settingsktor","title":"<code>settings.ktor</code>","text":"<p><code>settings:ktor:</code> configures the Ktor.</p> Attribute Description Default <code>enabled: boolean</code> Enable Ktor <code>false</code> <code>version: string</code> Ktor version <code>3.1.1</code> <p>Example:</p> <pre><code>settings:\n  ktor:\n    enabled: true\n    version: 2.3.2 # version customization\n</code></pre>"},{"location":"dsl-reference/module/#settingslombok","title":"<code>settings.lombok</code>","text":"<p><code>settings:lombok:</code> configures Lombok.</p> Attribute Description Default <code>enabled: boolean</code> Enable Lombok <code>false</code> <p>Example:</p> <pre><code>settings:\n  lombok:\n    enabled: true\n</code></pre>"},{"location":"dsl-reference/module/#settingsnative","title":"<code>settings.native</code>","text":"<p><code>settings:native:</code> configures settings specific to native applications.</p> Attribute Description Default <code>entryPoint: string</code> The fully-qualified name of the application's entry point function <code>null</code> <p>Example:</p> <pre><code># Configure native settings for the module\nsettings:\n  native:\n    entryPoint: com.example.MainKt.main\n</code></pre>"},{"location":"dsl-reference/module/#settingsspringboot","title":"<code>settings.springBoot</code>","text":"<p><code>settings:springBoot:</code> configures the Spring Boot framework (JVM platform only).</p> Attribute Description Default <code>enabled: boolean</code> Enable Spring Boot <code>false</code> <code>version: string</code> Spring Boot version <code>3.4.3</code> <p>Example:</p> <pre><code>settings:\n  springBoot:\n    enabled: true\n    version: 3.1.0 # version customization\n</code></pre>"},{"location":"dsl-reference/project/","title":"Project file","text":""},{"location":"dsl-reference/project/#modules","title":"<code>modules</code>","text":"<p>The <code>modules:</code> section lists all the modules in the project, except the root module. If a <code>module.yaml</code> is present at the root of the project, the root module is implicitly included and doesn't need to be listed.</p> <p>Each element in the list must be the path to a module directory, relative to the project root. A module directory must contain a <code>module.yaml</code> file.</p> <p>Example:</p> <pre><code># include the `app` and `lib1` modules explicitly:\nmodules:\n  - ./app\n  - ./libs/lib1\n</code></pre> <p>You can also use Glob patterns to include multiple module directories at the same time. Only directories that contain a <code>module.yaml</code> file will be considered when matching a glob pattern.</p> <ul> <li><code>*</code> matches zero or more characters of a path name component without crossing directory boundaries</li> <li><code>?</code> matches exactly one character of a path name component</li> <li><code>[abc]</code> matches exactly one character of the given set (here <code>a</code>, <code>b</code>, or <code>c</code>). A dash (<code>-</code>) can be used to match a range, such as <code>[a-z]</code>.</li> </ul> <p>Using <code>**</code> to recursively match directories at multiple depth levels is not supported.</p> <p>Example:</p> <pre><code># include all direct subfolders in the `plugins` dir that contain `module.yaml` files:\nmodules:\n  - ./plugins/*\n</code></pre>"},{"location":"user-guide/","title":"User Guide","text":"<p>This is the comprehensive documentation of Amper. Here, you can learn everything about Amper concepts and built-in support for some popular technologies.</p>"},{"location":"user-guide/basics/","title":"Basic concepts","text":"<p>An Amper project is defined by a <code>project.yaml</code> file. This file contains the list of modules and the project-wide configuration. The folder with the <code>project.yaml</code> file is the project root. Modules can only be located under the  project root (at any depth). If there is only one module in the project, the <code>project.yaml</code> file is not required.</p> <p>An Amper module is a directory with a <code>module.yaml</code> configuration file, sources, and resources. A module configuration file describes what to produce: e.g. a reusable library or a platform-specific application. Each module describes a single product. Several modules can't share the same sources or resources, but they can depend  on each other. How to produce the desired product, that is, the build rules, is the responsibility of the Amper build engine.</p> <p>If you are not familiar with YAML, see our brief YAML primer.</p> <p>Amper supports Kotlin Multiplatform as a core concept and offers special syntax to deal with multiplatform configuration. There is a dedicated @platform-qualifier used to mark platform-specific dependencies, settings, etc. You'll see it in the examples below.</p>"},{"location":"user-guide/basics/#project-layout","title":"Project layout","text":"<p>A basic single-module Amper project looks like this:</p> <pre><code>|-src/             \n|  |-main.kt      \n|-test/       \n|  |-MainTest.kt \n|-module.yaml\n</code></pre> <p>If there are multiple modules, the <code>project.yaml</code> file specifies the list of modules:</p> <pre><code>|-app/\n|  |-src/             \n|  |  |-main.kt\n|  |-...      \n|  |-module.yaml\n|-lib/\n|  |-src/             \n|  |  |-util.kt      \n|  |-module.yaml\n|-project.yaml\n</code></pre> <p>In the above case, the <code>project.yaml</code> looks like this:</p> <pre><code>modules:\n  - ./app\n  - ./lib\n</code></pre> <p>Check the reference for more options to define the list of modules in the  <code>project.yaml</code> file.</p>"},{"location":"user-guide/basics/#source-code","title":"Source code","text":"<p>Source files are located in the <code>src</code> folder:</p> <pre><code>|-src/             \n|  |-main.kt      \n|-module.yaml\n</code></pre> <p>By convention, a <code>main.kt</code> file, if present, is the default entry point for the application. Read more on configuring the application entry points.</p> <p>In a JVM module, you can mix Kotlin and Java source files:</p> <pre><code>|-src/             \n|  |-main.kt      \n|  |-Util.java      \n|-module.yaml\n</code></pre> <p>In a multiplatform module, platform-specific code is located in folders with <code>@platform</code>-qualifiers:</p> <pre><code>|-src/             # common code\n|  |-main.kt      \n|  |-util.kt       #  API with \u2018expect\u2019 part\n|-src@ios/         # code to be compiled only for iOS targets\n|  |-util.kt       #  API implementation with \u2018actual\u2019 part for iOS\n|-src@jvm/         # code to be compiled only for JVM targets\n|  |-util.kt       #  API implementation with \u2018actual\u2019 part for JVM\n|-module.yaml\n</code></pre> <p>Sources and resources can't be shared by multiple modules. This ensures that the IDE always knows how to analyze and refactor the code, as it always exists in the scope of a single module, has a well-defined list of dependencies, etc.</p>"},{"location":"user-guide/basics/#resources","title":"Resources","text":"<p>Files placed into the <code>resources</code> folder are copied to the resulting products:</p> <pre><code>|-src/             \n|  |-...\n|-resources/     # These files are copied into the final products\n|  |-...\n</code></pre> <p>In multiplatform modules, resources are merged from the common folders and corresponding platform-specific folders: <pre><code>|-src/             \n|  |-...\n|-resources/          # these resources are copied into the Android and JVM artifact\n|  |-...\n|-resources@android/  # these resources are copied into the Android artifact\n|  |-...\n|-resources@jvm/      # these resources are copied into the JVM artifact\n|  |-...\n</code></pre></p> <p>In case of duplicated names, the common resources are overwritten by the more specific ones. That is <code>resources/foo.txt</code> will be overwritten by <code>resources@android/foo.txt</code>.</p> <p>Android modules also have <code>res</code> and <code>assets</code>  folders:</p> <pre><code>|-src/             \n|  |-...\n|-res/\n|  |-drawable/\n|  |  |-...\n|  |-layout/\n|  |  |-...\n|  |-...\n|-assets/\n|  |-...\n|-module.yaml\n</code></pre>"},{"location":"user-guide/basics/#module-file-anatomy","title":"Module file anatomy","text":"<p>A <code>module.yaml</code> file has several main sections: <code>product:</code>, <code>dependencies:</code> and <code>settings:</code>. A module can produce a single product, such as a reusable library or an application. Read more on the supported product types below.</p> <p>Here is an example of a JVM console application with a single dependency and a specified Kotlin language version: <pre><code>product: jvm/app\n\ndependencies:\n  - io.ktor:ktor-client-core:2.3.0\n\nsettings:\n  kotlin:\n    languageVersion: 1.9\n</code></pre></p> <p>Example of a KMP library: <pre><code>product: \n  type: lib\n  platforms: [android, iosArm64]\n\nsettings:\n  kotlin:\n    languageVersion: 1.9\n</code></pre></p>"},{"location":"user-guide/basics/#product-types","title":"Product types","text":"<p>Product type describes the target platform and the type of the project at the same time. Below is the list of supported product types:</p> <ul> <li><code>lib</code> - a reusable Kotlin Multiplatform library which can be used as a dependency by other modules in the Amper project</li> <li><code>jvm/lib</code> - a reusable JVM library which can be used as a dependency by other modules in the Amper project</li> <li><code>jvm/app</code> - a JVM console or desktop application</li> <li><code>windows/app</code> - a mingw64 application</li> <li><code>linux/app</code> - a native linux application</li> <li><code>macos/app</code> - a native macOS application</li> <li><code>android/app</code> - an Android VM application</li> <li><code>ios/app</code> - an iOS/iPadOS application</li> </ul>"},{"location":"user-guide/basics/#multiplatform-configuration","title":"Multiplatform configuration","text":"<p><code>dependencies:</code> and <code>setting:</code> sections can be specialized for each platform using the <code>@platform</code>-qualifier. An example of a multiplatform library with some common and platform-specific code: <pre><code>product:\n  type: lib\n  platforms: [iosArm64, android]\n\n# These dependencies are available in common code.\n# They are also propagated to iOS and Android code, along with their platform-specific counterparts \ndependencies:\n  - io.ktor:ktor-client-core:2.3.0\n\n# These dependencies are available in Android code only\ndependencies@android:\n  - io.ktor:ktor-client-android:2.3.0\n  - com.google.android.material:material:1.5.0\n\n# These dependencies are available in iOS code only\ndependencies@ios:\n  - io.ktor:ktor-client-darwin:2.3.0\n\n# These settings are for common code.\n# They are also propagated to iOS and Android code \nsettings:\n  kotlin:\n    languageVersion: 1.8\n  android:\n    compileSdk: 33\n\n# We can add or override settings for specific platforms. \n# Let's override the Kotlin language version for iOS code: \nsettings@ios:\n  kotlin:\n    languageVersion: 1.9 \n</code></pre> See details on multiplatform configuration in the dedicated multiplatform section.</p>"},{"location":"user-guide/basics/#settings","title":"Settings","text":"<p>The <code>settings:</code> section contains toolchains settings. A toolchain is an SDK (Kotlin, Java, Android, iOS) or a simpler tool (linter, code generator).</p> <p>All toolchain settings are specified in dedicated groups in the <code>settings:</code> section: <pre><code>settings:\n  kotlin:\n    languageVersion: 1.8\n  android:\n    compileSdk: 31\n</code></pre></p> <p>Here is the list of currently supported toolchains and their settings.</p> <p>See the multiplatform section for more details about how multiple settings sections interact in multiplatform modules.</p>"},{"location":"user-guide/basics/#configuring-entry-points","title":"Configuring entry points","text":""},{"location":"user-guide/basics/#jvm","title":"JVM","text":"<p>By default, the entrypoint of JVM applications (the <code>main</code> function) is expected to be in a <code>main.kt</code> file (case-insensitive) in the <code>src</code> folder.</p> <p>This can be overridden by specifying a main class explicitly in the module settings: <pre><code>product: jvm/app\n\nsettings:\n  jvm:\n    mainClass: org.example.myapp.MyMainKt\n</code></pre></p> <p>Note</p> <p>In Kotlin, unlike Java, the <code>main</code> function doesn't have to be declared in a class, and is usually at the top level of the file. However, the JVM still expects a main class when running any application. Kotlin always compiles  top-level declarations to a class, and the name of that class is derived from the name of the file by capitalizing  the name and turning the <code>.kt</code> extension into a <code>Kt</code> suffix.</p> <p>For example, the top-level declarations of <code>myMain.kt</code> will be in a class named <code>MyMainKt</code>.</p>"},{"location":"user-guide/basics/#native","title":"Native","text":"<p>By default, the entrypoint of Kotlin native applications (the <code>main</code> function) is expected to be in a <code>main.kt</code> file (case-insensitive) in the <code>src</code> folder.</p> <p>This can be overridden by specifying the fully qualified name of the <code>main</code> function explicitly in the module settings:</p> <pre><code>product: jvm/app\n\nsettings:\n  native:\n    entryPoint: org.example.myapp.main\n</code></pre>"},{"location":"user-guide/basics/#android","title":"Android","text":"<p>Android apps have their own way to configure the entry point, see the  dedicated Android section.</p>"},{"location":"user-guide/basics/#ios","title":"iOS","text":"<p>iOS apps have their own way to configure the entry point, see the dedicated iOS section.</p>"},{"location":"user-guide/basics/#packaging","title":"Packaging","text":"<p>Amper provides a <code>package</code> command to build a project for distribution.</p> <p>For <code>jvm/app</code> modules it produces executable jars which follow  The Executable Jar Format. The executable JAR format, while commonly associated with Spring applications, is a universal packaging solution suitable for any JVM application. This format provides a convenient, runnable self-contained deployment unit that includes all necessary dependencies, but unlike the \"fat jar\" approach, it doesn't suffer from the problems of handling duplicate files.</p> <p>For <code>android/app</code> modules, see the dedicated Android packaging section.</p>"},{"location":"user-guide/dependencies/","title":"Dependencies","text":""},{"location":"user-guide/dependencies/#external-maven-dependencies","title":"External Maven dependencies","text":"<p>Maven dependencies can be added via their coordinates using the usual <code>:</code>-separated notation:</p> <pre><code>dependencies:\n  - org.jetbrains.kotlin:kotlin-serialization:1.8.0\n  - io.ktor:ktor-client-core:2.2.0\n</code></pre>"},{"location":"user-guide/dependencies/#module-dependencies","title":"Module dependencies","text":"<p>To depend on another Module, use a relative path to the folder which contains the corresponding <code>module.yaml</code>. The path should start either with <code>./</code> or <code>../</code>.</p> <p>Note</p> <p>Dependencies between modules are only allowed within the project scope. That is, they must be listed in the <code>project.yaml</code> file.</p> <p>Example: given the project layout</p> <pre><code>root/\n  |-app/\n  |  |-src/\n  |  |-module.yaml\n  |-ui/\n  |  |-utils/\n  |  |  |-src/\n  |  |  |-module.yaml\n</code></pre> <p>The <code>app/module.yaml</code> can declare a dependency on <code>ui/utils</code> as follows:</p> <pre><code>dependencies:\n  - ../ui/utils\n</code></pre> <p>Other examples of the internal dependencies:</p> <pre><code>dependencies:\n  - ./nested-folder-with-module-yaml\n  - ../sibling-folder-with-module-yaml\n</code></pre>"},{"location":"user-guide/dependencies/#scopes-and-visibility","title":"Scopes and visibility","text":"<p>There are three dependency scopes:</p> <ul> <li><code>all</code> - (default) the dependency is available during compilation and runtime.</li> <li><code>compile-only</code> - the dependency is only available during compilation. This is a 'provided' dependency in Maven terminology.</li> <li><code>runtime-only</code> - the dependency is not available during compilation, but available during testing and running</li> </ul> <p>In a full form you can declare scope as follows:</p> <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0:\n      scope: compile-only \n  - ../ui/utils:\n      scope: runtime-only \n</code></pre> <p>There is also an inline form:</p> <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0: compile-only  \n  - ../ui/utils: runtime-only\n</code></pre> <p>All dependencies by default are not accessible from the dependent code. In order to make a dependency visible to a dependent module, you need to explicitly mark it as <code>exported</code> (this is equivalent to declaring a dependency using the <code>api()</code> configuration in Gradle).</p> <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0:\n      exported: true \n  - ../ui/utils:\n      exported: true \n</code></pre> <p>There is also an inline form:</p> <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0: exported\n  - ../ui/utils: exported\n</code></pre> <p>Here is an example of a <code>compile-only</code> and <code>exported</code> dependency:</p> <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0:\n      scope: compile-only\n      exported: true\n</code></pre>"},{"location":"user-guide/dependencies/#bom-dependencies","title":"BOM dependencies","text":"<p>To import a BOM (Bill of materials), specify its coordinates prefixed by <code>bom:</code></p> <pre><code>dependencies:\n  - bom: io.ktor:ktor-bom:2.2.0\n  - io.ktor:ktor-client-core \n</code></pre> <p>After a BOM is imported, the versions of the dependencies declared in the module can be omitted, unspecified versions are resolved from the BOM. Dependency versions declared in the BOM participate in version conflict resolution.</p>"},{"location":"user-guide/dependencies/#library-catalogs-aka-version-catalogs","title":"Library Catalogs (a.k.a Version Catalogs)","text":"<p>A library catalog associates keys to library coordinates (including the version), and allows adding the same libraries as dependencies to multiple modules without having to repeat the coordinates or the versions of the libraries.</p> <p>Amper currently supports 2 types of dependency catalogs:</p> <ul> <li>toolchain catalogs (such as Kotlin, Compose Multiplatform etc.)</li> <li>Gradle version catalogs that are placed in the default gradle/libs.versions.toml file</li> </ul> <p>The toolchain catalogs are implicitly defined, and contain predefined libraries that relate to the corresponding toolchain. The name of such a catalog corresponds to the name of the corresponding toolchain in the settings section. For example, dependencies for the Compose Multiplatform frameworks are accessible using the <code>$compose</code> catalog. All dependencies in such catalogs usually have the same version, which is the toolchain version.</p> <p>The Gradle version catalogs are user-defined catalogs using the Gradle format. Dependencies from this catalog can be accessed via the <code>$libs</code> catalog, and the library keys are defined according to the Gradle name mapping rules.</p> <p>To use dependencies from catalogs, use the syntax <code>$&lt;catalog-name&gt;.&lt;key&gt;</code> instead of the coordinates, for example: <pre><code>dependencies:\n  - $kotlin.reflect      # dependency from the Kotlin catalog\n  - $compose.material3   # dependency from the Compose Multiplatform catalog\n  - $libs.commons.lang3  # dependency from the Gradle default libs.versions.toml catalog\n</code></pre></p> <p>Catalog dependencies can still have a scope and visibility even when coming from a catalog:</p> <pre><code>dependencies:\n  - $compose.foundation: exported\n  - $my-catalog.db-engine: runtime-only \n</code></pre>"},{"location":"user-guide/dependencies/#managing-maven-repositories","title":"Managing Maven repositories","text":"<p>By default, Maven Central and Google Android repositories are pre-configured. To add extra repositories, use the following options:</p> <pre><code>repositories:\n  - https://repo.spring.io/ui/native/release\n  - url: https://dl.google.com/dl/android/maven2/\n  - id: jitpack\n    url: https://jitpack.io\n</code></pre> <p>To configure repository credentials, use the following snippet: <pre><code>repositories:\n  - url: https://my.private.repository/\n    credentials:\n      file: ../local.properties # relative path to the file with credentials\n      usernameKey: my.private.repository.username\n      passwordKey: my.private.repository.password\n</code></pre></p> <p>Here is the file <code>../local.properties</code>: <pre><code>my.private.repository.username=...\nmy.private.repository.password=...\n</code></pre></p> <p>Note</p> <p>Currently only <code>*.properties</code> files with credentials are supported.</p>"},{"location":"user-guide/multiplatform/","title":"Kotlin Multiplatform projects","text":""},{"location":"user-guide/multiplatform/#platform-qualifier","title":"Platform qualifier","text":"<p>Use the <code>@platform</code>-qualifier to mark platform-specific source folders and sections in the <code>module.yaml</code> files. You can use Kotlin Multiplatform platform names and families  as <code>@platform</code>-qualifier.</p> <p><pre><code>dependencies:               # common dependencies for all platforms\ndependencies@ios:           # ios is a platform family name  \ndependencies@iosArm64:      # iosArm64 is a KMP platform name\n</code></pre> <pre><code>settings:                   # common settings for all platforms\nsettings@ios:               # ios is a platform family name  \nsettings@iosArm64:          # iosArm64 is a KMP platform name\n</code></pre> <pre><code>|-src/                      # common code for all platforms\n|-src@ios/                  # sees declarations from src/ \n|-src@iosArm64/             # sees declarations from src/ and from src@ios/ \n</code></pre> <pre><code>|-resources/                # resources for all platforms\n|-resources@ios/             \n|-resources@iosArm64/       \n</code></pre></p> <p>See also how the resources are handled in the multiplatform projects.</p> <p>Only the platform names (but not the platform family names) can be currently used in the <code>platforms:</code> list:</p> <pre><code>product:\n  type: lib\n  platforms: [iosArm64, android, jvm]\n</code></pre>"},{"location":"user-guide/multiplatform/#platforms-hierarchy","title":"Platforms hierarchy","text":"<p>Some target platforms belong to the same family and share some common APIs. They form a hierarchy as follows: <pre><code>common  # corresponds to src directories or configuration sections without @platform suffix\n  jvm\n  android  \n  native\n    linux\n      linuxX64\n      linuxArm64\n    mingw\n      mingwX64\n    apple\n      macos\n        macosX64\n        macosArm64\n      ios\n        iosArm64\n        iosSimulatorArm64\n        iosX64            # iOS Simulator for Intel Mac\n      watchos\n        watchosArm32\n        watchosArm64\n        watchosDeviceArm64\n        watchosSimulatorArm64\n        watchosX64\n      tvos\n        tvosArm64\n        tvosSimulatorArm64\n        tvosX64\n  ...\n</code></pre></p> <p>Note</p> <p>Note: not all platforms listed here are equally supported or tested. Additional platforms may also exist in addition to the ones listed here, but are also untested/highly experimental.</p> <p>Based on this hierarchy, common code is visible from more <code>@platform</code>-specific code, but not vice versa:</p> <pre><code>|-src/             \n|  |-...      \n|-src@ios/                  # sees declarations from src/ \n|  |-...      \n|-src@iosArm64/             # sees declarations from src/ and from src@ios/ \n|  |-...      \n|-src@iosSimulatorArm64/    # sees declarations from src/ and from src@ios/ \n|  |-...      \n|-src@jvm/                  # sees declarations from src/\n|  |-...      \n|-module.yaml\n</code></pre> <p>You can therefore share code between platforms by placing it in a common ancestor in the hierarchy: code placed in <code>src@ios</code> is shared between <code>iosArm64</code> and <code>iosSimulatorArm64</code>, for instance.</p> <p>For Kotlin Multiplatform expect/actual declarations,  put your <code>expected</code> declarations into the <code>src/</code> folder, and <code>actual</code> declarations into the corresponding  <code>src@&lt;platform&gt;/</code> folders.</p> <p>This hierarchy applies to <code>@platform</code>-qualified sections in the configuration files as well. We'll see how this works more precisely in the Multiplatform Dependencies and Multiplatform Settings sections.</p>"},{"location":"user-guide/multiplatform/#aliases","title":"Aliases","text":"<p>If the default hierarchy is not enough, you can define new groups of platforms by giving them an alias. You can then use the alias in places where <code>@platform</code> suffixes usually appear to share code, settings, or dependencies:</p> <pre><code>product:\n  type: lib\n  platforms: [iosArm64, android, jvm]\n\naliases:\n  - jvmAndAndroid: [jvm, android] # defines a custom alias for this group of platforms\n\n# these dependencies will be visible in jvm and android code\ndependencies@jvmAndAndroid:\n  - org.lighthousegames:logging:1.3.0\n\n# these dependencies will be visible in jvm code only\ndependencies@jvm:\n  - org.lighthousegames:logging:1.3.0\n\n# these settings will affect both jvm and android code, and the shared code placed in src@jvmAndAndroid\nsettings@jvmAndAndroid:\n  kotlin:\n    freeCompilerArgs: [ -jvm-default=no-compatibility ]\n</code></pre> <pre><code>|-src/             \n|-src@jvmAndAndroid/ # sees declarations from src/ \n|-src@jvm/           # sees declarations from src/ and src@jvmAndAndroid/              \n|-src@android/       # sees declarations from src/ and src@jvmAndAndroid/             \n</code></pre>"},{"location":"user-guide/multiplatform/#multiplatform-dependencies","title":"Multiplatform dependencies","text":"<p>When you use a Kotlin Multiplatform library, its platforms-specific parts are automatically configured for each module platform.</p> <p>Example: To add the KmLogging library to a multiplatform module, simply write</p> <pre><code>product:\n  type: lib\n  platforms: [android, iosArm64, jvm]\n\ndependencies:\n  - org.lighthousegames:logging:1.3.0\n</code></pre> <p>The effective dependency lists are:</p> <p><pre><code>dependencies@android:\n  - org.lighthousegames:logging:1.3.0\n  - org.lighthousegames:logging-android:1.3.0\n</code></pre> <pre><code>dependencies@iosArm64:\n  - org.lighthousegames:logging:1.3.0\n  - org.lighthousegames:logging-iosarm64:1.3.0\n</code></pre> <pre><code>dependencies@jvm:\n  - org.lighthousegames:logging:1.3.0\n  - org.lighthousegames:logging-jvm:1.3.0\n</code></pre></p> <p>For the explicitly specified dependencies in the <code>@platform</code>-sections the general  propagation rules apply. That is, for the given configuration:</p> <pre><code>product:\n  type: lib\n  platforms: [android, iosArm64, iosSimulatorArm64]\n\ndependencies:\n  - ../foo\ndependencies@ios:\n  - ../bar\ndependencies@iosArm64:\n  - ../baz\n</code></pre> <p>The effective dependency lists are:</p> <p><pre><code>dependencies@android:\n  ../foo\n</code></pre> <pre><code>dependencies@iosSimulatorArm64:\n  ../foo\n  ../bar\n</code></pre> <pre><code>dependencies@iosArm64:\n  ../foo\n  ../bar\n  ../baz\n</code></pre></p>"},{"location":"user-guide/multiplatform/#multiplatform-settings","title":"Multiplatform settings","text":"<p>All toolchain settings, even platform-specific can be placed in the <code>settings:</code> section: <pre><code>product:\n  type: lib\n  platforms: [android, iosArm64]\n\nsettings:\n  # Kotlin toolchain settings that are used for both platforms\n  kotlin:\n    languageVersion: 1.8\n\n  # Android-specific settings are used only when building for android\n  android:\n    compileSdk: 33\n</code></pre></p> <p>There are situations when you need to override certain settings for a specific platform only. You can use <code>@platform</code>-qualifier.</p> <p>Note that certain platform names match the toolchain names, e.g. Android:</p> <ul> <li><code>settings@android</code> qualifier specifies settings for all Android target platforms</li> <li><code>settings:android:</code> is an Android toolchain settings</li> </ul> <p>This could lead to confusion in cases like:</p> <pre><code>product: android/app\n\nsettings@android:    # settings to be used for Android target platform\n  android:           # Android toolchain settings\n    compileSdk: 33\n  kotlin:        # Kotlin toolchain settings\n    languageVersion: 1.8\n</code></pre> <p>Luckily, there should rarely be a need for such a configuration. We also plan to address this by linting with conversion to a more readable form:</p> <pre><code>product: android/app\n\nsettings:\n  android:           # Android toolchain settings\n    compileSdk: 33\n  kotlin:        # Kotlin toolchain settings\n    languageVersion: 1.8\n</code></pre> <p>For settings with the <code>@platform</code>-qualifiers, the propagation rules apply. E.g., for the given configuration:</p> <pre><code>product:\n  type: lib\n  platforms: [android, iosArm64, iosSimulatorArm64]\n\nsettings:           # common toolchain settings\n  kotlin:           # Kotlin toolchain\n    languageVersion: 1.8\n    freeCompilerArgs: [x]\n  android:              # Android toolchain\n    compileSdk: 33\n\nsettings@android:   # specialization for Android platform\n  compose: enabled  # Compose toolchain\n\nsettings@ios:       # specialization for all iOS platforms\n  kotlin:           # Kotlin toolchain\n    languageVersion: 1.9\n    freeCompilerArgs: [y]\n\nsettings@iosArm64:  # specialization for iOS arm64 platform \n  ios:              # iOS toolchain\n    freeCompilerArgs: [z]\n</code></pre> <p>The effective settings are:</p> <p><pre><code>settings@android:\n  kotlin:\n    languageVersion: 1.8   # from settings:\n    freeCompilerArgs: [x]  # from settings:\n  compose: enabled         # from settings@android:\n  android:                \n    compileSdk: 33         # from settings@android:\n</code></pre> <pre><code>settings@iosArm64:\n  kotlin:\n    languageVersion: 1.9      # from settings@ios:\n    freeCompilerArgs: [x, y]  # merged from settings: and settings@ios:\n</code></pre> <pre><code>settings@iosSimulatorArm64:\n  kotlin:\n    languageVersion: 1.9      # from settings@ios:\n    freeCompilerArgs: [x, y, z]  # merged from settings: and settings@ios: and settings@iosArm64:\n</code></pre></p>"},{"location":"user-guide/multiplatform/#dependencysettings-propagation","title":"Dependency/Settings propagation","text":"<p>Common <code>dependencies:</code> and <code>settings:</code> are automatically propagated to the platform families and platforms in <code>@platform</code>-sections, using the following rules:</p> <ul> <li>Scalar values (strings, numbers etc.) are overridden by more specialized <code>@platform</code>-sections.</li> <li>Mappings and lists are appended.</li> </ul> <p>Think of the rules like adding merging Java/Kotlin Maps.</p>"},{"location":"user-guide/multiplatform/#interoperability-between-languages","title":"Interoperability between languages","text":"<p>Kotlin Multiplatform implies smooth interoperability with platform languages, APIs, and frameworks. There are three distinct scenarios where such interoperability is needed:</p> <ul> <li>Consuming: Kotlin code can use APIs from existing platform libraries, e.g. jars on JVM (later CocoaPods on iOS too).</li> <li>Publishing: Kotlin code can be compiled and published as platform libraries to be consumed by the target platform's   tooling; such as jars on JVM, frameworks on iOS (maybe later .so on linux).</li> <li>Joint compilation: Kotlin code be compiled and linked into a final product together with the platform languages, like   JVM, Objective-C, and Swift.</li> </ul> <p>Joint compilation is already supported for Java and Kotlin, with 2-way interoperability: Java code can reference Kotlin declarations, and vice versa. So Java code can be placed alongside Kotlin code in the same source folder that is compiled for JVM/Android:</p> <pre><code>|-src/             \n|  |-main.kt      \n|-src@jvm/             \n|  |-KotlinCode.kt      \n|  |-JavaCode.java      \n|-src@android/             \n|  |-KotlinCode.kt \n|  |-JavaCode.java\n|-src@ios/\n|  |- ...\n|-module.yaml\n</code></pre> <p>In the future, Kotlin Native will also support joint Kotlin+Swift compilation in the same way, but this is not the case yet. At the moment, Kotlin code is first compiled into a single framework per <code>ios/app</code> module, and then Swift is compiled using the Xcode toolchain with a dependency on that framework. This means that Swift code can reference Kotlin declarations, but Kotlin cannot reference Swift declarations. See more in the dedicated Swift support section.</p>"},{"location":"user-guide/templates/","title":"Templates","text":"<p>In modularized projects, there is often a need to have a certain common configuration for all or some modules. Typical examples could be a testing framework used in all modules or a Kotlin language version.</p> <p>Amper offers a way to extract whole sections or their parts into reusable template files.  These files are named <code>&lt;name&gt;.module-template.yaml</code> and have the same structure as <code>module.yaml</code> files.</p> <p>A templates is applied to a <code>module.yaml</code> file by it to the <code>apply:</code> section:</p> module.yaml<pre><code>product: jvm/app\n\napply: \n  - ../common.module-template.yaml\n</code></pre> ../common.module-template.yaml<pre><code>test-dependencies:\n  - org.jetbrains.kotlin:kotlin-test:1.8.10\n\nsettings:\n  kotlin:\n    languageVersion: 1.8\n</code></pre> <p>Sections in the template can also have <code>@platform</code>-qualifiers.</p> <p>Note</p> <p>Template files can't have <code>product:</code> and <code>apply:</code> sections (they can't be recursive).</p> <p>Templates are applied one by one, using the same rules as  platform-specific dependencies and settings:</p> <ul> <li>Scalar values (strings, numbers etc.) are overridden.</li> <li>Mappings and lists are appended.</li> </ul> <p>Settings and dependencies from the <code>module.yaml</code> file are applied last. The position of the <code>apply:</code> section doesn't matter, the <code>module.yaml</code> file content always has precedence E.g.</p> common.module-template.yaml<pre><code>dependencies:\n  - ../shared\n\nsettings:\n  kotlin:\n    languageVersion: 1.8\n  compose: enabled\n</code></pre> module.yaml<pre><code>product: jvm/app\n\napply:\n  - ./common.module-template.yaml\n\ndependencies:\n  - ../jvm-util\n\nsettings:\n  kotlin:\n    languageVersion: 1.9\n  jvm:\n    release: 8\n</code></pre> <p>After applying the template the resulting effective module is:</p> module.yaml<pre><code>product: jvm/app\n\ndependencies:  # lists appended\n  - ../shared\n  - ../jvm-util\n\nsettings:  # objects merged\n  kotlin:\n    languageVersion: 1.9  # module.yaml overwrites value\n  compose: enabled        # from the template\n  jvm:\n    release: 8   # from the module.yaml\n</code></pre>"},{"location":"user-guide/testing/","title":"Testing","text":"<p>Test code is located in the <code>test/</code> folder:</p> <pre><code>|-src/            # production code\n|  ...      \n|-test/           # test code \n|  |-MainTest.kt\n|  |-... \n|-module.yaml\n</code></pre> <p>By default, the Kotlin test framework is preconfigured for each platform. Additional test-only dependencies should be added to the <code>test-dependencies:</code> section of your module configuration file:</p> <pre><code>product: jvm/app\n\n# these dependencies are available in main and test code\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0\n\n# additional dependencies for test code\ntest-dependencies:\n  - io.ktor:ktor-server-test-host:2.2.0\n</code></pre> <p>To add or override toolchain settings in tests, use the <code>test-settings:</code> section: <pre><code># these dependencies are available in main and test code\nsetting:\n  kotlin:\n    ...\n\n# additional test-specific setting \ntest-settings:\n  kotlin:\n    ...\n</code></pre></p> <p>Test settings and dependencies by default are inherited from the main configuration according to the  configuration propagation rules. Example: <pre><code>|-src/             \n|  ...      \n|-src@ios/             \n|  ...      \n|-test/           # Sees declarations from src/. Executed on all platforms. \n|  |-MainTest.kt\n|  |-... \n|-test@ios/       # Sees declarations from src/, src@ios/, and `test/`. Executed on iOS platforms only.  \n|  |-IOSTest.kt \n|  |-... \n|-module.yaml\n</code></pre></p> <pre><code>product:\n  type: lib\n  platforms: [android, iosArm64]\n\n# these dependencies are available in main and test code\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0\n\n# dependencies for test code\ntest-dependencies:\n  - org.jetbrains.kotlin:kotlin-test:1.8.10\n\n# these settings affect the main and test code\nsettings: \n  kotlin:\n    languageVersion: 1.8\n\n# these settings affect tests only\ntest-settings:\n  kotlin:\n    languageVersion: 1.9 # overrides `settings:kotlin:languageVersion: 1.8`\n</code></pre>"},{"location":"user-guide/yaml-primer/","title":"Brief YAML primer","text":"<p>Amper uses (a subset of) the YAML language for configuration files.</p> <p>YAML describes a tree of mappings and values. Mappings have key-value pairs and can be nested. Values can be scalars (string, numbers, booleans) and sequences (lists, sets). YAML is indent-sensitive.</p> <p>Here is a cheat-sheet and YAML 1.2 specification.</p> <p>Strings can be quoted or unquoted. These are equivalent:</p> <pre><code>string1: foo bar\nstring2: \"foo bar\"\nstring3: 'foo bar'\n</code></pre> <p>Mapping:</p> <pre><code>mapping-name:\n  field1: foo bar\n  field2: 1.2  \n</code></pre> <p>List of values (strings):</p> <pre><code>list-name:\n  - foo bar\n  - \"bar baz\"  \n</code></pre> <p>List of mapping:</p> <pre><code>list-name:\n  - named-mapping:\n      field1: x\n      field2: y\n  - field1: x\n    field2: y\n</code></pre>"},{"location":"user-guide/advanced/compiler-plugins/","title":"Kotlin compiler plugins","text":"<p>Third-party compiler plugins are not supported at the moment</p>"},{"location":"user-guide/advanced/compiler-plugins/#all-open","title":"all-open","text":"<p>To enable all-open, add the following configuration:</p> <pre><code>  settings:\n    kotlin:\n      allOpen:\n        enabled: true\n        annotations: \n          - org.springframework.context.annotation.Configuration\n          - org.springframework.stereotype.Service\n          - org.springframework.stereotype.Component\n          - org.springframework.stereotype.Controller\n          - ...\n</code></pre> <p>Or you can use one of the preconfigured presets that contain all-open annotations related to specific frameworks:</p> <pre><code>  settings:\n    kotlin:\n      allOpen:\n        enabled: true\n        presets:\n          - spring\n          - micronaut\n</code></pre>"},{"location":"user-guide/advanced/compiler-plugins/#no-arg","title":"no-arg","text":"<p>To enable no-arg, add the following configuration:</p> <pre><code>  settings:\n    kotlin:\n      noArg:\n        enabled: true\n        annotations: \n          - jakarta.persistence.Entity\n          - ...\n</code></pre> <p>Or you can use one of the preconfigured presets that contain no-arg annotations related to specific frameworks:</p> <pre><code>  settings:\n    kotlin:\n      noArg:\n        enabled: true\n        presets: \n          - jpa\n</code></pre>"},{"location":"user-guide/advanced/java-annotation-processing/","title":"Java annotation processing","text":"<p>To add java annotation processors to your module, add their maven coordinates to the <code>settings.java.annotationProcessing.processors</code> list:</p> <pre><code>settings:\n  java:\n    annotationProcessing:\n      processors:\n        - org.mapstruct:mapstruct-processor:1.6.3\n</code></pre> <p>This option is only available for java or android modules (it's a platform-specific).</p> <p>As with KSP, it's possible to reference a local Amper module as a processor. See the KSP section for more information. Using library catalog entry is also supported.</p> <p>Some annotation processors can be customized by passing options. You can pass these options using the <code>processorOptions</code> map:</p> <pre><code>settings:\n  java:\n    annotationProcessing:\n      processors:\n        - $libs.auto.service # using catalog reference \n      processorOptions:\n        debug: true\n</code></pre>"},{"location":"user-guide/advanced/ksp/","title":"Configuring Kotlin Symbol Processing (KSP)","text":"<p>Kotlin Symbol Processing is a tool that allows feeding Kotlin source code to processors, which can in turn use this information to generate code, classes, or resources, for instance. Amper provides built-in support for KSP.</p> <p>Some popular libraries also include a KSP processor to enhance their capabilities, such as Room or Moshi.</p> <p>Info</p> <p>Amper works with KSP2, so any processors used must be compatible with KSP2. We\u2019re expecting most processors to make this upgrade soon, as KSP1 is no longer part of KSP releases. However, at the moment, you might still see some gaps in support, such as issues with native targets.</p> <p>To add KSP processors to your module, add their maven coordinates to the <code>settings.kotlin.ksp.processors</code> list:</p> <pre><code>settings:\n  kotlin:\n    ksp:\n      processors:\n        - androidx.room:room-compiler:2.7.0-alpha12\n</code></pre>"},{"location":"user-guide/advanced/ksp/#multiplatform-support","title":"Multiplatform support","text":"<p>In multiplatform modules, all settings from the <code>settings</code> section apply to all platforms by default, including KSP  processors. If you only want to add KSP processors for a specific platform, use a <code>settings</code> block with a <code>@platform</code> qualifier:</p> <pre><code># the Room processor will only process code that compiles to the Android platform\nsettings@android:\n  kotlin:\n    ksp:\n      processors:\n        - androidx.room:room-compiler:2.7.0-alpha12\n</code></pre> <p>Generated code is not available in common sources</p> <p>In multiplatform modules, KSP is called for each platform separately. This means that any code generated by KSP processors will be available only for the corresponding platform. There is no way at the moment to access the  generated code from the common fragment (<code>src</code>) or intermediate fragments (e.g. <code>src@native</code>).</p> <p>This limitation comes from the Kotlin compilation model and how KSP aligns with it. Please follow  the relevant KSP issue for more information.</p>"},{"location":"user-guide/advanced/ksp/#passing-options-to-ksp-processors","title":"Passing options to KSP processors","text":"<p>Some processors can be customized by passing options. You can pass these options using the <code>processorOptions</code> section:</p> <pre><code>settings:\n  kotlin:\n    ksp:\n      processors:\n        - androidx.room:room-compiler:2.7.0-alpha12\n      processorOptions:\n        room.schemaLocation: ./schema\n</code></pre> <p>Consult the documentation of the processor you want to use for more information about the available options.</p> <p>Note</p> <p>Note: all options are passed to all processors by KSP. It's the processor's responsibility to use unique option names to avoid clashes with other processor options.</p>"},{"location":"user-guide/advanced/ksp/#using-your-own-local-ksp-processor","title":"Using your own local KSP processor","text":"<p>You can implement your own processor in an Amper module as a regular JVM library, and then use it to process code from other modules in your project.</p> <p>Usually, 3 modules are involved:</p> <ul> <li>The processor module, with the actual processor implementation</li> <li>The annotations module (optional), which contains annotations that the processor looks for in the consumer code</li> <li>The consumer module, which uses KSP with the custom processor</li> </ul> <p>The annotations module is a very simple JVM library module without any required dependencies (it's just here to provide some annotations to work with, if necessary):</p> <pre><code># my-processor-annotations/module.yaml\nproduct:\n  type: lib\n  platforms: [ jvm ]\n</code></pre> <p>The processor module is a JVM library with a <code>compile-only</code> dependency on KSP facilities, and on the custom annotations module:</p> <pre><code># my-processor/module.yaml\nproduct:\n  type: lib\n  platforms: [ jvm ]\n\ndependencies:\n  - ../my-processor-annotations\n  - com.google.devtools.ksp:symbol-processing-api:2.0.21-1.0.25: compile-only\n</code></pre> <p>The consumer module adds a regular dependency on the annotations module, and a reference to the processor module:</p> <pre><code># my-consumer/module.yaml\nproduct: jvm/app\n\ndependencies:\n  - ../my-processor-annotations # to be able to annotate the consumer code\n\nsettings:\n  kotlin:\n    ksp:\n      processors:\n        - ../my-processor # path to the module implementing the KSP processor\n</code></pre> <p>For more information about how to write your own processor, check out the KSP documentation.</p>"},{"location":"user-guide/advanced/maven-like-layout/","title":"Maven-like module layout","text":"<p>Amper is opinionated about where to put your sources, resources, and tests (see the  standard project layout).</p> <p>When transitioning from other tools, it would be tedious to move all (re)source files around in addition to converting the build configuration files. To smoothen the transition, Amper provides an alternative layout that is compatible with Maven and Gradle. The layout conforms to the Maven Standard Directory Layout.</p> <p>Example:</p> <pre><code>module/\n\u251c\u2500\u2500 module.yaml\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 main/\n    \u2502   \u251c\u2500\u2500 java/\n    \u2502   \u2502   \u2514\u2500\u2500 Main.java\n    \u2502   \u251c\u2500\u2500 kotlin/\n    \u2502   \u2502   \u2514\u2500\u2500 func.kt\n    \u2502   \u2514\u2500\u2500 resources/\n    \u2502       \u2514\u2500\u2500 input.txt\n    \u2514\u2500\u2500 test/\n        \u251c\u2500\u2500 java/\n        \u2502   \u2514\u2500\u2500 JavaTest.java\n        \u251c\u2500\u2500 kotlin/\n        \u2502   \u2514\u2500\u2500 KotlinTest.kt\n        \u2514\u2500\u2500 resources/\n            \u2514\u2500\u2500 test-input.txt\n</code></pre> <p>Note</p> <p>There is no difference between <code>java/</code> and <code>kotlin/</code> folders, Amper will look for java and kotlin sources in both folders. It is only necessary for the sake of transitioning simplicity.</p> <p>Choosing the file layout is possible per module.</p> <p>To enable the maven-like module layout, add the following to the <code>module.yaml</code> file:</p> <pre><code>layout: maven-like\n</code></pre>"},{"location":"user-guide/builtin-tech/android/","title":"Android","text":"<p>Use the <code>android/app</code> product type in a module to build an Android application.</p>"},{"location":"user-guide/builtin-tech/android/#entry-point","title":"Entry point","text":"<p>The application's entry point is specified in the AndroidManifest.xml file according to the official Android documentation. <pre><code>|-src/ \n|  |-MyActivity.kt\n|  |-AndroidManifest.xml\n|  |-... \n|-module.yaml\n</code></pre></p> <p><code>src/AndroidManifest.xml</code>: <pre><code>&lt;manifest ... &gt;\n  &lt;application ... &gt;\n    &lt;activity android:name=\"com.example.myapp.MainActivity\" ... &gt;\n    &lt;/activity&gt;\n  &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>You can run your application using the <code>run</code> command.</p>"},{"location":"user-guide/builtin-tech/android/#packaging","title":"Packaging","text":"<p>You can use the <code>build</code> command to create an APK, or the <code>package</code> command to create an Android Application Bundle (AAB).</p> <p>The <code>package</code> command will not only build the APK, but also minify/obfuscate it with ProGuard, and sign it. See the dedicated signing and code shrinking sections to learn how to configure this.</p>"},{"location":"user-guide/builtin-tech/android/#code-shrinking","title":"Code shrinking","text":"<p>When creating a release build with Amper, R8 will be used automatically, with minification and shrinking enabled. This is equivalent to the following Gradle configuration:</p> <pre><code>// in Gradle\nisMinifyEnabled = true\nisShrinkResources = true\nproguardFiles(getDefaultProguardFile(\"proguard-android-optimize.txt\"))\n</code></pre> <p>You can create a <code>proguard-rules.pro</code> file in the module folder to add custom rules for R8.</p> <pre><code>|-src/\n|  ...      \n|-test/\n|  ...\n|-proguard-rules.pro\n|-module.yaml\n</code></pre> <p>It is automatically used by Amper if present.</p> <p>An example of how to add custom R8 rules can be found in the android-app module of the <code>compose-multiplatform</code> example project.</p>"},{"location":"user-guide/builtin-tech/android/#signing","title":"Signing","text":"<p>In a module containing an Android application (using the <code>android/app</code> product type) you can enable signing under settings:</p> <pre><code>settings:\n  android:\n    signing: enabled\n</code></pre> <p>This will use a <code>keystore.properties</code> file located in the module folder for the signing details by default. This properties file must contain the following signing details. Remember that these details should usually not be added to version control.</p> <pre><code>storeFile=/Users/example/.keystores/release.keystore\nstorePassword=store_password\nkeyAlias=alias\nkeyPassword=key_password\n</code></pre> <p>To customize the path to this file, you can use the <code>propertiesFile</code> option:</p> <pre><code>settings:\n  android:\n    signing:\n      enabled: true\n      propertiesFile: ./keystore.properties # default value\n</code></pre> <p>You can use <code>./amper tool generate-keystore</code> to generate a new keystore if you don't have one yet. This will create a new self-signed certificate, using the details in the <code>keystore.properties</code> file.</p> <p>You can also pass in these details to <code>generate-keystore</code> as command line arguments. Invoke the tool with <code>--help</code> to learn more.</p>"},{"location":"user-guide/builtin-tech/android/#parcelize","title":"Parcelize","text":"<p>If you want to automatically generate your <code>Parcelable</code> implementations, you can enable Parcelize as follows:</p> <pre><code>settings:\n  android:\n    parcelize: enabled\n</code></pre> <p>With this simple toggle, the following class gets its <code>Parcelable</code> implementation automatically without spelling it out in the code, just thanks to the <code>@Parcelize</code> annotation: <pre><code>import kotlinx.parcelize.Parcelize\n\n@Parcelize\nclass User(val firstName: String, val lastName: String, val age: Int): Parcelable\n</code></pre></p> <p>While this is only relevant on Android, sometimes you need to share your data model between multiple platforms. However, the <code>Parcelable</code> interface and <code>@Parcelize</code> annotation are only present on Android. But fear not, there is a solution described in the official documentation. In short:</p> <ul> <li>For <code>android.os.Parcelable</code>, you can use the <code>expect</code>/<code>actual</code> mechanism to define your own interface as typealias of   <code>android.os.Parcelable</code> (for Android), and as an empty interface for other platforms.</li> <li>For <code>@Parcelize</code>, you can simply define your own annotation instead, and then tell Parcelize about it (see below).</li> </ul> <p>For example, in common code: <pre><code>@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class MyParcelize\n\nexpect interface MyParcelable\n</code></pre> Then in Android code: <pre><code>actual typealias MyParcelable = android.os.Parcelable\n</code></pre> And in other platforms: <pre><code>// empty because nothing is generated on non-Android platforms\nactual interface MyParcelable\n</code></pre></p> <p>You can then make Parcelize recognize this custom annotation using the <code>additionalAnnotations</code> option:</p> <pre><code>settings:\n  kotlin:\n    # for the expect/actual MyParcelable interface\n    freeCompilerArgs: [ -Xexpect-actual-classes ]\n  android:\n    parcelize:\n      enabled: true\n      additionalAnnotations: [ com.example.MyParcelize ]\n</code></pre>"},{"location":"user-guide/builtin-tech/android/#google-services-and-firebase","title":"Google Services and Firebase","text":"<p>To enable the <code>google-services</code> plugin, place your <code>google-services.json</code> file in the module containing an <code>android/app</code> product, next to <code>module.yaml</code>.</p> <pre><code>|-androidApp/\n|  |-src/\n|  |-google-services.json\n|  |-module.yaml\n</code></pre> <p>This file will be found and consumed automatically.</p>"},{"location":"user-guide/builtin-tech/compose/","title":"Compose Multiplatform","text":"<p>To enable Compose (with a compiler plugin and required dependencies), add the following configuration:</p> <p>JVM Desktop: <pre><code>product: jvm/app\n\ndependencies:\n  # add Compose dependencies using a dependency catalog:\n  - $compose.desktop.currentOs\n\nsettings: \n  # enable Compose toolchain\n  compose: enabled\n</code></pre></p> <p>Android: <pre><code>product: android/app\n\ndependencies:\n  # add Compose dependencies using a dependency catalog:\n  - $compose.foundation\n  - $compose.material3\n\nsettings: \n  # enable Compose toolchain\n  compose: enabled\n</code></pre></p> <p>There is also a full form for enabling or disabling the Compose toolchain: <pre><code>...\nsettings: \n  compose:\n    enabled: true\n</code></pre></p> <p>Also, you can specify the exact version of the Compose framework to use:</p> <pre><code>...\nsettings:\n  compose:\n    version: 1.5.10\n</code></pre>"},{"location":"user-guide/builtin-tech/compose/#using-multiplatform-resources","title":"Using multiplatform resources","text":"<p>Amper supports Compose Multiplatform resources.</p> <p>The file layout in Amper is: <pre><code>|-my-kmp-module/\n|  |-module.yaml\n|  |-src/ # your code is here\n|  |  |-...\n|  |-composeResources/ # place your multiplatform resources in this folder\n|  |  |-values/\n|  |  |  |-strings.xml\n|  |  |-drawable/\n|  |  |  |-image.jpg\n|  |-...\n</code></pre></p> <p>Amper automatically generates the accessors for resources during the build and when working with code in the IDE. Accessors are generated in a package that corresponds to the module name. All non-letter symbols are replaced with <code>_</code>. In the given example where the module name is <code>my-kmp-module</code>, the package name for the generated resources will be <code>my_kmp_module</code>.</p> <p>Here is how to use the resources in the code:</p> <pre><code>import my_kmp_module.generated.resources.Res\nimport my_kmp_module.generated.resources.hello\n// other imports\n\n@Composable\nprivate fun displayHelloText() {\n    BasicText(stringResource(Res.string.hello))\n}\n</code></pre> <p>Read more about setting up and using compose resources in  the documentation.</p>"},{"location":"user-guide/builtin-tech/compose/#compose-hot-reload-experimental","title":"Compose Hot Reload (experimental)","text":"<p>Amper supports Compose Hot Reload, allowing you to see UI changes in real-time without restarting the application. This significantly improves the developer experience by shortening the feedback loop during UI development.</p>"},{"location":"user-guide/builtin-tech/compose/#configuration","title":"Configuration","text":"<p>To enable Compose Hot Reload set <code>compose.experimental.hotReload</code> to <code>enabled</code>:</p> <pre><code>settings:\n  compose:\n    enabled: true\n    experimental:\n      hotReload: enabled\n</code></pre> <p>When you run your application with Compose Hot Reload enabled:</p> <ul> <li>Amper automatically downloads and runs JetBrains Runtime to maximize   hot-swap capabilities</li> <li>A Java agent for Compose Hot Reload is attached during execution</li> <li>A small Compose Hot Reload devtools icon appears next to the application window, indicating that the feature is active</li> </ul> <p></p>"},{"location":"user-guide/builtin-tech/compose/#ide-integration","title":"IDE Integration","text":"<p>When running your app from the IDE, you can get automatic recompilation and reloading based on file system changes, using the Amper IntelliJ plugin.</p> <p>To configure it, you don't have to do anything, the plugin will automatically detect the presence of the Compose Hot Reload and enable the feature.</p> <p>When Compose Hot Reload is enabled, in the IDE you can see a special mode of running Amper application: </p>"},{"location":"user-guide/builtin-tech/compose/#developmententrypoint","title":"DevelopmentEntryPoint","text":"<p>It's also possible to run specific composables as in the Compose Hot Reload mode. To do that, you need to put <code>@DevelopmentEntryPoint</code> annotation on the composable function without parameters. A clickable gutter icon will appear on the left side of the composable. </p>"},{"location":"user-guide/builtin-tech/compose/#current-limitations","title":"Current Limitations","text":"<ul> <li>You need to make sure that <code>jvm</code> is one of the platforms of the module.</li> <li>Amper doesn't watch the file system, so automatic reloads are only available when using the IDE</li> </ul>"},{"location":"user-guide/builtin-tech/ios/","title":"iOS","text":""},{"location":"user-guide/builtin-tech/ios/#xcode-project","title":"Xcode Project","text":"<p>Currently, an Xcode project is required to build an iOS application in Amper. It has to be named <code>module.xcodeproj</code> and located in the <code>ios/app</code> module root directory.</p> <p>Normally, when the Amper project is created via <code>amper init</code> or via the IDE's Wizard, the appropriate Xcode project is already there. This is currently the recommended way of creating projects that have an iOS app module.</p> <p>However, if the Amper project is created from scratch, the default buildable Xcode project will be created automatically after the first project build. This project can later be customized and checked into a VCS.</p> <p>If you want to migrate an existing Xcode project so it has Amper support, you must manually ensure that:</p> <ol> <li>it is named <code>module.xcodeproj</code> and is located in the root of the <code>ios/app</code> module</li> <li>it has a single iOS application target</li> <li>the target has <code>Debug</code> &amp; <code>Release</code> build configurations, each containing <code>AMPER_WRAPPER_PATH = &lt;relative path to amper wrapper script&gt;</code>.    The path is relative to the Amper module root.</li> <li>the target has a script build phase called <code>Build Kotlin with Amper</code> with the code:    <pre><code> # !AMPER KMP INTEGRATION STEP!\n # This script is managed by Amper, do not edit manually!\n \"${AMPER_WRAPPER_PATH}\" tool xcode-integration\n</code></pre></li> <li>The Framework Search Paths (<code>FRAMEWORK_SEARCH_PATHS</code>) option contains the <code>$(TARGET_BUILD_DIR)/AmperFrameworks</code> value</li> </ol> <p>Changes to the Xcode project that do not break these requirements are allowed.</p> <p>So the iOS app module layout looks like this: <pre><code>|-src/             \n|  |-KotlinCode.kt      # optional, if all the code is in the libraries\n|  |-EntryPoint.swift\n|  |-Info.plist\n|-module.yaml           # ios/app\n|-module.xcodeproj      # xcode project\n</code></pre></p> <p>Tip</p> <p>The Xcode project can be built normally from the Xcode IDE, if needed.</p>"},{"location":"user-guide/builtin-tech/ios/#application-entrypoint","title":"Application entrypoint","text":"<p>For iOS applications, the entrypoint is expected to be a <code>@main</code> struct in any Swift file in the <code>src</code> folder.</p> <pre><code>|-src/ \n|  |-main.swift\n|  |-... \n|-module.yaml\n|-module.xcodeproj\n</code></pre> <p>src/main.swift: <pre><code>...\n@main\nstruct iosApp: App {\n   ...\n}\n</code></pre></p> <p>This is not customizable at the moment.</p>"},{"location":"user-guide/builtin-tech/ios/#swift-support","title":"Swift support","text":"<p>Info</p> <p>Swift sources are only fully supported in the <code>src</code> directory of the <code>ios/app</code> module.</p> <p>While swift sources are, strictly speaking, managed by the Xcode project and, as such, can reside in arbitrary locations, it's not recommended to have them anywhere outside the <code>src</code> directory - the tooling might not work correctly.</p> <p>To use Kotlin code from Swift, one must import the <code>KotlinModules</code> framework. This framework is built from:</p> <ol> <li>the code inside the <code>ios/app</code> module itself</li> <li>the modules that <code>ios/app</code> module depends on (e.g. <code>- ../shared</code>)</li> <li>all the external dependencies, transitively</li> </ol> <p>Note</p> <p>All declarations from the source Kotlin code are accessible to Swift, but external dependencies are not.</p>"},{"location":"user-guide/builtin-tech/kotlin-serialization/","title":"Kotlin Serialization","text":"<p>Kotlin Serialization is the official multiplatform and multi-format serialization library for Kotlin.</p> <p>If you need to (de)serialize Kotlin classes to/from JSON, you can enable Kotlin Serialization it in its simplest form: <pre><code>settings:\n  kotlin:\n    serialization: json  # JSON or other format\n</code></pre> This snippet configures the compiler to process <code>@Serializable</code> classes, and adds dependencies on the serialization runtime and JSON format libraries.</p> <p>You can also customize the version of the Kotlin Serialization libraries using the full form of the configuration:</p> <pre><code>settings:\n  kotlin:\n    serialization:\n      format: json\n      version: 1.7.3\n</code></pre>"},{"location":"user-guide/builtin-tech/kotlin-serialization/#more-control-over-serialization-formats","title":"More control over serialization formats","text":"<p>If you don't need serialization format dependencies or if you need more control over them, you can use the following: <pre><code>settings:\n  kotlin:\n    serialization: enabled # configures the compiler and serialization runtime library\n</code></pre> This snippet on its own only configures the compiler and the serialization runtime library, but doesn't add any format dependency. However, it adds a built-in catalog with official serialization formats libraries, which you can use in your <code>dependencies</code> section. This is useful in multiple cases:</p> <ul> <li> <p>if you need a format dependency only in tests:   <pre><code>settings:\n  kotlin:\n    serialization: enabled\n\ntest-dependencies:\n  - $kotlin.serialization.json\n</code></pre></p> </li> <li> <p>if you need to customize the scope of the format dependencies:   <pre><code>settings:\n  kotlin:\n    serialization: enabled\n\ndependencies:\n  - $kotlin.serialization.json: compile-only\n</code></pre></p> </li> <li> <p>if you need to expose format dependencies transitively:   <pre><code>settings:\n  kotlin:\n    serialization: enabled\n\ndependencies:\n  - $kotlin.serialization.json: exported\n</code></pre></p> </li> <li> <p>if you need multiple formats:   <pre><code>settings:\n  kotlin:\n    serialization: enabled\n\ndependencies:\n  - $kotlin.serialization.json\n  - $kotlin.serialization.protobuf\n</code></pre></p> </li> </ul>"},{"location":"user-guide/builtin-tech/ktor/","title":"Ktor","text":"<p>To enable Ktor support, add the following to the <code>module.yaml</code> file:</p> <pre><code>settings:\n  ktor: enabled\n</code></pre> <p>Setting <code>ktor: enabled</code> performs the following actions:</p> <ul> <li>Applies Ktor BOM</li> <li>Contributes Ktor-related entries to a built-in library catalog</li> <li>Adds default JVM arguments when running the app</li> </ul> <p>Examples of Ktor projects:</p> <ul> <li>ktor-simplest-sample</li> </ul>"},{"location":"user-guide/builtin-tech/lombok/","title":"Lombok","text":"<p>Despite there is a way to configure annotation processing in general for Java, for the Kotlin interop you need a compiler plugin configured. So if you want to add Lombok to your project it is better to use <code>settings:lombok</code> instead of configuring <code>settings:java:annotationProcessing</code> directly even if your module is java-only. Enabling Lombok is by</p> <pre><code>  settings:\n    lombok: enabled\n</code></pre> <p>adds <code>lombok</code> dependency, annotation processor, and kotlin compiler plugin.</p>"},{"location":"user-guide/builtin-tech/spring/","title":"Spring Boot","text":"<p>To enable Spring boot support, add the following to the <code>module.yaml</code> file:</p> <pre><code>settings:\n  springBoot: enabled\n</code></pre> <p>Setting <code>springBoot: enabled</code> performs the following actions:</p> <ul> <li>Applies the Spring Dependencies BOM</li> <li>Adds the <code>spring-boot-starter</code> dependency</li> <li>Adds the <code>spring-boot-starter-test</code> test dependency</li> <li>Configures <code>all-open</code> and <code>no-arg</code> Kotlin compiler plugins with the <code>spring</code> preset</li> <li>Adds the necessary compiler arguments for <code>kotlinc</code> and <code>javac</code></li> <li>Contributes Spring Boot-related entries to the built-in library catalog</li> </ul> <p>Mixed projects (containing java and kotlin sources simultaneously) are supported.</p> <p>Examples of Spring Boot projects:</p> <ul> <li>spring-petclinic</li> <li>spring-petclinic-kotlin</li> </ul>"}]}