{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Amper","text":"<p>Amper is an experimental build tool for the Kotlin and Java languages, with a focus on user experience and tooling.</p> <p>It can build plain JVM console applications, Android and iOS mobile applications, server-side application like Spring or Ktor, multiplatform projects that share business logic and/or UI, and more.</p> <p>Get started  Learn</p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>Amper should be invisible when you're working on your code \u2013 nobody likes dealing with the build tool. Ideally, you shouldn't have to leave your source files to adjust the build configuration.</p> <p>When you do edit the build configuration by hand, we want the experience to be as smooth and enjoyable as possible.</p> <p>We believe that this can be achieved by:</p> <ul> <li>providing a declarative configuration DSL \u2013 to simplify not only the initial setup but also improve maintainability    and let IDEs assist with automatic configuration reliably;</li> <li>bundling a curated set of toolchains \u2013 to support the majority of the scenarios without the need to find compatible   plugins;</li> <li>carefully choosing the extensibility points \u2013 to keep the overall mental model and UX of the configuration consistent   and to avoid unexpected third-party code execution.</li> </ul> <p>In essence, we aim to achieve a similar well-thought-out and well-tested experience as with JetBrains IDEs.</p>"},{"location":"#project-status","title":"Project status","text":"<p>Amper is still in the experimental phase, but we encourage you to try it out and  give us feedback.</p> <p>We\u2019re currently looking at various aspects, including extensibility, publication, and Maven integration.</p>"},{"location":"#supported-features","title":"Supported features","text":"<ul> <li> Creating and running JVM, Android, iOS, Linux, Windows, and macOS applications</li> <li> Creating Kotlin Multiplatform libraries</li> <li> Running tests</li> <li> Mixing Kotlin, Java, and Swift code</li> <li> Code assistance for module files in IntelliJ IDEA</li> <li> Multi-module projects</li> <li> Compose Multiplatform, with   multiplatform resources and   Compose Hot Reload</li> <li> Integration with Gradle version catalogs</li> <li> Extensibility (Preview)</li> </ul> <p>Future directions:</p> <ul> <li> Packaging, publication, distribution</li> <li> Maven migration</li> <li> More features for extensibility</li> <li> Platform-specific test types, including android instrumented tests.</li> <li> Native dependencies support, such as CocoaPods, Swift Package Manager</li> <li> Build variants support</li> </ul>"},{"location":"#issues-and-feedback","title":"Issues and feedback","text":"<p>Amper uses   YouTrack for issue tracking, create a new issue there to report problems or submit ideas.</p> <p>You can also join the  Slack channel for discussions.</p>"},{"location":"#examples","title":"Examples","text":""},{"location":"#basics","title":"Basics","text":"<p>Here is a very basic JVM \"Hello, World!\" project:</p> <p></p> <p>The <code>main.kt</code> and <code>MyTest.kt</code> files are just regular Kotlin files with nothing special in them. The interesting part is <code>module.yaml</code>, which is the Amper module configuration file. For the above project structure, it would simply be:</p> <pre><code># Produce a JVM application \nproduct: jvm/app\n</code></pre> <p>That's it. The Kotlin and Java toolchains, test framework, and other necessary functionality are configured and available straight out of the box. You can build it, run it, write and run tests, and more. For more detailed information, check out the full example.</p> <p></p>"},{"location":"#multiplatform","title":"Multiplatform","text":"<p>Now, let's look at a Compose Multiplatform project with Android, iOS, and desktop JVM apps, with the following project structure in Fleet:</p> <p></p> <p>Notice how the <code>src/</code> folder contains Kotlin and Swift code together. It could, of course, also be Kotlin and Java. Another aspect to highlight is the shared module with the common code in the <code>src</code> folder and the platform-specific code folders <code>src@ios</code> and <code>src@android</code> (learn more about project layout).</p> <p>Here is how <code>ios-app/module.yaml</code> file looks: <pre><code># Produce an iOS application\nproduct: ios/app\n\n# Depend on the shared library module: \ndependencies:\n  - ../shared\n\nsettings:\n  # Enable the Compose Multiplatform framework\n  compose: enabled\n</code></pre></p> <p>This is pretty straightforward: it defines an iOS application with a dependency on a shared module and enables the Compose Multiplatform framework. A more interesting example would be <code>shared/module.yaml</code>:</p> <pre><code># Produce a shared library for the JVM, Android, and iOS platforms:\nproduct:\n  type: lib\n  platforms: [jvm, android, iosArm64, iosSimulatorArm64, iosX64]\n\n# Shared Compose dependencies:\ndependencies:\n  - $compose.foundation: exported\n  - $compose.material3: exported\n\n# Android-only dependencies  \ndependencies@android:\n  # Android-specific integration with Compose\n  - androidx.activity:activity-compose:1.7.2: exported\n  - androidx.appcompat:appcompat:1.6.1: exported\n\nsettings:\n  # Enable Kotlin serialization\n  kotlin:\n    serialization: json\n\n  # Enable the Compose Multiplatform framework\n  compose: enabled\n</code></pre> <p>A couple of things are worth mentioning. Note the platform-specific <code>dependencies@android</code> section with the <code>@&lt;platform&gt;</code> qualifier. The platform qualifier can be used both in the manifest and also in  the file layout. The qualifier organizes the code, dependencies, and settings for a certain platform.</p> <p></p> <p>Naturally, these examples show only a limited set of Amper features. To get more insight into design and functionality, look at the user guide, the tutorial, and example projects.</p>"},{"location":"#more-examples","title":"More examples","text":"<p>Check our these example projects:</p> <ul> <li>JVM \"Hello, World!\"</li> <li>Compose Multiplatform</li> <li>Compose on iOS, Android,   and desktop</li> <li>Kotlin Multiplatform app template with shared Compose UI   and with native Android and iOS UI</li> <li>And other examples</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#general","title":"General","text":""},{"location":"faq/#is-amper-a-brand-new-build-tool-from-jetbrains","title":"Is Amper a brand-new build tool from JetBrains?","text":"<p>Yes, Amper is a new build tool with a focus on user experience and IDE support.</p>"},{"location":"faq/#do-you-plan-to-support-only-kotlin","title":"Do you plan to support only Kotlin?","text":"<p>Amper already supports both Kotlin and Java as first-class citizens. Also, because one of Amper's main targets is Kotlin Multiplatform projects, it supports Swift and Objective-C for iOS.</p> <p>We\u2019ll investigate other tech stacks in the future based on the demand for them.</p>"},{"location":"faq/#which-target-platforms-are-supported","title":"Which target platforms are supported?","text":"<p>Currently, you can create applications for the JVM, Android, iOS, macOS, Linux, Windows, but also JS and WASM (although those cannot be run directly with Amper).</p> <p>Libraries can be created for all Kotlin Multiplatform targets.</p>"},{"location":"faq/#does-amper-support-compose-multiplatform","title":"Does Amper support Compose Multiplatform?","text":"<p>Yes, you can configure Compose for Android, iOS, and desktop. Check out our Compose Multiplatform guide.</p>"},{"location":"faq/#does-amper-support-kotlinjs-or-kotlinwasm-projects","title":"Does Amper support Kotlin/JS or Kotlin/Wasm projects?","text":"<p>Yes, but it doesn't provide tooling to work on full stack web projects yet. For instance, Amper doesn't install any  browser or Node.js runtime, doesn't generate or process any HTML entry point, and cannot run <code>js/app</code> modules on its own.</p>"},{"location":"faq/#what-functionality-do-you-plan-to-support","title":"What functionality do you plan to support?","text":"<p>We plan to cover all the common use cases based on demand. At the moment, we\u2019re working on extensibility, publication, and exploring Maven migration and integration.</p>"},{"location":"faq/#will-amper-be-open-source","title":"Will Amper be open source?","text":"<p>Amper is already open source. Check out our GitHub repository to see what we're  up to!</p>"},{"location":"faq/#when-will-amper-be-released-as-stable","title":"When will Amper be released as stable?","text":"<p>Right now, we\u2019re focusing on getting feedback and understanding your needs. Based on that, we\u2019ll be able to provide a more accurate estimate of a release date sometime in the future.</p>"},{"location":"faq/#should-i-start-my-next-project-with-amper","title":"Should I start my next project with Amper?","text":"<p>You\u2019re welcome to use it in any type of project. However, please understand that Amper is still in the experimental phase, and we expect things to change.</p>"},{"location":"faq/#should-i-migrate-my-existing-projects","title":"Should I migrate my existing projects?","text":"<p>Understanding real-world scenarios is crucial for us to provide a better experience, so from our side we\u2019d love to hear about the challenges you may face porting existing projects. However, please understand that the project is still in the experimental phase, and we cannot guarantee that all scenarios can be supported.</p>"},{"location":"faq/#how-do-i-report-a-bug","title":"How do I report a bug?","text":"<p>Please report problems to our   YouTrack issue tracker. Since this project is in the experimental phase, we would also greatly appreciate feedback and suggestions regarding  the configuration experience \u2013 join our   Slack channel for discussion.</p>"},{"location":"faq/#why-dont-you-use-kotlin-for-ampers-configuration-files","title":"Why don\u2019t you use Kotlin for Amper's configuration files?","text":"<p>Currently, we use YAML as a simple and readable markup language. It allows us to experiment with the UX and the IDE support much faster. We\u2019ll review the language choice as we proceed with the design and based on demand. The Kotlin DSL, or a limited form thereof, is one of the possible options.</p> <p>Having said that, we believe that the declarative approach to project configuration has significant advantages over the imperative approach. Declarative configuration is easily toolable, recovery from errors is much easier, and interpretation is much faster. These properties are critical for a good UX.</p> <p>Our final language choice will be made based on the overall UX it provides.</p>"},{"location":"faq/#why-did-you-have-a-gradle-based-option-to-use-amper","title":"Why did you have a Gradle-based option to use Amper?","text":"<p>In the initial Amper prototype, our main focus was improving the user experience and toolability of build configuration. Gradle, as a well-tested build engine, allowed us to start experimenting with the UX of the configuration very quickly. What\u2019s more, smooth interoperability with Gradle allowed using Amper in existing projects, which is important if we want to get feedback from real-world use cases.</p> <p>Now, Amper is a standalone build tool, which allows us to improve the IDE support and workflows even further.</p>"},{"location":"faq/#why-not-simply-improve-gradle","title":"Why not simply improve Gradle?","text":"<p>We believe there is room to improve the project configuration experience and IDE support. With Amper, we want to show you our design and get your feedback, as it will help us to decide which direction to take the design.</p> <p>At the same time, we are also working with the Gradle team to improve Gradle support in our IDEs and Gradle itself.</p>"},{"location":"faq/#what-about-gradle-extensibility-and-plugins","title":"What about Gradle extensibility and plugins?","text":"<p>We aim to support most of the Kotlin and Kotlin Multiplatform use cases out of the box and offer a reasonable level of extensibility.</p>"},{"location":"faq/#how-do-amper-and-declarative-gradle-relate-to-each-other","title":"How do Amper and Declarative Gradle relate to each other?","text":"<p>Both projects aim to improve the developer experience and the IDE support, but from opposite directions and with different constraints. Amper's approach is to design, from the ground up, a tool that is easy to use for the developers regardless of their background, with great IDE support in mind, and focused on specific use-cases. The Declarative Gradle project approaches the same goal from the other end,  improving the developer experience and the IDE support in an already exising powerful tool. </p> <p>While both projects are still experimental, it's important that you provide your feedback to shape the future development.</p>"},{"location":"faq/#usage","title":"Usage","text":""},{"location":"faq/#what-are-the-requirements-to-use-amper","title":"What are the requirements to use Amper?","text":"<p>The Amper command line tool doesn't require any software preinstallation, except the Xcode toolchain if you want to  build iOS applications. See the CLI instructions.</p> <p>We recommend using the latest IntelliJ IDEA EAP to make the most out of Amper. Our focus on the tooling and UX really pays off in IntelliJ IDEA. To learn about the required and optional  plugins in IntelliJ IDEA, see the IDE setup instructions.</p>"},{"location":"faq/#how-do-i-create-a-new-amper-project","title":"How do I create a new Amper project?","text":"<p>You have several options:</p> <ul> <li> <p>Open IntelliJ IDEA and create a new Kotlin project with the Amper build tool</p> </li> <li> <p>Kick-start your project using one of the examples</p> </li> <li> <p>Download the Amper script by following the CLI instructions, and generate a project    from a template using the <code>./amper init</code> command.</p> </li> </ul>"},{"location":"faq/#how-do-i-create-a-multi-module-project-in-amper","title":"How do I create a multi-module project in Amper?","text":"<p>See the documentation on the project layout.</p>"},{"location":"faq/#is-there-an-automated-migration-tool","title":"Is there an automated migration tool?","text":"<p>Not currently, but it's certainly something we\u2019re looking into.</p>"},{"location":"faq/#feature-x-is-not-yet-supported-what-can-i-do","title":"Feature X is not yet supported, what can I do?","text":"<p>Please let us know about it! We're eager to hear what you're trying to do, because we plan to expand the list of supported use cases based on demand. Please submit your requests and sugg estions in the   YouTrack issue tracker or join the  Slack channel for discussions.</p>"},{"location":"faq/#can-i-write-a-custom-task-or-use-a-plugin","title":"Can I write a custom task or use a plugin?","text":"<p>Yes! Amper now includes a preview of a plugin system. See the dedicated docs.</p>"},{"location":"faq/#how-can-i-use-c-interop-in-amper","title":"How can I use C-interop in Amper?","text":"<p>For now, Amper doesn't directly support C-interop.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>Ready to try Amper? Choose the right approach for you:</p> <ul> <li> <p> Examples on GitHub</p> <p>Look at complete example projects, and get inspired.</p> </li> <li> <p> Tutorial</p> <p>Create a project from the ground up, step-by-step.</p> </li> <li> <p> User guide</p> <p>Learn about Amper concepts, or deepen your knowledge about specific topics.</p> </li> <li> <p> Start from a template project</p> <p>Use <code>./amper init</code> from the CLI, or create a new Amper project in IntelliJ IDEA.</p> </li> </ul> <p>Good tooling rocks!</p> <p>If you choose to write code on your machine, we recommend using IntelliJ IDEA to make the most out of Amper. Check our IDE setup page for more information. </p>"},{"location":"getting-started/cli/","title":"Amper CLI","text":""},{"location":"getting-started/cli/#installation","title":"Installation","text":"<p>To use the Amper CLI, you need to download the Amper wrapper script to your project's root folder. The script is a small file that downloads and runs the actual Amper CLI distribution, and serves as an entry point for all Amper commands. It is meant to be checked into your VCS, so your team can build and run your project without any installation, no matter their OS.</p> IntelliJ IDEA can take care of this for you <p>New projects created using the IntelliJ IDEA wizard will already contain the wrapper scripts. Also, if you create an Amper <code>module.yaml</code> file in a blank project, IntelliJ IDEA will offer to setup the wrapper scripts for you.</p> <p>Use the following command in your project directory to download the script and set up Amper:</p>  Linux macOS Windows <pre><code>curl -fsSL -o amper https://jb.gg/amper/wrapper.sh &amp;&amp; chmod +x amper &amp;&amp; ./amper update -c\n</code></pre> <pre><code>curl -fsSL -o amper https://jb.gg/amper/wrapper.sh &amp;&amp; chmod +x amper &amp;&amp; ./amper update -c\n</code></pre> PowerShell<pre><code>Invoke-WebRequest -OutFile amper.bat -Uri https://jb.gg/amper/wrapper.bat; ./amper update -c\n</code></pre> cmd.exe<pre><code>curl -fsSL -o amper.bat https://jb.gg/amper/wrapper.bat &amp;&amp; call amper update -c\n</code></pre> <p>The <code>./amper update -c</code> command following the download is not strictly necessary, but it will automatically get the  wrapper script for the other OS. It is good practice to check them both into your VCS so your team can build and run  your project without any installation, on any OS.</p> <p>Note</p> <p>The first time you run the Amper script, it will take some time to download the Amper CLI distribution. Subsequent runs will be faster, as the downloaded files will be cached locally.</p> <p>The <code>./amper update</code> call that is part of the above installation command will actually do this first run for you.</p>"},{"location":"getting-started/cli/#exploring-amper-commands","title":"Exploring Amper commands","text":"<p>The root <code>./amper</code> command and all subcommands support the <code>-h</code> (or <code>--help</code>) option to explore what is possible:</p> <pre><code>./amper --help       # shows the available commands and general options\n./amper build --help # shows the options for the 'build' command specifically\n</code></pre> <p>Useful commands:</p> <ul> <li><code>amper init</code> to create a new Amper project</li> <li><code>amper build</code> to compile and link all code in the project</li> <li><code>amper test</code> to run tests in the project</li> <li><code>amper run</code> to run your application </li> <li><code>amper clean</code> to remove the project's build output and caches</li> </ul> <p>Try it out!</p> <p>Create a new project using the <code>./amper init</code> command and select the JVM console application template.</p> <p>Then build and run the application using <code>./amper run</code>.</p>"},{"location":"getting-started/cli/#tab-completion","title":"Tab-completion","text":"<p>If you\u2019re using <code>bash</code>, <code>zsh</code>, or <code>fish</code>, you can generate a completion script to source as part of your shell\u2019s configuration, to get tab completion for Amper commands.</p> <p>First, generate the completion script using the <code>generate-completion</code> command, specifying the shell you use:</p> bashzshfish <pre><code>./amper generate-completion bash &gt; ~/amper-completion.sh\n</code></pre> <pre><code>./amper generate-completion zsh &gt; ~/amper-completion.sh\n</code></pre> <pre><code>./amper generate-completion fish &gt; ~/amper-completion.sh\n</code></pre> <p>Then load the script in your shell (this can be added to <code>.bashrc</code>, <code>.zshrc</code>, or similar configuration files to load it automatically):</p> <pre><code>source ~/amper-completion.sh\n</code></pre> <p>You should now have tab completion available for Amper subcommands, options, and option values.</p>"},{"location":"getting-started/cli/#updating-amper-to-a-newer-version","title":"Updating Amper to a newer version","text":"<p>Run <code>./amper update</code> to update the Amper scripts and distribution to the latest released version. Use the <code>--dev</code> option if you want to try the bleeding edge dev build of Amper (no guarantees are made on these builds).</p> <p>See <code>./amper update -h</code> for more information about the available options.</p> <p>Don't forget to regenerate your tab-completion script, if you have one.</p>"},{"location":"getting-started/ide-setup/","title":"IDE Setup","text":"Do I need to use IntelliJ IDEA? <p>Amper is a command line tool that stands on its own, so using IntelliJ IDEA is not required. If you prefer to work directly with the terminal or in another IDE, head over to the Amper CLI section.</p> <p>However, to make the most out of Amper and its toolability, we recommend using IntelliJ IDEA. There are tons of diagnostics and quick fixes that make your life a bliss when working with Amper.</p> <ol> <li> <p>Preferably use the latest   IntelliJ IDEA EAP.     The best way to get the most recent IDE versions is by using the   Toolbox App.</p> </li> <li> <p>Make sure to install the   Amper plugin:</p> </li> </ol> <p></p> <ol> <li> <p>[Optional] If you want to write code for  Apple platforms or share code between several platforms,     install the   Kotlin Multiplatform plugin.</p> </li> <li> <p>[Optional] If you want to write some Android-specific code, also install the     Android plugin.</p> </li> </ol>"},{"location":"getting-started/tutorial/","title":"Tutorial","text":"<p>This tutorial gives a short introduction to Amper and how to create a new project.</p> <p>If you are looking for more detailed information, check the user guide.</p>"},{"location":"getting-started/tutorial/#before-you-start","title":"Before you start","text":"<p>If you want to use IntelliJ IDEA to write the code, check the IDE setup instructions to get the relevant plugins.</p>"},{"location":"getting-started/tutorial/#step-1-hello-world","title":"Step 1. Hello, World","text":"<p>The first thing you\u2019d want to try when getting familiar with a new tool is just a simple \"Hello, World\" application. Here is what we do:</p> <p>Create a <code>module.yaml</code> file at the root of your project:</p> module.yaml<pre><code>product: jvm/app\n</code></pre> <p>And add some code in the <code>src/</code> folder:</p> <pre><code>\u251c\u2500 src/\n\u2502  \u2570\u2500 main.kt\n\u2570\u2500 module.yaml\n</code></pre> main.kt<pre><code>fun main() {\n    println(\"Hello, World!\")\n}\n</code></pre> <p>You also need to add the Amper shell scripts to your root project folder.</p> <ul> <li>If you're in IntelliJ IDEA, you can simply use the quick fix in <code>module.yaml</code> to \"Configure standalone Amper\".</li> <li>If not, follow the CLI installation instructions to download them.</li> </ul> <p>Your project should now look like this: <pre><code>\u251c\u2500 src/\n\u2502  \u2570\u2500 main.kt\n\u251c\u2500 module.yaml\n\u251c\u2500 amper\n\u2570\u2500 amper.bat\n</code></pre></p> <p>That\u2019s it, we\u2019ve just created a simple JVM application.</p> <p>And since it\u2019s a JVM project, you can add Java code. Java and Kotlin files can reside together, no need to create separate Maven-like <code>java/</code> and <code>kotlin/</code> folders:</p> <pre><code>\u251c\u2500 src/\n\u2502  \u251c\u2500 main.kt\n\u2502  \u2570\u2500 JavaClass.java\n\u2570\u2500 module.yaml\n</code></pre> <p>You can now build your application using <code>./amper build</code>, or run it using <code>./amper run</code>.</p> Run it directly from IntelliJ IDEA <p>If you're using IntelliJ IDEA, you can use the   Run icon in any of those places:</p> <ul> <li>next to the <code>product:</code> section in <code>module.yaml</code>:</li> </ul> <p></p> <ul> <li>next to the <code>main()</code> function in <code>main.kt</code>:</li> </ul> <p></p> <ul> <li>in the main toolbar</li> </ul> <p>Related documentation</p> <ul> <li>Project layout</li> <li>Module file anatomy</li> <li>Using Amper from the command line</li> </ul>"},{"location":"getting-started/tutorial/#step-2-add-dependencies","title":"Step 2. Add dependencies","text":"<p>Let's add a dependency on a Kotlin library from the Maven repository:</p> module.yaml<pre><code>product: jvm/app\n\ndependencies:\n  - org.jetbrains.kotlinx:kotlinx-datetime:0.6.2\n</code></pre> <p>We can now use this library in the <code>main.kt</code> file:</p> <pre><code>import kotlinx.datetime.*\n\nfun main() {\n    println(\"Hello, World!\")\n    println(\"It's ${Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())} here\")\n}\n</code></pre> <p>Related documentation: Dependencies</p>"},{"location":"getting-started/tutorial/#step-3-add-tests","title":"Step 3. Add tests","text":"<p>Now let\u2019s add some tests. Amper configures the testing framework automatically, we only need to add some test code into the <code>test/</code> folder:</p> <pre><code>\u251c\u2500 src/\n\u2502  \u2570\u2500 ...\n\u251c\u2500 test/\n\u2502  \u2570\u2500 MyTest.kt\n\u2570\u2500 module.yaml\n</code></pre> MyTest.kt<pre><code>import kotlin.test.*\n\nclass MyTest {\n    @Test\n    fun doTest() {\n        assertTrue(true)\n    }\n}\n</code></pre> <p>To add test-specific dependencies, use the dedicated <code>test-dependencies:</code> section. This should be very familiar to Cargo, Flutter and Poetry users. As an example, let's add the MockK library to the project:</p> module.yaml<pre><code>product: jvm/app\n\ndependencies:\n  - org.jetbrains.kotlinx:kotlinx-datetime:0.6.2\n\ntest-dependencies:\n  - io.mockk:mockk:1.13.10\n</code></pre> <p>Example: JVM \"Hello, World!\"</p> <p>Related documentation: Testing</p>"},{"location":"getting-started/tutorial/#step-4-configure-java-and-kotlin","title":"Step 4. Configure Java and Kotlin","text":"<p>Another typical task is configuring compiler settings, such as language level etc. Here is how we do it in Amper:</p> module.yaml<pre><code>product: jvm/app\n\ndependencies:\n  - org.jetbrains.kotlinx:kotlinx-datetime:0.6.2\n\ntest-dependencies:\n  - io.mockk:mockk:1.13.10\n\nsettings:\n  kotlin:\n    languageVersion: 1.8  # Set Kotlin source compatibility to 1.8\n  jvm:\n    release: 17  # Set the minimum JVM version that the Kotlin and Java code should be compatible with.\n</code></pre> <p>Related documentation: Settings</p>"},{"location":"getting-started/tutorial/#step-5-add-a-ui-with-compose","title":"Step 5. Add a UI with Compose","text":"<p>Now, let's turn the example into a GUI application. To do that we'll add the Compose Multiplatform framework. It allows building plain JVM desktop apps, which are simple for now, and paves the way for turning multiplatform later.</p> <p>Let's change our <code>module.yaml</code> to: <pre><code>product: jvm/app\n\ndependencies:\n  # ...other dependencies...\n\n  # add Compose dependencies\n  - $compose.foundation\n  - $compose.material3\n  - $compose.desktop.currentOs\n\nsettings:\n  # ...other settings...\n\n  # enable the Compose framework toolchain  \n  compose:\n    enabled: true\n</code></pre></p> <p>Note</p> <p>The <code>$compose.*</code> dependencies are declared with a special reference syntax here. These are references to the Compose toolchain library catalog, and are available because we enabled the toolchain. Read more about library catalogs in the documentation.</p> <p>We can then replace the contents of <code>main.kt</code> with the following code:</p> <pre><code>import androidx.compose.foundation.text.BasicText\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\n\nfun main() = application {\n    Window(onCloseRequest = ::exitApplication) {\n        BasicText(\"Hello, World!\")\n    }\n}\n</code></pre> <p>Now we have a GUI application!</p> <p>Examples</p> <ul> <li>Compose Desktop</li> <li>Compose Android</li> <li>Compose iOS</li> <li>Compose Multiplatform</li> </ul> <p>Related documentation: Compose Multiplatform</p>"},{"location":"getting-started/tutorial/#step-6-modularize","title":"Step 6. Modularize","text":"<p>Let's split our project into a JVM application and a library module, with shared code that we are going to reuse later when making the project multiplatform.</p> <p>Our goal here is to separate our app into a <code>shared</code> library module and a <code>jvm-app</code> application module and reach the  following structure: <pre><code>\u251c\u2500 jvm-app/\n\u2502  \u251c\u2500 ...\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 shared/\n\u2502  \u251c\u2500 ...\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 amper\n\u251c\u2500 amper.bat\n\u2570\u2500 project.yaml\n</code></pre></p> <p>First let's move our current <code>src</code>, <code>test</code> and <code>module.yaml</code> files into a new <code>jvm-app</code> directory: <pre><code>\u251c\u2500 jvm-app/\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u2570\u2500 main.kt\n\u2502  \u251c\u2500 test/\n\u2502  \u2502  \u2570\u2500 ...\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 amper\n\u2570\u2500 amper.bat\n</code></pre></p> <p>Add a <code>project.yaml</code> file in the root, next to the existing <code>amper</code> and <code>amper.bat</code> files, with the following content:</p> project.yaml<pre><code>modules:\n  - ./jvm-app\n  - ./shared\n</code></pre> <p>If you're using IntelliJ IDEA, you should see a warning that the <code>shared</code> module is missing, and you can automatically create it from here. Otherwise, just create a new <code>shared</code> directory manually, with <code>src</code> and <code>test</code> directories, and a <code>module.yaml</code> with the following content:</p> <pre><code>product:\n  type: lib\n  platforms: [jvm]\n\ndependencies:\n  - $compose.foundation: exported\n  - $compose.material3: exported\n  - $compose.desktop.currentOs: exported\n\nsettings:\n  compose:\n    enabled: true\n</code></pre> <p>Note how the library 'exports' its dependencies. The dependent module will 'see' these dependencies and don't need to explicitly depend on them.</p> <p>We can now change our <code>jvm-app/module.yaml</code> to depend on the <code>shared</code> module:</p> <pre><code>product: jvm/app\n\ndependencies:\n  - ../shared # use the 'shared' module as a dependency\n\nsettings:\n  compose:\n    enabled: true\n</code></pre> <p>Note how the dependency on the <code>shared</code> module is declared using a relative path.</p> <p>Let's extract the common code into a new <code>shared/src/hello.kt</code> file:</p> <pre><code>import androidx.compose.foundation.text.BasicText\nimport androidx.compose.runtime.Composable\n\n@Composable\nfun sayHello() {\n    BasicText(\"Hello, World!\")\n}\n</code></pre> <p>And re-use it in the <code>jvm-app/src/main.kt</code> file: <pre><code>import androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\n\nfun main() = application {\n    Window(onCloseRequest = ::exitApplication) {\n        sayHello()\n    }\n}\n</code></pre></p> <p>We now have a multi-module project with some neatly extracted shared code.</p> <p>Example: Compose Multiplatform</p> <p>Related documentation</p> <ul> <li>Project layout</li> <li>Module dependencies</li> <li>Dependency visibility and scope</li> </ul>"},{"location":"getting-started/tutorial/#step-7-make-the-project-multiplatform","title":"Step 7. Make the project multiplatform","text":"<p>So far we've been working with a JVM platform to create a desktop application. Let's add an Android and an iOS application. It will be straightforward, since we've already prepared a multi-module layout with a shared module that we can reuse.</p> <p>Here is the project structure that we need:</p> <pre><code>\u251c\u2500 android-app/\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u251c\u2500 main.kt\n\u2502  \u2502  \u2570\u2500 AndroidManifest.xml\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 ios-app/\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u251c\u2500 iosApp.swift\n\u2502  \u2502  \u2570\u2500 main.kt\n\u2502  \u251c\u2500 module.yaml\n\u2502  \u2570\u2500 module.xcodeproj\n\u251c\u2500 jvm-app/\n\u2502  \u2570\u2500 ...\n\u251c\u2500 shared/\n\u2502  \u2570\u2500 ...\n\u2570\u2500 project.yaml\n</code></pre> <p>Remember to add the new modules into the <code>project.yaml</code> file:</p> <pre><code>modules:\n  - ./android-app\n  - ./ios-app\n  - ./jvm-app\n  - ./shared   \n</code></pre> <p>The <code>android-app/module.yaml</code> will look like this way: <pre><code>product: android/app\n\ndependencies:\n  - ../shared\n\nsettings:\n  compose:\n    enabled: true\n</code></pre></p> <p>And the <code>ios-app/module.yaml</code>:</p> <pre><code>product: ios/app\n\ndependencies:\n  - ../shared\n\nsettings:\n  compose:\n    enabled: true\n</code></pre> <p>Let's update the <code>shared/module.yaml</code> and add the new platforms and a couple of additional dependencies for Android:</p> <pre><code>product:\n  type: lib\n  platforms: [ jvm, android, iosArm64, iosSimulatorArm64, iosX64 ]\n\ndependencies:\n  - $compose.foundation: exported\n  - $compose.material3: exported\n\ndependencies@jvm:\n  - $compose.desktop.currentOs: exported\n\ndependencies@android:\n  # Compose integration with Android activities\n  - androidx.activity:activity-compose:1.7.2: exported\n  - androidx.appcompat:appcompat:1.6.1: exported\n\nsettings:\n  compose:\n    enabled: true\n</code></pre> <p>Note how we used the <code>dependencies@jvm:</code> and <code>dependencies@android:</code> sections to specify JVM- and Android-specific dependencies. These dependencies will be added to the JVM and Android versions of the <code>shared</code> library correspondingly. They will also be available for the <code>jvm-app</code> and <code>android-app</code> modules, since they depend on the <code>shared</code> module. Read more about multiplatform configuration in the documentation.</p> <p>Now, as we have the module structure, we need to add platform-specific application code to the Android and iOS modules. Create a <code>MainActivity.kt</code> file in <code>android-app/src</code> with the following content:</p> <pre><code>package hello.world\n\nimport sayHello\nimport android.os.Bundle\nimport androidx.activity.compose.setContent\nimport androidx.appcompat.app.AppCompatActivity\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            sayHello()\n        }\n    }\n}\n</code></pre> <p>Next, create a <code>ViewController.kt</code> file in <code>ios-app/src</code>:</p> <pre><code>import sayHello\nimport androidx.compose.ui.window.ComposeUIViewController\n\nfun ViewController() = ComposeUIViewController { \n    sayHello() \n}\n</code></pre> <p>And the last step, copy the AndroidManifest.xml file from an example project into <code>android-app/src</code> folder, and the iosApp.swift file into the <code>ios-app/src</code>. These files bind the Compose UI code with the native application entry points.</p> <p>Make sure that your project structure looks like this: <pre><code>\u251c\u2500 android-app/\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u251c\u2500 main.kt\n\u2502  \u2502  \u2570\u2500 AndroidManifest.xml\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 ios-app/\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u251c\u2500 iosApp.swift\n\u2502  \u2502  \u2570\u2500 main.kt\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 jvm-app/\n\u251c\u2500 shared/\n\u2570\u2500 ...\n</code></pre></p> <p>Now you can build and run both apps using the corresponding IntelliJ IDEA run configurations, or use the CLI commands: <pre><code>./amper run -m android-app\n</code></pre> <pre><code>./amper run -m ios-app\n</code></pre></p> <p>Note</p> <p>After the first build, the Xcode project will appear beside the <code>module.yaml</code> in the <code>ios-app</code> module.  It can be checked into the VCS and customized (e.g. Team (<code>DEVELOPMENT_TEAM</code>) setting). See iOS Support to learn more about the Xcode \u2194 Amper interoperability.</p> <p>Example: Compose Multiplatform</p> <p>Related documentation</p> <ul> <li>multiplatform configuration</li> <li>Compose</li> </ul>"},{"location":"getting-started/tutorial/#step-8-deduplicate-common-configuration","title":"Step 8. Deduplicate common configuration","text":"<p>You might have noticed that there are some settings present in  the <code>module.yaml</code> files. To redce duplication we can extract them into a template.</p> <p>Let's create a couple of <code>&lt;name&gt;.module-template.yaml</code> files: <pre><code>\u251c\u2500 android-app/\n\u2502  \u2570\u2500 ...\n\u251c\u2500 ios-app/\n\u2502  \u2570\u2500 ...\n\u251c\u2500 jvm-app/\n\u2502  \u2570\u2500 ...\n\u251c\u2500 shared/\n\u2502  \u2570\u2500 ...\n\u251c\u2500 compose.module-template.yaml\n\u2570\u2500 app.module-template.yaml\n</code></pre></p> <p>A <code>/compose.module-template.yaml</code> with settings common to all modules: <pre><code>settings:\n  compose:\n    enabled: true\n</code></pre></p> <p>and <code>/app.module-template.yaml</code> with dependencies that are used in the application modules: <pre><code>dependencies:\n  - ./shared\n</code></pre></p> <p>Now we will apply these templates to our module files:</p> <p><code>/shared/module.yaml</code>: <pre><code>product:\n  type: lib\n  platforms: [ jvm, android, iosArm64, iosSimulatorArm64, iosX64 ]\n\napply:\n  - ../compose.module-template.yaml\n\ndependencies:\n  - $compose.foundation: exported\n  - $compose.material3: exported\n\ndependencies@jvm:\n  - $compose.desktop.currentOs\n\ndependencies@android:\n  # Compose integration with Android activities\n  - androidx.activity:activity-compose:1.7.2: exported\n  - androidx.appcompat:appcompat:1.6.1: exported\n</code></pre></p> <p><code>/jvm-app/module.yaml</code>: <pre><code>product: jvm/app\n\napply:\n  - ../compose.module-template.yaml\n  - ../app.module-template.yaml\n</code></pre></p> <p><code>/android-app/module.yaml</code>: <pre><code>product: android/app\n\napply:\n  - ../compose.module-template.yaml\n  - ../app.module-template.yaml\n</code></pre></p> <p><code>/ios-app/module.yaml</code>: <pre><code>product: ios/app\n\napply:\n  - ../compose.module-template.yaml\n  - ../app.module-template.yaml\n</code></pre></p> <p>You can put all common dependencies and settings into the template. It's also possible to have multiple templates  for various typical configurations in the project.</p> <p>Related documentation: Templates</p>"},{"location":"getting-started/tutorial/#further-steps","title":"Further steps","text":"<p>Check the user guide and explore example projects.</p>"},{"location":"plugins/overview/","title":"Plugins in Amper","text":"<p>Important</p> <ol> <li>It is a preview, and things are guaranteed to change. Try it out and give us your feedback!</li> <li>Support for KMP is limited; the current preview is focused on JVM-only projects mostly.     We may cover KMP scenarios better as the plugin subsystem evolves.</li> </ol> <p>You can read this functionality summary or jump right into the Quick Start guide.</p>"},{"location":"plugins/overview/#ideas-at-the-core-of-the-preview","title":"Ideas at the core of the preview","text":"<p>Conceptually, any Amper plugin consists of two parts:</p> <ol> <li> <p>A configurable part that is quick to read and fully exempt from arbitrary code execution:</p> <ul> <li><code>plugin.yaml</code></li> <li><code>@TaskAction</code> function signatures, <code>@Configurable</code> interfaces and enums</li> </ul> </li> <li> <p>An executable part that contains arbitrary task\u2011action implementation code:</p> <ul> <li>Normal code in <code>src/</code>, including its dependencies \u2014 other local modules and libraries</li> </ul> </li> </ol> <p>The configurable part is used to quickly and safely build the project model for tooling in a traceable way. This way we can make project import safe and nearly transparent and provide user\u2011friendly, actionable diagnostics that lead to precise problem locations \u2014 for example, why tasks are wired the way they are, or why certain Maven dependencies are added one way or another. Consequently, this part has limited expressiveness; we are exploring how minimal it can be while remaining useful.</p> <p>On the other hand, the executable part is only needed at build execution time and has no significant restrictions.</p>"},{"location":"plugins/overview/#summary-of-what-is-currently-extensible","title":"Summary of what is currently extensible","text":"<p>Plugins can currently extend the build with custom build actions \u2014 tasks. Such tasks can receive configuration, consume file\u2011system locations (<code>Path</code>s), or produce them. They can contribute specific typed entities to the build and/or consume them from the build.</p> <p>Task actions can consume:</p> <ul> <li>Typed contents from the build:<ul> <li>module sources/resources (via built\u2011in <code>ModuleSources</code> configurable, e.g., <code>${module.sources}</code>/<code>${module.resources}</code>)</li> <li>module compilation result (via built\u2011in <code>CompilationArtifact</code> configurable, e.g., <code>${module.jar}</code>)</li> <li>module runtime/compilation classpath (via built\u2011in <code>Classpath</code> configurable, e.g., <code>${module.runtimeClasspath}</code>/<code>${module.compileClasspath}</code>)</li> <li>resolve arbitrary Maven dependencies as an ad hoc classpath (via a custom <code>Classpath</code> configuration, like <code>myClasspath: [ \"group:name:version\", ... ]</code>)</li> </ul> </li> <li>arbitrary file trees via specified paths</li> </ul> <p>Task actions can produce:</p> <ul> <li>Typed contents:<ul> <li>Kotlin/Java sources (via <code>markOutputAs</code>)</li> <li>resources (via <code>markOutputAs</code>)</li> </ul> </li> <li>arbitrary file trees in specified paths</li> </ul> <p>For more information on these features, see the KDocs on these built\u2011in configurable interfaces.</p>"},{"location":"plugins/overview/#missing-functionality","title":"Missing functionality","text":""},{"location":"plugins/overview/#planned-for-upcoming-releases","title":"Planned for upcoming releases","text":"<ul> <li>Packaging and publishing plugins</li> <li>Bundled module templates in plugins to contribute to the configuration of the modules they are applied to</li> <li>A simpler way of authoring trivial plugins consisting of a single task, template, etc.</li> <li>Dependencies between plugins</li> </ul>"},{"location":"plugins/overview/#we-may-consider-providing-solutions-for","title":"We may consider providing solutions for","text":"<ul> <li>Supporting conditionals/loops in the declarative configuration</li> <li>Alternatives to YAML as the configuration language</li> </ul> <p>Your requests and reports are welcome!</p> <p>File us a plugins-related issue here.</p>"},{"location":"plugins/quick_start/","title":"Quick Start","text":""},{"location":"plugins/quick_start/#how-to-write-a-plugin","title":"How to write a plugin","text":"<p>Here we are going to learn how to write a toy build plugin in Amper that exposes some external build\u2011time data to the application by generating sources.</p> <p>Let's define what we want from our plugin for starters. The plugin would be able to parse a <code>.properties</code> file and generate Kotlin properties out of it. Later we may implement additional features.</p>"},{"location":"plugins/quick_start/#basic-example","title":"Basic example","text":"<p>We will name our plugin <code>build-config</code>. We are going to add it to our existing project.</p> <p>Let's take a look at the whole project structure we aim for in advance:</p> <pre><code>&lt;root&gt;/\n\u251c\u2500 app/\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 build-config/\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u2570\u2500 **.kt\n\u2502  \u251c\u2500 module.yaml\n\u2502  \u2570\u2500 plugin.yaml\n\u251c\u2500 utils/\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 ... #(1)!\n\u2570\u2500 project.yaml\n</code></pre> <ol> <li>Other project modules</li> </ol> <p>The <code>project.yaml</code> would look like this then: project.yaml<pre><code>modules:\n  - app   #(1)!\n  - build-config #(2)!\n  - utils #(3)!\n  - ...   #(4)!\n\nplugins: #(5)!\n  - ./build-config\n</code></pre></p> <ol> <li>Regular module, e.g., <code>jvm/app</code></li> <li>Our plugin is also a normal module and needs to be listed here</li> <li>Regular <code>jvm/lib</code> module, that contains, e.g., generic utilities useful for most modules in the project</li> <li>There may be other project modules</li> <li>This is a block where we list our plugin dependencies to make available in the project.</li> </ol> <p>And the <code>build-config/module.yaml</code> would look like: build-config/module.yaml<pre><code>product: jvm/amper-plugin\n</code></pre></p> <p>This is already a valid (although incomplete) Amper plugin.</p> <p>It has a plugin ID which equals the plugin module name (<code>build-config</code>) by default. The plugin ID is the string by which the plugin is going to be referred to throughout the project, e.g., to enable/configure it.</p> <p>Declaring the plugin in the <code>plugins</code> section of <code>project.yaml</code> makes it available to the project, but it is not yet enabled in (applied to) any of its modules. Learn more about it here. But it doesn't contain anything useful yet.</p> <p>Let's start implementing our plugin by writing a task action that would do the source generation based on the contents of the properties file. For now, we'll do the code formatting by hand: build-config/src/generateSources.kt<pre><code>package com.example\n\nimport org.jetbrains.amper.plugins.*\n\nimport java.nio.file.Path\nimport java.util.*  \nimport kotlin.io.path.*\n\n@TaskAction\n@OptIn(ExperimentalPathApi::class)\nfun generateSources(\n    @Input propertiesFile: Path,\n    @Output generatedSourceDir: Path,\n) {\n    generatedSourceDir.deleteRecursively() //(1)!\n    val outputFile = generatedSourceDir / \"properties.kt\"\n\n    if (!propertiesFile.isRegularFile()) {//(2)!\n        println(\"No input\")\n        return\n    }\n    println(\"Generating sources\")//(3)!\n\n    val properties = propertiesFile.bufferedReader().use { reader -&gt;  \n        Properties().apply { load(reader) }  \n    }.toMap()  \n\n    outputFile.createParentDirectories()//(4)!\n    val code = buildString {\n        appendLine(\"package com.example.generated\")\n        appendLine(\"public object Config {\")\n        for ((key, value) in properties) {\n            appendLine(\"    const val `$key`: String = \\\"$value\\\"\")\n        }\n        appendLine(\"}\")\n    }\n    outputFile.writeText(code)\n}\n</code></pre></p> <ol> <li>Clean the old state if any is present from the previous invocation</li> <li>Input file may not exist at all, need to check that</li> <li>Simple logging (structured logging support comes later)</li> <li>Need to ensure the output directory structure exists: Amper doesn't pre-create it for us</li> </ol> <p>The code can be written in any Kotlin file in any package \u2013 there's no convention here. <code>@TaskAction</code> is a marker for a top-level Kotlin function that can be registered as a task. <code>@Input</code>/<code>@Output</code> are marker annotations required for <code>Path</code>\u2011referencing action parameters to tell Amper how to treat these paths.</p> <p>Info</p> <p>Amper automatically uses task execution avoidance based on the contents of <code>@Input</code>/<code>@Output</code>-annotated paths.</p> <p>Declaring a task action does nothing by itself yet. The task with the action must be registered explicitly to become available in modules the plugin is enabled in. To do that, we need a special file to register tasks and define how they use the plugin's configuration \u2013 <code>plugin.yaml</code>:</p> build-config/plugin.yaml<pre><code>tasks:\n  generate: # (1)!\n    action: !com.example.generateSources\n      propertiesFile: ${module.rootDir}/config.properties # (2)!\n      generatedSourceDir: ${taskOutputDir}\n</code></pre> <ol> <li>Registers the <code>generate</code> task</li> <li>Specifies the conventional location for the source .properties file</li> </ol> <p>Note that the task action's type is specified using the type tag \u2014 <code>!com.example.generateSources</code> \u2014 using the fully qualified function name.</p> <p>As we see here, the <code>plugin.yaml</code> file allows Amper references with the syntax <code>${foo.bar.baz}</code>. Here we use the built\u2011in reference\u2011only property <code>taskOutputDir</code> to direct our output to the unique task\u2011associated output directory that Amper provides for us. And <code>module.rootDir</code> is the directory of the module the plugin is applied to.  Learn more about Amper-provided reference-only properties.</p> <p>But we need to make Amper aware that our output is, in fact, generated Kotlin sources, so the build tool can include them in the compilation, IDE can resolve symbols from them, etc. To do that, we'll use the <code>markOutputAs</code> clause in our task registration:</p> build-config/plugin.yaml<pre><code>tasks:\n  generate:\n    action: !com.example.generateSources\n      propertiesFile: ${module.rootDir}/config.properties\n      generatedSourceDir: ${taskOutputDir}\n  markOutputsAs:\n    - path: ${action.generatedSourceDir}\n      kind: kotlin-sources # (1)!\n</code></pre> <ol> <li><code>java-sources</code> and <code>jvm-resources</code> are also possible here</li> </ol> <p>We've added an item to the <code>markOutputsAs</code> list, where we reference our <code>generatedSourceDir</code> path and state, that <code>kotlin-sources</code> will be located there after the task is run.</p> <p>That's it with the plugin for now! Let's enable it in one of our modules (<code>app</code>):</p> app/module.yaml<pre><code>plugins:\n  build-config: enabled # (1)!\n\n# ... Other things, like settings, dependencies, etc.\n</code></pre> <ol> <li><code>&lt;plugin-id&gt;: enabled</code> is a shorthand;  <code>&lt;plugin-id&gt;: { enabled: true }</code> is the full form</li> </ol> <p>If we now run the build, we'll see that our generated <code>com.example.Config</code> object is present and is visible in the IDE,  and <code>\"Generating sources\"</code> is being logged to the console.</p> <p>Now let's explore what else we can enhance about our plugin:</p> <ul> <li>Let's use a third-party library to generate Kotlin code instead of doing it manually.</li> <li>Our plugin should also accept values directly from the user configuration in their <code>module.yaml</code>, in addition to taking them from the properties file.</li> <li>Let's introduce a toy task that just prints all the generated sources to the stdout.</li> </ul>"},{"location":"plugins/quick_start/#adding-library-dependencies","title":"Adding library dependencies","text":"<p>We often don't implement a plugin from scratch but rather use the existing tool or a library and wrap around it. Amper plugins, being normal Amper modules, can depend on other modules and/or external libraries. Let's use the <code>kotlin-poet</code> library to make our Kotlin code generation more robust and convenient. In addition to that, let's assume we have a <code>utils</code> module in the project. This module is a collection of some utilities that are used across the project \u2013 we'd like to use them in our plugin implementation as well.</p> build-config/module.yaml<pre><code>product: jvm/amper-plugin\n\ndependencies:\n  - com.squareup:kotlinpoet:2.2.0 # (1)!\n  - ../utils # (2)!\n</code></pre> <ol> <li>Plugins support external Maven dependencies.</li> <li>Plugins support depending on another local module, unless this introduces a dependency cycle, see below.</li> </ol> <p>(For the sake of brevity, we are not going to list the code written with <code>kotlin\u2011poet</code> APIs here, as the exact code is largely irrelevant in our example.)</p> Info: no meta\u2011build in Amper \u2014 plugins can depend on regular modules <p>Amper doesn't have a notion of a meta\u2011build (e.g., \"included builds\"/<code>buildSrc</code>, etc.).  Plugin modules are built inside the same build as the other \"production\" modules. This way, plugins can easily depend on any other project modules (like <code>utils</code> in our example), as long as there are no physical cyclic dependencies between internal actions.</p> <p>Example: Self\u2011documenting</p> <p>A documentation plugin can technically be safely applied to itself, because when the documentation generation runs, the plugin's code itself can already be built and can be executed in a task to generate the docs for itself.</p> <p>Example: Can't generate resources for itself</p> <p>If a plugin contributes anything to the compilation, it can't be applied to itself, because the cyclic dependency is detected: <pre><code>1. task `generateSources` in module `my-plugin` from plugin `my-plugin` (*)\n   \u2570\u2500\u2500\u2500&gt; depends on the compilation of its source code\n2. compilation of module `my-plugin` &lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n   \u2570\u2500\u2500\u2500&gt; needs sources from \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n3. source generation for module `my-plugin` &lt;\u2500\u256f\n   \u2570\u2500\u2500\u2500&gt; includes the directory `&lt;project-build-dir&gt;/tasks/_my-plugin_generateSources@my-plugin` generated by\n4. task `generateSources` in module `my-plugin` from plugin `my-plugin` (*) &lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre></p> <p>Warning</p> <p>Currently, Amper plugins can't depend on other plugins meaningfully, other than to share some implementation pieces. This is not recommended anyway \u2013 use common utility modules instead.</p>"},{"location":"plugins/quick_start/#adding-plugin-settings","title":"Adding plugin settings","text":"<p>Until now, our plugin just used the fixed values/paths, hardcoded within the plugin, with no ability to change them on the module level. Here we'll describe a way to \"parameterize\" the plugin, so users can configure its behavior.</p> <p>Suppose we want the user to be able to:</p> <ul> <li>customize the properties file name</li> <li>provide additional properties values</li> </ul> <p>Let's whip up our public plugin settings definition: build-config/src/settings.kt<pre><code>package com.example\n\nimport org.jetbrains.amper.plugins.Configurable\n\n@Configurable\ninterface Settings {\n   /** \n    * Properties file name (without extension) \n    * that is located in the module root.\n    */\n   val propertiesFileName: String get() = \"config\"\n\n   /**\n    * Extra properties to generate in addition to the ones read from the \n    * properties file. \n    */\n   val additionalConfig: Map&lt;String, String&gt; get() = emptyMap()\n}\n</code></pre></p> <p>Let's be nice and use KDocs!</p> <p>The provided KDocs are going to be visible in the IDE in the tooltips for plugin settings in <code>module.yaml</code>.</p> <p>Such an interface acts like a YAML schema to describe the configuration our plugin may receive from the user. For that we need the <code>@Configurable</code>-annotated public interface with the properties of configurable types and optional default values, expressed as default getter implementations.</p> <p>Now we need to tell Amper which of our <code>@Configurable</code> declarations is the root of the plugin settings that users can configure in their module files. In our case, it's <code>com.example.Settings</code>: build-config/module.yaml<pre><code>product: jvm/amper-plugin\n\ndependencies: # ...\n\npluginInfo:\n  settingsClass: com.example.Settings\n</code></pre></p> <p>Tip</p> <p>It is good practice to provide reasonable defaults for all the plugin settings if possible, so the user still can use the plugin right away by simply having written, e.g., <code>build-config: enabled</code>.</p> <p>This way, we can now configure our plugin in the app's <code>module.yaml</code>: app/module.yaml<pre><code>plugins:\n  build-config:\n    enabled: true # (1)!\n    propertiesFileName: \"konfig\" # (2)!\n    additionalConfig:\n      VERSION: \"1.0\"\n</code></pre></p> <ol> <li>We still need to enable our plugin explicitly.</li> <li>Overrides the default \"config\" value from Kotlin.</li> </ol> <p>Warning</p> <p>It is not yet possible to use references (<code>${...}</code>) in <code>module.yaml</code> files or access the module configuration tree from <code>plugin.yaml</code>. We are planning on supporting this in some quality in the following releases.</p> <p>But wait! We've added the plugin settings and even used them to customize the plugin behavior. But we haven't wired them to our task! Let's fix that.</p> <p>First on the Kotlin side: build-config/src/generateSources.kt<pre><code>// ...\n@TaskAction\nfun generateSources(\n  @Input propertiesFile: Path,\n  @Output generatedSourceDir: Path,\n  additionalConfig: Map&lt;String, String&gt;, //(1)!\n) {\n  // ...\n}\n</code></pre></p> <ol> <li><code>additionalConfig: Map&lt;String, String&gt;</code> parameter does not require an <code>@Input</code> annotation,       because all \"plain data\" (no references to <code>Path</code> within the type) parameters are already considered as task inputs.</li> </ol> <p>And on the \"declarative\" side: build-config/plugin.yaml<pre><code>tasks:\n  generate:\n    action: !com.example.generateSources\n      propertiesFile: \n        ${module.rootDir}/${pluginSettings.propertiesFileName}.properties\n      additionalConfig: ${pluginSettings.additionalConfig}\n      generatedSourceDir: ${taskOutputDir}\n  markOutputsAs:\n    - path: ${action.generatedSourceDir}\n      kind: kotlin-sources\n</code></pre></p> <p><code>pluginSettings</code> is a global reference-only property that contains the configured plugin settings for each module the plugin is applied to. In our case the type of <code>pluginSettings</code> would be <code>com.example.Settings</code> which we specified in <code>pluginInfo.settingsClass</code>.</p> <p>So, e.g., when the plugin is applied to the <code>app</code> module in our example when we refer to the <code>${pluginSettings.propertiesFileName}</code> in <code>plugin.yaml</code>, we would get the <code>\"konfig\"</code> value the user specified in their <code>plugins.build-config.propertiesFileName</code> in <code>app/module.yaml</code></p>"},{"location":"plugins/quick_start/#adding-another-task","title":"Adding another task","text":"<p>As planned, let's now add another task to the plugin that simply reads the already generated sources and prints them to stdout.</p> build-config/src/printSources.kt<pre><code>package com.example\n\n// import ...\n\n@TaskAction\nfun printSources(\n  @Input sourceDir: Path,\n) {\n  sourceDir.walk().forEach { file -&gt;\n    println(file.pathString)\n    println(file.readText())\n  }\n}\n</code></pre> build-config/plugin.yaml<pre><code>tasks:\n  generate:\n    action: !com.example.generateSources\n      # ...\n      generatedSourceDir: ${taskOutputDir}\n\n  print:\n    action: !com.example.printSources\n      sourceDir: ${generate.action.generatedSourceDir}\n</code></pre> <p>In the line <code>sourceDir: ${generate.action.generatedSourceDir}</code> we reference an <code>@Output</code> path of another task. In addition to automatic execution avoidance for individual tasks, Amper automatically infers task dependencies based on matching <code>@Input</code> paths with <code>@Output</code> paths. In our example it means that if the task <code>generate</code> has a path <code>/generated/sources</code> in the <code>@Output</code> position, and the task <code>print</code> has the matching path in the <code>@Input</code> position, then <code>print</code> will depend on the <code>generate</code>. More on task dependencies here.</p> <p>Info</p> <p>If a task has no declared <code>@Output</code>s (like <code>print</code> in our example), then no execution avoidance is done for it \u2014 it will always run the action. This is done because tasks without outputs are almost always introduced for side effects, e.g., diagnostics or deployment.</p> <p>Now we've added the <code>print</code> task, we'd like to use it. Unlike the <code>generate</code> task, it doesn't declare any outputs that are contributed back to the build, so it won't be executed automatically when build/test/run is invoked. So, to run a task manually, one must use the following CLI command:</p> <pre><code>$ ./amper task :app:print@build-config\n</code></pre> <p>That's it for this tutorial! You can study some specific topics about Amper plugins and/or go try to write one yourself.</p>"},{"location":"plugins/quick_start/#learn-more","title":"Learn more","text":"<p>Consuming things from the Amper build</p> <p>See the dedicated documentation section with examples.</p> <p>Tip</p> <p>There are plugins that we ourselves have implemented and are already using in Amper. Feel free to take a look!</p> <ul> <li>Protobuf</li> <li>Binary Compatibility Validator</li> <li>a couple of purely internal ones, like <code>amper-distribution</code></li> </ul> <p>If you haven't already, check the more detailed reference on the specific topics:</p> <ul> <li>Plugin Structure</li> <li>Configuration</li> <li>References</li> <li>Tasks</li> </ul>"},{"location":"plugins/topics/configuration/","title":"Configuration","text":"<p>This section provides details on how to configure tasks and plugin settings, how the schema works, default values and more.</p> <p>YAML?</p> <p>Amper currently uses \"Amper-flavored\" YAML as the configuration language. YAML is flexible, and it allowed us to move fast with prototyping solutions, plugins included. However, we are aware of YAML's shortcomings  and are exploring the possibility of replacing YAML with a custom language tailored for our needs in the future.  </p>"},{"location":"plugins/topics/configuration/#configurable-types","title":"Configurable types","text":"<p>Amper configuration only works with configurable types. Configurable types are types, values for which can be</p> <ol> <li>provided in our YAML configs</li> <li>denoted on the Kotlin side to be used in task actions</li> </ol> Amper type Kotlin type YAML structure <code>string</code> <code>kotlin.String</code> scalar <code>boolean (true | false)</code> <code>kotlin.Boolean</code> scalar <code>integer</code> <code>kotlin.Int</code> scalar <code>path</code> <code>java.nio.file.Path</code> scalar <code>enum E</code> <code>enum class E</code> scalar <code>sequence [T]</code> <code>kotlin.collections.List&lt;T&gt;</code> sequence <code>mapping {string : T}</code> <code>kotlin.collections.Map&lt;String, T&gt;</code> mapping/sequence of pairs <code>object T</code> <code>@Configurable interface T</code> mapping + others <code>T | null</code> <code>T?</code> \"null\" scalar <p>Task action parameters and properties in <code>@Configurable</code> interfaces are only allowed to be of configurable types. </p> <p>Note</p> <p>Currently, any custom configurable type \u2014 for example, a <code>@Configurable</code> interface or an enum \u2014 defined in plugin <code>A</code> cannot be reused in plugin <code>B</code>, even if the module of plugin <code>A</code> has module <code>B</code> as its dependency. The tool will issue an \"Unexpected schema type\" diagnostic. This restriction may be lifted in the future.</p> <p>There are also built\u2011in variant types, but the mechanism is not yet allowed in user code.</p>"},{"location":"plugins/topics/configuration/#configurable-interfaces","title":"Configurable interfaces","text":"<p>A configurable interface is a public Kotlin interface annotated with the <code>@Configurable</code> annotation. Restrictions apply to this interface:</p> <ul> <li>methods, superinterfaces, generics are not allowed</li> <li>it may only have immutable non-extension (<code>val</code>) properties of the configurable types.   Such a property may have a default getter implementation, depending on a type.</li> <li>See the defaults section. </li> </ul> Valid configurable declarations<pre><code>@Configurable\ninterface MySettings {\n    /**\n    * Note: KDocs on configurable entities are visible to the tooling\n    */\n    val booleanSetting: Boolean\n    val intSetting: Int\n    val stringSetting: String\n    val nested: Nested\n    val pathSetting: Path\n    val mapSetting: Map&lt;String, String&gt;\n    val listSetting: List&lt;Nested&gt;\n}\n\n@Configurable\ninterface Nested {\n    val enumSetting: MyEnum\n    val nullableStringSetting: String?\n}\n\nenum class MyEnum { Hello, Bye }\n</code></pre>"},{"location":"plugins/topics/configuration/#plugin-settings","title":"Plugin settings","text":"<p>A <code>@Configurable</code> interface may be specified in a plugin's <code>module.yaml</code> to expose it as user\u2011facing plugin settings: module.yaml<pre><code>pluginInfo:\n  settingsClass: com.example.MyPluginSettings\n</code></pre></p> <p>The property with the name <code>enabled</code> is reserved in such interfaces.</p> <p>Then the object with this type (e.g., <code>com.example.MyPluginSettings | null</code>) becomes available under <code>plugins.&lt;plugin-id&gt;</code> in every module in the project. An additional synthetic boolean <code>enabled</code> shorthand property is present in the object to control if the plugin is applied to the module or not.</p>"},{"location":"plugins/topics/configuration/#enums","title":"Enums","text":"<p>Generally, any enum is allowed in the configuration. You may want to specify custom names for the enum constants to be used in configuration, using the <code>@EnumValue</code> annotation. Otherwise, the <code>name</code> of the entry is used in the configuration. </p> KotlinYAML <pre><code>enum class MyEnum {\n    Hello,\n    @EnumValue(\"byeBye\")\n    Bye,\n}\n</code></pre> <pre><code>myEnum1: Hello\nmyEnum2: byeBye\n</code></pre>"},{"location":"plugins/topics/configuration/#default-values","title":"Default values","text":"<p>Properties and task action parameters are allowed to have default values specified in Kotlin.</p> <p>Properties use default getter implementation syntax. The getter must have an expression body:</p> <pre><code>@Configurable interface Settings {\n    val myBoolean get() = false\n    val myString get() = \"default\"\n}\n</code></pre> <p>Task parameters use the regular default value syntax:</p> <pre><code>@TaskAction fun myAction(\n    myBoolean = false,\n    myString = \"default\",\n) { /*...*/ }\n</code></pre> Amper type Supported explicit default values <code>string</code>, <code>boolean</code>, <code>integer</code> Kotlin constant expression of the appropriate type <code>enum E</code> enum constant references, e.g., <code>E.Constant</code> <code>path</code> not supported yet <code>sequence [T]</code> <code>emptyList()</code> <code>mapping {string : T}</code> <code>emptyMap()</code> <code>T | null</code> <code>null</code> (not required - implicit default) <code>object T</code> not supported (instantiated implicitly, see the note) <p>Note</p> <p>Properties of <code>@Configurable</code> interface types can't have explicit defaults specified. However, all objects are instantiated by default using their default values and the values provided at the configuration (YAML) side. If some required (with no default at all) values remain unconfigured, then the error is issued and the configuration is rejected.</p>"},{"location":"plugins/topics/configuration/#advanced","title":"Advanced","text":"<p>Info</p> <p>Although these features are present in the typing/configuration system and are used in some built\u2011in APIs, they are not yet ready to be used by plugin authors in their own Kotlin code.</p> <p>You may read the following sections at your leisure if you seek to better understand how dependency notation, task actions or \"short forms\" work in Amper.</p>"},{"location":"plugins/topics/configuration/#shorthand-notation","title":"Shorthand notation","text":"<p>Some built\u2011in <code>@Configurable</code> interfaces, e.g., <code>Classpath</code>, allow the \"shorthand\" notation. They have a property marked with the <code>@Shorthand</code> internal annotation. This enables objects of the type to be constructed in a \"short\" form: not from the YAML mapping, but from the value of the type that the shorthand property has. Other properties are then set to their default values.</p> <p>For example, <code>classpath: [ \"foo:bar:1.0\" ]</code> is a short form of <pre><code>classpath:\n  dependencies: [ \"foo:bar:1.0\" ]\n</code></pre> because the <code>dependencies</code> property is marked as a \"shorthand\".</p> <p>Warning</p> <p>Shorthands do not currently work with references. E.g., if there's a property <code>foo</code> of the <code>sequence[Dependency]</code> type, then <code>classpath: ${foo}</code> will not work. So, the expanded form <code>classpath: { dependencies: ${foo} }</code> is required.</p> <p>The special case for the shorthand notation is when the shorthand property is a boolean. Then, instead of the <code>true</code> keyword, one needs to write the property name itself, e.g., <code>enabled</code>. For example, plugin settings have an implicit synthetic <code>enabled</code> property which is a shorthand.</p>"},{"location":"plugins/topics/configuration/#variant-types","title":"Variant types","text":"<p>On the Kotlin side they are modeled as a <code>@Configurable</code> <code>sealed</code> interface. When a variant type is expected, there is a need to express which exact variant is being provided in the configuration. This ability to express the exact type is not yet well-designed in Amper and generally looks unintuitive in YAML.</p> <p>So for the built\u2011in <code>Dependency { Local, Maven }</code> variant type Amper infers the type based on the <code>@DependencyNotation</code> string contents:</p> <ul> <li>if the dependency string starts with the <code>.</code> it is a local dependency </li> <li>otherwise it is a Maven dependency</li> </ul>"},{"location":"plugins/topics/configuration/#task-action-types","title":"Task action types","text":"<p>Technically, task's <code>action</code> property also has a variant type. This type is synthetic, and its variants are also synthetic types that are based on all the signatures of all the <code>@TaskAction</code> functions in the plugin, so all the task parameters become properties with the correspodning types. And in this case an explicit YAML type tag is required to communicate the exact type.</p>"},{"location":"plugins/topics/references/","title":"References","text":"<p>Amper uses its own value\u2011reference system using the <code>${...}</code> syntax. Throughout the documentation this syntax is referred to as Amper references or simply references. Currently, its usage is limited to plugin configuration files (<code>plugin.yaml</code>).</p> <p>Info</p> <p>Standard YAML anchors (<code>&amp;</code>) and aliases (<code>*</code>) are not supported in Amper and Amper references are used instead.</p>"},{"location":"plugins/topics/references/#syntax","title":"Syntax","text":"<p>References are specified using the <code>${...}</code> syntax. Inside the braces a property path is specified \u2014 one or more dot\u2011separated reference parts, e.g., <code>${start.one.two.three}</code></p>"},{"location":"plugins/topics/references/#string-interpolation","title":"String interpolation","text":"<p>One or more references can be embedded in YAML scalar values \u2014 string interpolation. This works for properties that expect either <code>string</code> or <code>path</code> types.</p> <ul> <li>For strings: <code>prefix-${some.name}-suffix</code></li> <li>For paths: <code>base/${something.dir}/${file.name}.name</code></li> </ul> <p>References pointing to values of <code>string</code>, <code>path</code>, <code>integer</code>, or <code>enum</code> can be used in string interpolation.</p> <p>Note</p> <p>References inside mapping keys are not yet allowed. So constructions like this are not permitted: <pre><code>myMap:\n  ${module.name}: \"value\"\n</code></pre></p>"},{"location":"plugins/topics/references/#reference-resolution","title":"Reference resolution","text":"<p>Assume we have a reference <code>${foo.bar.baz}</code>:</p> <ul> <li><code>foo</code> is the starting part</li> <li><code>bar</code> and <code>baz</code> are the remaining parts</li> </ul> <p>Reference resolution is done relative to the location of the reference in the value tree.</p> <ol> <li>The starting part is resolved, i.e., the property with the name matching the starting part is found,    searching upward in the lexical scopes.</li> <li>The remaining parts are resolved consequently as member-properties against the starting value.  </li> </ol> <p>The lexical scope consists of all property names in the given YAML mapping, including names that are implicitly present there. Such implicit properties are:</p> <ul> <li>properties that are not specified explicitly but have default values</li> <li>reference-only properties</li> </ul> <p>Example: how scopes are defined</p> <pre><code>sibling-object:\n  foo: 1\n  bar: 4 # scopes here: (1)\nobject:\n  # foo: 1 (by default)\n  # provided: 2 (reference-only)\n  list:\n    - quu: 'a'\n      buu: 'b' # scopes here: (2)\n  baz: 3\n  bar: 4 # scopes here: (3)\n</code></pre> <ol> <li> <p>(in the order of the lookup):</p> <ol> <li><code>{foo, bar}</code></li> <li><code>{sibling-object, object}</code></li> </ol> </li> <li> <p>(in the order of the lookup):</p> <ol> <li><code>{quu, buu}</code></li> <li><code>{foo, provided, list, baz, bar}</code></li> <li><code>{sibling-object, object}</code></li> </ol> </li> <li> <p>(in the order of the lookup):</p> <ol> <li><code>{foo, provided, list, baz, bar}</code></li> <li><code>{sibling-object, object}</code></li> </ol> </li> </ol> <p>Cyclic references are not allowed! This includes references that ultimately point to each other or to a direct sub- or super-tree of each other.</p> <p>Info</p> <p>There is no way to refer to the list element (using indexes or otherwise). So <code>${myList.0.foo}</code> is not possible.</p> <p>Info</p> <p>Not every built\u2011in property in <code>plugin.yaml</code> can be referenced (be the final value that a reference resolves to). Some properties are there purely as configuration DSL/skeleton/sections, e.g., <code>markOutputsAs</code> list or the <code>tasks</code> map. Referencing these things directly makes no sense and is forbidden. They can, however, appear as the starting/intermediate reference part, e.g., <code>tasks.myTask.action.myInput</code>.</p>"},{"location":"plugins/topics/references/#type-compatibility","title":"Type compatibility","text":"<p>The resolved value's type must be assignable to the property's type:</p> <ul> <li><code>null</code> values are assignable to nullable (<code>| null</code>) types.</li> <li><code>string</code>, <code>path</code>, <code>integer</code>, and <code>enum</code> values are assignable to <code>string</code> properties.</li> </ul>"},{"location":"plugins/topics/references/#reference-only-properties","title":"Reference-only properties","text":"<p>The properties below are available for referencing in <code>plugin.yaml</code> and are read\u2011only. Their values are provided by Amper itself, and they are designed to provide the plugin author  with the necessary information to configure the plugin logic.</p>"},{"location":"plugins/topics/references/#global","title":"Global","text":"<p>These properties are available in the root scope:</p> <pre><code># module: { ... }\n# pluginSettings: { ... }\n\ntasks:\n  myTask: {...}\n</code></pre> Property path Type Description <code>pluginSettings</code> the type specified in <code>pluginInfo.settingsClass</code> The plugin\u2019s settings object from the <code>plugins.&lt;plugin-id&gt;</code> block of the module the plugin is applied to. <code>module.name</code> <code>string</code> Module display name. <code>module.rootDir</code> <code>path</code> Absolute path to the module root (where <code>module.yaml</code> is). <code>module.runtimeClasspath</code> <code>Classpath</code> Resolved runtime classpath (JVM, main). <code>module.compileClasspath</code> <code>Classpath</code> Compile classpath plus the module\u2019s compilation result. <code>module.kotlinJavaSources</code> <code>ModuleSources</code> Kotlin and Java sources (JVM, main). <code>module.resources</code> <code>ModuleSources</code> Resources (JVM, main). <code>module.jar</code> <code>CompilationArtifact</code> Compiled JAR (JVM, main). <code>module.self</code> <code>Dependency.Local</code> A dependency pointing to the module itself <p>Note</p> <p><code>pluginSettings</code> is defined only if a plugin has a settings class.</p>"},{"location":"plugins/topics/references/#task-scoped","title":"Task-scoped","text":"<p>These properties are available in the lexical scope for every task:</p> <pre><code>tasks:\n  myTask:\n    # taskOutputDir\n    action: {...}\n</code></pre> Property path Type Description <code>taskOutputDir</code> <code>path</code> Unique output directory for the given task. <p>Warning</p> <p>Sometimes a user\u2011defined property may clash with another one or with a reference\u2011only one. For example: <pre><code>action: !myAction\n  module: ${module.name}\n</code></pre> As the lookup of the starting part happens upwards rather than from the root,  this will lead to a cyclic\u2011reference error. So instead of the reference-only <code>module</code> from the root scope the resolution will find the <code>module</code> property in the current scope. These reference resolution shortcomings are known; for now, avoid name clashes to prevent such situations.</p>"},{"location":"plugins/topics/structure/","title":"Plugin structure","text":"<p>Plugin is a normal Amper module with the <code>jvm/amper-plugin</code> product type. It has a normal <code>module.yaml</code> build file, with an additional <code>pluginInfo</code> section available.</p> <p>In addition, a plugin has a <code>plugin.yaml</code> file, where tasks are registered and configured.</p> <p>Plugin build logic is written in Kotlin in the <code>src</code> directory.</p> Planned: simple cases \u2013 simpler structure <p>There can be simpler cases for custom build logic for which having a full-blown plugin may be overkill. For example, a single ad-hoc task action that is only needed in one module.</p> <p>We are planning to improve UX for such cases and provide a more laconic way to express them.</p> <p>Plugin has an ID, which equals to its module name by default. The plugin ID is used across the project to refer to the plugin, e.g., when enabling it or in diagnostic messages.</p> Plugin ID can be customized <p>For example: build-config/module.yaml<pre><code>pluginInfo:\n  id: \"build-konfig\"\n</code></pre> This changes the ID from the default <code>build-config</code> to <code>build-konfig</code>.</p> <p> Changing the default ID makes little sense if we are not sharing the plugin between projects, which is not supported yet. Currently, the ID string doesn't have well-defined format, so leaving the ID at its default is a good idea. </p>"},{"location":"plugins/topics/structure/#making-plugins-available-in-the-project","title":"Making plugins available in the project","text":"<p>Amper plugins are module-level plugins \u2013 they are enabled and applied per module. There is no such concept as a project-wide plugin in Amper.</p> <p>To make a plugin available in the project, the dependency on it must be listed under the <code>plugins</code>section of the <code>project.yaml</code> file: <pre><code>modules:\n  - ...\n  - plugins/my-plugin\n\nplugins:\n  - ./plugins/my-plugin\n</code></pre></p> <p>Plugins listed this way are not yet enabled anywhere. One must enable them manually in each module where they are needed.</p> <p>There may be cases where a plugin is developed as part of the project, but not needed in the project itself. Then such a plugin is present in the <code>modules</code> list, but not included in the <code>plugins</code> list.</p> Similar to <code>apply false</code> in Gradle... <p>Amper's approach to listing plugins project-wide and applying them per-module is somewhat similar to the  recommended approach in Gradle. There one lists plugins at the project level with the <code>apply false</code> clause and then just enables them where needed.</p>"},{"location":"plugins/topics/structure/#enabling-plugins","title":"Enabling plugins","text":"<p>Plugins can be enabled and configured like this:</p> module.yaml (shorthand)module.yaml (expanded) <p>Just to enable the plugin and leave the default configuration: <pre><code>plugins:\n  &lt;plugin-id&gt;: enabled\n</code></pre></p> <p>To enable the plugin and configure the plugin settings: <pre><code>plugins:\n  &lt;plugin-id&gt;:\n    enabled: true\n    # other options\n</code></pre></p> <p>Tip</p> <p>If many modules use the same plugin, potentially even using some common settings for it, then it may make sense to use a dedicated module template that enables and configures the plugin.</p>"},{"location":"plugins/topics/tasks/","title":"Tasks","text":""},{"location":"plugins/topics/tasks/#task-action-definition","title":"Task action definition","text":"<p>Task actions are top-level Kotlin functions annotated with <code>@TaskAction</code>.  Restrictions for a task action function:</p> <ul> <li>must be a top-level, public function</li> <li>must return <code>Unit</code></li> <li>must not be an extension, generic, <code>suspend</code>, <code>inline</code>, or have context parameters</li> <li>parameter types must be configurable types</li> </ul> <p>Parameters are allowed to have default values as per configurable defaults.</p>"},{"location":"plugins/topics/tasks/#path-parameters","title":"Path parameters","text":"<p>Parameters of type <code>Path</code> require an explicit role:</p> <ul> <li><code>@Input</code> if the path points to files/directories read by the action</li> <li><code>@Output</code> if the path points to files/directories written by the action</li> </ul> <p>The requirement applies transitively: if a parameter\u2019s type contains a <code>Path</code> anywhere inside, the parameter must still be marked with either <code>@Input</code> or <code>@Output</code>, so the build tool knows their semantics.</p> <p>Example</p> <p>Examples of types that require the parameters to be annotated with input/output marker:</p> <ul> <li><code>List&lt;Path&gt;</code></li> <li><code>Map&lt;String, Path&gt;</code></li> <li><code>Distribution</code>, defined as:   <pre><code>@Configurable interface Distribution {\n  val manifestPath: Path\n  val binaryPath: Path\n}\n</code></pre></li> <li>built\u2011in configurable interfaces that request files, e.g., <code>ModuleSources</code>, <code>Classpath</code>, etc.</li> </ul> <p>Info</p> <p>Special built\u2011in configurable interfaces that are used to request files from the build \u2014 such as <code>ModuleSources</code>, <code>Classpath</code>, or <code>CompilationArtifact</code> \u2014 are always required to be annotated with <code>@Input</code>.</p> <p>All non\u2011<code>Path</code>\u2011referencing parameters are considered inputs and do not require any additional annotations.</p>"},{"location":"plugins/topics/tasks/#tasks-runtime","title":"Tasks runtime","text":"<p>Tasks are executed inside an isolated JVM environment, and no guarantees are made about the state of static globals from one task action invocation to the other. </p> <p>At the moment tasks are effectively executed inside the Amper JVM using an isolated plugin classloader that contains only the plugin's runtime classpath.  This concrete implementation is very much likely to change in the future, so it is advised not to rely on it.</p>"},{"location":"plugins/topics/tasks/#runtime-api","title":"Runtime API","text":"<p>There is no currently available runtime API exposed for tasks, besides the configuration system. So plugin authors are free to use whatever libraries they need to implement things. In the future some runtime APIs that Amper can provide and support will be added.</p>"},{"location":"plugins/topics/tasks/#logging","title":"Logging","text":"<p>Use <code>System.out/err</code>, Amper will associate the output with the task name in its build log. Structured logging support is coming soon.</p>"},{"location":"plugins/topics/tasks/#execution-avoidance","title":"Execution avoidance","text":"<p>Amper uses a built\u2011in execution\u2011avoidance mechanism for task actions by default. When not disabled, Amper decides whether to rerun an action based on:</p> <ul> <li>the action execution classpath changes (if the action code is recompiled, tasks using the action need to be rerun)</li> <li>effective values of the action arguments that are non\u2011paths, including property values of configurable interfaces, recursively </li> <li>the state of all gathered file-tree inputs and file-tree outputs declared via <code>@Input</code>/<code>@Output</code></li> </ul> <p>Note</p> <p>Currently, only file attributes and modification time are inspected to compute if a file tree changed. No file content checking is performed.  </p> <p>This behavior is controlled per action by the <code>executionAvoidance</code> parameter of <code>@TaskAction</code> annotation:</p> <ul> <li><code>ExecutionAvoidance.Automatic</code> (default) \u2014 compute up\u2011to\u2011dateness as described above. If a task action declares no outputs, it always re\u2011runs.</li> <li><code>ExecutionAvoidance.Disabled</code> \u2014 always re\u2011run the action regardless of inputs/outputs.    Use this if the task has side effects and/or its up\u2011to\u2011date state needs to be computed in a more complex way.</li> </ul> <p>Tip</p> <p>When implementing the desired build logic as task actions, keep the execution avoidance in mind. For example, for a deployment plugin that builds and publishes a distribution, it is better to have two separate tasks: <code>build</code> and <code>publish</code>. The <code>build</code> task can be \"incremental\" and benefit from automatic execution avoidance because it's easy to declare its inputs and outputs; while <code>publish</code> task has undeclarable side effects and cannot be incremental at the build system level.</p>"},{"location":"plugins/topics/tasks/#task-dependencies","title":"Task Dependencies","text":"<p>Dependencies between user\u2011registered tasks are inferred automatically from matching <code>@Input</code> and <code>@Output</code> paths in their actions:</p> <ul> <li>If task A declares an <code>@Output</code> path and task B declares an <code>@Input</code> path that matches it, Amper adds a dependency from B to A.</li> <li> <p>Paths are considered matching when they are either equal or one is an ancestor or descendant of the other.   For example:</p> <ul> <li><code>/foo/bar</code> and <code>/foo/bar/out.txt</code> are matching</li> <li><code>/foo/bar</code> and <code>/foo/baz</code> are not matching</li> </ul> </li> </ul> <p>Info</p> <p>If an <code>@Input</code> points inside the build directory but no task produces a matching <code>@Output</code>, a warning is issued to help catch misconfigured paths.</p> <p>There is no way to specify task dependencies manually for now.</p>"},{"location":"plugins/topics/tasks/#disabling-dependency-inference-for-a-particular-input","title":"Disabling dependency inference for a particular input","text":"<p>Use <code>@Input(inferTaskDependency = false)</code> on a path parameter when you do not want a dependency to be inferred, even if another task writes to the same path.</p> <p>Example</p> <p>This is needed for \u201cbaseline\u201d files where an \u201cupdate\u201d task writes the baseline and a \u201ccheck\u201d task reads and compares it. If a dependency were inferred, \u201cupdate\u201d would always run before \u201ccheck\u201d, hiding problems.</p> <p>A good example of this case could be seen in the Binary Compatibility Validator.</p> <p>Note</p> <p>Disabling dependency inference on an input with <code>@Input(inferTaskDependency = false)</code> only affects task wiring. The file(s) pointed to by that input are still considered for execution\u2011avoidance decisions.</p>"},{"location":"plugins/topics/tasks/#task-registration","title":"Task Registration","text":"<p>Tasks are registered declaratively in the plugin\u2019s <code>plugin.yaml</code> under the <code>tasks</code> map. Each entry creates a task instance with a short name (the map key):</p> <pre><code>tasks:\n  myTaskName:\n    action: !fully.qualified.function.name\n      param1: ...\n      param2: ...\n    markOutputsAs:\n      - path: ...\n        kind: ...\n</code></pre> <p>The task action is specified using the <code>action</code> property. This property requires an explicit YAML type tag, in this example <code>!fully.qualified.function.name</code>, to express which exact action the task uses. The tag starts with the bang (<code>!</code>) and then goes the fully qualified name of the Kotlin <code>@TaskAction</code> function. There is a note on how this works on the configuration level.</p> <p>The properties of the <code>action</code> object correspond to parameters of the Kotlin function.</p> <p>The same task action can be registered multiple times under different task names and with different argument values. Tasks are registered once in <code>plugin.yaml</code>, but they are instantiated per module where the plugin is enabled.</p> Why does the concept of a task feel split between Kotlin and YAML? <p>As we want to provide the best tooling and IDE assistance, we want the most information available \"declaratively\" so it can be easily traced and made available quickly and safely.</p> <p>The build tool still needs to preprocess Kotlin code to extract task signatures and configurable types. So we want to have the least amount of information in Kotlin, mostly only implementation.</p> <p>Custom task actions can be reused multiple times in different tasks. Also, there can be shared/built\u2011in universal task actions like <code>copy</code>, <code>download</code>, <code>unzip</code>, etc.</p> <p>So registering a new task can be as easy as dropping a few lines of YAML (for now) and reusing the ready task action.</p> <p>Now, inputs/outputs markup is done in Kotlin because it is inherently bound to the action itself  (if the action reads from the file, it is an input), while <code>markOutputsAs</code> is not necessarily so: a generic <code>unzip</code> action may be actually unzipping some sources, and only a concrete plugin may know that, so it needs to convey it at the registration site.</p>"},{"location":"plugins/topics/tasks/#naming-and-addressing","title":"Naming and addressing","text":"<p>The task name is local to the plugin. Different plugins may use the same task names without conflicts.</p>"},{"location":"plugins/topics/tasks/#internal-name","title":"Internal name","text":"<p>In logs and in the CLI, a task is addressed as <code>:&lt;module-name&gt;:&lt;task-name&gt;@&lt;plugin-id&gt;</code>. This is also what you see in tasks output and what you pass to the task command to run a task manually.</p> <p>Info</p> <p>The plugin ID is part of the internal task name. By default, it is the plugin module name, unless overridden in <code>pluginInfo.id</code>.  See the quick start guide for examples of running tasks and customizing the plugin ID.</p> <p>The internal name of a task should not ideally be exposed and used externally. We are working on making it so. </p>"},{"location":"plugins/topics/tasks/#contributing-back-to-the-build","title":"Contributing back to the build","text":"<p>There are a bunch of things the Amper build can consume that can be produced by a custom task. In order to contribute some typed files back to the build, we need the following:</p> <ol> <li>To have a necessary path marked as an <code>@Output</code> in the task action</li> <li>To add an entry to the <code>markOutputsAs</code> list at the registration site, referring to the path and specifying the desired content kind.</li> </ol> <p>Currently supported content kinds:</p> Content kind Description <code>kotlin-sources</code> A directory containing Kotlin sources to be compiled together with the module <code>java-sources</code> A directory containing Java sources to be compiled together with the module <code>jvm-resources</code> A directory containing jvm resources to be bundled together with the module <p>Example</p> <pre><code>tasks:\n  generate:\n    action: !com.example.generateSources\n      propertiesFile: ${module.rootDir}/config.properties\n      generatedSourceDir: ${taskOutputDir} #(1)!\n  markOutputsAs:\n    - path: ${action.generatedSourceDir}\n      kind: kotlin-sources\n</code></pre> <ol> <li><code>generatedSourceDir</code> is <code>@Output generatedSourceDir: Path</code> in Kotlin</li> </ol>"},{"location":"plugins/topics/tasks/#advanced","title":"Advanced","text":"<p>One can customize the platform and/or main/test scope the content is associated with using the <code>fragment</code> clause of the <code>markOutputsAs</code> list element. It has two properties: <code>modifier: string</code> and <code>isTest: boolean</code>. The <code>modifier</code> string has the same semantics as the suffix one can put after the <code>@</code> in the <code>module.yaml</code> configuration or in the names of <code>src</code> directories. For example, having: <pre><code>markOutputAs:\n  - path: ${action.generatedSourceDir}\n    kind: kotlin-sources\n    fragment:\n      isTest: true\n      modifier: ios\n</code></pre> would make Amper treat the generated sources as if they were put into the <code>test@ios</code> directory.</p>"},{"location":"plugins/topics/tasks/#consuming-things-from-the-build","title":"Consuming things from the build","text":"<p>Warning</p> <p>Currently, most of the built\u2011in configurables used to request things from the build are JVM\u2011only.</p>"},{"location":"plugins/topics/tasks/#requesting-layout-agnostic-module-sources","title":"Requesting layout-agnostic module sources","text":"<p>To request module sources, we can use the built\u2011in <code>org.jetbrains.amper.plugins.ModuleSources</code> configurable. It should always be marked as <code>@Input</code>. The <code>includeGenerated</code> property allows the task to depend on the other code generating steps in the build, like other custom tasks or KSP, and include their results in <code>sourceDirectories</code> as well.</p> <p>Example</p> someKindOfLinter.ktplugin.yaml (just user sources)plugin.yaml (including generated sources) <pre><code>@TaskAction\nfun someKindOfLinter(\n    @Input sources: ModuleSources,\n    moduleName: String,\n) {\n    sources.sourceDirectories.forEach { dir -&gt;\n        println(\"Module `$moduleName` has $dir as its source directory\")\n    }\n}\n</code></pre> <pre><code>tasks:\n  lint:\n    action: !someKindOfLinter\n      moduleName: ${module.name}\n      sources: ${module.sources}\n</code></pre> <pre><code>tasks:\n  lint:\n    action: !someKindOfLinter\n      moduleName: ${module.name}\n      sources:\n        from: ${module.self}\n        includeGenerated: true\n</code></pre> <p>Tip</p> <p>Using <code>ModuleSources</code> even in the simple case is more robust than just referring to <code>${module.rootDir}/src</code>, because it takes module layout into account (and multiplatform source directories \u2014 coming soon).</p>"},{"location":"plugins/topics/tasks/#requesting-classpathad-hoc-dependency-resolution","title":"Requesting classpath/ad-hoc dependency resolution","text":"<p>Amper models a request to get a resolved classpath as the built\u2011in <code>org.jetbrains.amper.plugins.Classpath</code> configurable. It also must always be an <code>@Input</code>. There are a bunch of convenience reference\u2011only properties like <code>module.runtimeClasspath</code> or <code>module.compileClasspath</code>, but one can also construct a <code>Classpath</code> spec to request an ad hoc dependency resolution.</p> <p>Example</p> packageClasspath.ktplugin.yaml <pre><code>@TaskAction\nfun packageClasspath(\n    @Input appClasspath: Classpath,\n    @Input extraClasspath: Classpath?,\n) {\n    appClasspath.resolvedFiles.forEach {  it.copyTo(...) }\n    ...\n}\n</code></pre> <pre><code>tasks:\n  package:\n    action: !packageTheApp\n      appClasspath: ${module.runtimeClasspath} #(1)!\n      extraClasspath: #(2)!\n        - foo:bar:1.0\n        - ${pluginSettings.extraDependency}\n</code></pre> <ol> <li>A convenience value for the <code>{ dependencies: [ ${module.self} ], scope: runtime }</code></li> <li>Resolves arbitrary dependencies (local, Maven) in the specified scope (<code>runtime</code> by default)</li> </ol>"},{"location":"plugins/topics/tasks/#requesting-a-module-compilation-result","title":"Requesting a module compilation result","text":"<p>As opposed to the <code>runtimeClasspath</code>, sometimes we want to get just the JAR that is the result of the module's compilation. To do that we can refer to the <code>${module.jar}</code> which has the <code>org.jetbrains.amper.plugins.CompilationArtifact</code> type.</p> <p>Example</p> copyJar.kt <pre><code>@TaskAction\nfun copyJar(jar: CompilationArtifact) {\n    jar.artifact.copyTo(...)\n}\n</code></pre> plugin.yaml <pre><code>tasks:\n  copy:\n    action: !copyJar\n      jar: ${module.jar} #(1)!\n</code></pre> <ol> <li>A convenience value for the <code>{ from: ${module.self} }</code></li> </ol>"},{"location":"plugins/topics/tasks/#run-a-task","title":"Run a task","text":"<p>If the task contributes something to the build, it probably doesn't ever need to be invoked explicitly by hand. It is invoked automatically by the build system or tooling to ensure that generated contents are up to date.</p> <p>If the task needs to serve as an entry point to the build, then, currently, it needs to be run manually via the Amper CLI using the task's internal name:</p> <pre><code>$ ./amper task :moduleName:taskName@pluginId\n</code></pre> <p>We are working on providing a proper UX for calling plugin tasks.</p>"},{"location":"plugins/topics/tasks/#learn-more","title":"Learn more","text":"<p>To see more practical examples of how to write tasks, you are welcome to check out the quick start guide and our plugin samples in the <code>build-sources</code> directory of the Amper project.</p>"},{"location":"reference/module/","title":"Module file reference","text":""},{"location":"reference/module/#aliases","title":"<code>aliases</code>","text":"<p>An alias can be used to share code, dependencies, and/or settings between a group of platforms that doesn't already  have a name (an exclusive common ancestor) in the default hierarchy. Aliases can be used as <code>@platform</code> qualifiers in the settings.</p> <p>Read more about aliases.</p> <p>Example:</p> <pre><code># Create an alias to share code between JVM and Android platforms.  \nproduct:\n  type: lib\n  platforms: [ jvm, android, iosArm64, iosSimulatorArm64 ]\n\naliases:\n  - jvmAndAndroid: [jvm, android]\n\n# Dependencies for JVM and Android platforms:\ndependencies@jvmAndAndroid:\n  ...\n</code></pre>"},{"location":"reference/module/#apply","title":"<code>apply</code>","text":"<p><code>apply:</code> section lists the templates applied to the module. Read more about the module templates</p> <p>Use <code>- ./&lt;relative path&gt;</code> or <code>- ../&lt;relative path&gt;</code> notation, where the <code>&lt;relative path&gt;</code> points at a template file.</p> <p>Example:</p> <pre><code># Apply a `common.module-template.yaml` template to the module\nproduct: jvm/app\n\napply:\n  - ../common.module-template.yaml\n</code></pre>"},{"location":"reference/module/#dependencies-and-test-dependencies","title":"<code>dependencies</code> and <code>test-dependencies</code>","text":"<p><code>dependencies:</code> section defines the list of modules and libraries necessary to build the module. Certain dependencies can also be exported as part of the module API. Read more about the dependencies.</p> <p><code>test-dependencies:</code> section defines the dependencies necessary to build and run tests of the module. Read more about the module tests.</p> <p>Supported dependency types:</p> Notation Description <code>- ./&lt;relative path&gt;</code><code>- ../&lt;relative path&gt;</code> Dependency on another module in the codebase. <code>- &lt;group ID&gt;:&lt;artifact ID&gt;:&lt;version&gt;</code> Dependency on a Kotlin or Java library in a Maven repository. <code>- $&lt;catalog.key&gt;</code> Dependency from a dependency catalog. <code>- bom: &lt;group ID&gt;:&lt;artifact ID&gt;:&lt;version&gt;</code> Dependency on a BOM. <code>- bom: $&lt;catalog.key&gt;</code> Dependency on a BOM from a dependency catalog. <p>Each dependency (except BOM) has the following attributes:</p> Attribute Description Default <code>exported: boolean</code> Whether a dependency should be visible as a part of a published API. <code>false</code> <code>scope: enum</code> When the dependency should be used. Read more about the dependency scopes. <code>all</code> <p>Available scopes:</p> Scopes Description <code>all</code> The dependency is available during compilation and runtime. <code>compile-only</code> The dependency is only available during compilation. This is a 'provided' dependency in Maven terminology. <code>runtime-only</code> The dependency is not available during compilation, but available during testing and running. <p>Examples:</p> <pre><code># Short form for the dependency attributes\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0                   # Kotlin or Java dependency \n  - org.postgresql:postgresql:42.3.3: runtime-only\n  - ../common-types: exported                        # Dependency on another module in the codebase \n  - $compose.foundation                              # Dependency from the 'compose' catalog\n  - bom: io.ktor:ktor-bom:2.2.0                      # Importing BOM \n  - io.ktor:ktor-serialization-kotlinx-json          # Kotlin or Java dependency with a version resolved from BOM\n</code></pre> <pre><code># Full form for the dependency attributes\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0\n  - ../common-types:\n      exported: true\n      scope: all\n  - org.postgresql:postgresql:42.3.3:\n      exported: false\n      scope: runtime-only\n</code></pre> <p>The <code>dependencies:</code> section can also be qualified with a platform:</p> <pre><code># Dependencies used to build the common part of the product\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0\n\n# Dependencies used to build the JVM part of the product\ndependencies@jvm:\n  - io.ktor:ktor-client-java:2.2.0\n  - org.postgresql:postgresql:42.3.3: runtime-only\n</code></pre>"},{"location":"reference/module/#layout","title":"<code>layout</code>","text":"<p>The <code>layout</code> defines the module file structure. Valid values:</p> <ul> <li><code>amper</code>: place your files in <code>src</code>, <code>test</code>, and <code>resources</code> directories </li> <li><code>maven-like</code>: just like Maven (<code>src/main/kotlin</code>, <code>src/main/java</code>, <code>src/test/kotlin</code>, <code>src/main/resources</code>)</li> </ul> <p>The default value is <code>amper</code>.</p> <p>The <code>maven-like</code> layout is only supported in modules with <code>jvm/app</code> or <code>jvm/lib</code> product type.</p> <p>Examples:</p> <pre><code>product: jvm/app\n\nlayout: maven-like\n\nsettings:\n  # ...\n</code></pre>"},{"location":"reference/module/#product","title":"<code>product</code>","text":"<p>The <code>product:</code> section defines what should be produced out of the module. Read more about the product types.</p> Attribute Description <code>type: enum</code> What type of product to generate. <code>platform: enum list</code> What platforms to generate the product for. <p>Supported product types and platforms:</p> Product Type Description Platforms <code>lib</code> A reusable multiplatform library that other modules can depend on. any (the list must be specified explicitly) <code>jvm/lib</code> A JVM library that other modules can depend on. <code>jvm</code> <code>jvm/app</code> A JVM console or desktop application. <code>jvm</code> <code>linux/app</code> A native Linux application. <code>linuxX86</code>, <code>linuxArm64</code> <code>windows/app</code> A native Windows application. <code>mingwX64</code> <code>macos/app</code> A native macOS application. <code>macosX64</code>, <code>macosArm64</code> <code>android/app</code> An Android VM application. <code>android</code> <code>ios/app</code> An iOS application. device: <code>iosArm64</code>, simulators: <code>iosX64</code>, <code>iosSimulatorArm64</code> <code>js/app</code> A JavaScript application. <code>js</code> <code>wasmJs/app</code> A Wasm (JS) application. <code>wasmJs</code> <code>wasmWasi/app</code> A Wasm (WASI) application. <code>wasmWasi</code> <p>Check the list of all Kotlin Multiplatform targets and the level of their support.</p> <p>Examples:</p> Short form<pre><code># Defaults to all supported platforms for the corresponding target\nproduct: macos/app\n</code></pre> Full form, explicitly specified platforms<pre><code>product:\n  type: macos/app\n  platforms: [ macosArm64, macosArm64 ]\n</code></pre> Multiplatform Library for JVM and Android platforms<pre><code>product:\n  type: lib\n  platforms: [ jvm, android ]\n</code></pre>"},{"location":"reference/module/#repositories","title":"<code>repositories</code>","text":"<p><code>repositories:</code> section defines the list of repositories used to look up and download the module dependencies. Read more about the dependency repositories.</p> Attribute Description Default <code>url: string</code> The url of the repository. <code>id: string</code> The ID of the repository, used for to reference it. repository url <code>credentials: object</code> Credentials for the authenticated repositories. empty <p>Read more on the repository configuration Credentials support username/password authentication and have the following attributes:</p> Attribute Description <code>file: path</code> A relative path to a file with the credentials. Currently, only <code>*.property</code> files are supported. <code>usernameKey: string</code> A key in the file that holds the username. <code>passwordKey: string</code> A key in the file that holds the password. <p>Examples:</p> Short form<pre><code>repositories:\n  - https://repo.spring.io/ui/native/release\n  - https://jitpack.io\n</code></pre> Full form<pre><code>repositories:\n  - url: https://repo.spring.io/ui/native/release\n  - id: jitpack\n    url: https://jitpack.io\n</code></pre> Specifying credentials<pre><code>repositories:\n  - url: https://my.private.repository/\n    credentials:\n      file: ./local.properties\n      usernameKey: my.private.repository.username\n      passwordKey: my.private.repository.password  \n</code></pre>"},{"location":"reference/module/#settings-and-test-settings","title":"<code>settings</code> and <code>test-settings</code>","text":"<p><code>settings:</code> section configures the toolchains used in the build process. Read more about settings configuration.</p> <p><code>test-settings:</code> section controls building and running the module tests. Read more about the module tests.</p>"},{"location":"reference/module/#settingsandroid","title":"<code>settings.android</code>","text":"<p><code>settings.android</code> configures the Android toolchain and platform.</p> Attribute Description Default <code>applicationId: string</code> The ID for the application on a device and in the Google Play Store. Read more. (namespace) <code>namespace: string</code> A Kotlin or Java package name for the generated <code>R</code> and <code>BuildConfig</code> classes. Read more. org.example.namespace <code>compileSdk: int</code> The API level to compile the code. The code can use only the Android APIs up to that API level. Read more. 36 <code>targetSdk: int</code> The target API level for the application. Read more. (compileSdk) <code>minSdk: int</code> Minimum API level needed to run the application. Read more. 21 <code>maxSdk: int</code> Maximum API level on which the application can run. Read more. <code>signing: object</code> Android signing settings. Read more. <code>versionCode: int</code> Version code. Read more. 1 <code>versionName: string</code> Version name. Read more. unspecified <code>parcelize: object \\| string</code> Configure Parcelize."},{"location":"reference/module/#settingsandroidparcelize","title":"<code>settings.android.parcelize</code>","text":"<p><code>settings.android.parcelize</code> configures Parcelize for the Android platform in the module. The value can be the simple <code>enabled</code> string, or an object with the following attributes:</p> Attribute Description Default <code>enabled: boolean</code> Whether to enable Parcelize. When enabled, an implementation of the <code>Parcelable</code> interface is automatically generated for classes annotated with <code>@Parcelize</code>. <code>additionalAnnotations: string list</code> The full-qualified names of additional annotations that should be considered as <code>@Parcelize</code>. This is useful if you need to annotate classes in common code shared between different platforms, where the real <code>@Parcelize</code> annotation is not available. In that case, create your own common annotation and add its fully-qualified name so that Parcelize recognizes it. (empty) Short form<pre><code># Enables Parcelize to process @Parcelize-annotated classes\nsettings:\n  android:\n    parcelize: enabled\n</code></pre> Custom annotation<pre><code># Configures Parcelize to process a custom @com.example.MyCommonParcelize annotation\nsettings:\n  android:\n    parcelize:\n      enabled: true\n      additionalAnnotations: [ com.example.MyCommonParcelize ]\n</code></pre>"},{"location":"reference/module/#settingsandroidsigning","title":"<code>settings.android.signing</code>","text":"<p><code>settings.android.signing</code> configures signing of Android apps Read more</p> Attribute Description Default <code>enabled: boolean</code> Whether signing enabled or not. Read more. false <code>propertiesFile: path</code> Location of properties file. Read more. ./keystore.properties"},{"location":"reference/module/#settingscompose","title":"<code>settings.compose</code>","text":"<p><code>settings.compose</code> configures the Compose Multiplatform framework. Read more about Compose configuration.</p> Attribute Description Default <code>enabled: boolean</code> Enable Compose runtime, dependencies and the compiler plugins. <code>false</code> <code>version: string</code> The Compose plugin version to use. <code>1.8.2</code> <code>resources: object</code> Compose Resources settings. <code>experimental: object</code> Experimental Compose settings. <p><code>settings.compose.resources</code> configures Compose Resources settings.</p> Attribute Description Default <code>packageName: string</code> A unique identifier for the resources in the current module. Used as package for the generated Res class and for isolating resources in the final artifact. <code>\"\"</code> <code>exposedAccessors: boolean</code> Whether the generated resources accessors should be exposed to other modules (public) or internal. <code>false</code> <p><code>settings.compose.experimental</code> configures experimental Compose features.</p> Attribute Description Default <code>hotReload: object</code> Experimental Compose hot-reload settings. <p><code>settings.compose.experimental.hotReload</code> configures experimental hot reload (JVM only).</p> Attribute Description Default <code>version: string</code> The Compose Hot Reload toolchain version to use. <code>1.0.0-rc01</code> <p>Examples:</p> Short form<pre><code>settings:\n  compose: enabled\n</code></pre> Full form<pre><code>settings:\n  compose:\n    enabled: true\n    version: 1.6.10\n</code></pre> Full form with resources configuration<pre><code>settings:\n  compose:\n    enabled: true\n    version: 1.6.10\n    resources:\n      packageName: \"com.example.myapp.resources\"\n      exposedAccessors: true\n</code></pre>"},{"location":"reference/module/#settingsjava","title":"<code>settings.java</code>","text":"<p><code>settings.java</code> configures the Java language and the compiler.</p> Attribute Description Default <code>annotationProcessing: object</code> Java annotation processing settings (empty) <code>freeCompilerArgs: string list</code> Pass any compiler option directly to the Java compiler (empty) <code>compileIncrementally: boolean</code> Enables incremental compilation for Java sources <code>false</code>"},{"location":"reference/module/#settingsjavaannotationprocessing","title":"<code>settings.java.annotationProcessing</code>","text":"<p><code>settings.java.annotationProcessing</code> configures Java annotation processing.</p> Attribute Description Default <code>processors: list</code> The list of annotation processors to use. Each item can be a path to a local module, a catalog reference, or maven coordinates (empty) <code>processorOptions: map</code> Options to pass to annotation processors (empty) <p>Examples:</p> <pre><code>settings:\n  java:\n    annotationProcessing:\n      processors:\n        - org.mapstruct:mapstruct-processor:1.6.3\n</code></pre> Passing processor options<pre><code>settings:\n  java:\n    annotationProcessing:\n      processors:\n        - $libs.auto.service # using catalog reference\n      processorOptions:\n        debug: true\n</code></pre>"},{"location":"reference/module/#settingsjunit","title":"<code>settings.junit</code>","text":"<p><code>settings.junit</code> configures the JUnit test runner on the JVM and Android platforms. Read more about testing support.</p> <p>By default, JUnit 5 is used.</p> Value Description <code>junit-5</code> JUnit 5 dependencies and the test runner are configured (default). <code>junit-4</code> JUnit 4 dependencies and the test runner are configured. <code>none</code> JUnit is not automatically configured."},{"location":"reference/module/#settingsjvm","title":"<code>settings.jvm</code>","text":"<p><code>settings.jvm</code> configures the JVM platform-specific settings.</p> Attribute Description Default <code>release: enum</code> The minimum JVM release version that the code should be compatible with. This enforces compatibility on 3 levels. First, it is used as the target version for the bytecode generated from Kotlin and Java sources. Second, it limits the Java platform APIs available to Kotlin and Java sources. Third, it limits the Java language constructs in Java sources. If this is set to null, these constraints are not applied and the compiler defaults are used. 21 <code>mainClass: string</code> (Only for <code>jvm/app</code> product type) The fully-qualified name of the class used to run the application. auto-detected <code>storeParameterNames: boolean</code> Enables storing formal parameter names of constructors and methods in the generated class files. These can later be accessed using reflection. false <code>runtimeClasspathMode: enum</code> How the runtime classpath is constructed: <code>jars</code> (default) builds local module dependencies as jars; <code>classes</code> uses compiled classes for local modules on the runtime classpath. <code>jars</code>"},{"location":"reference/module/#settingsjvmtest","title":"<code>settings.jvm.test</code>","text":"<p><code>settings.jvm.test</code> configures the test settings on the JVM and Android platforms. Read more about testing support.</p> Value Description <code>junitPlatformVersion: string</code> The JUnit platform version used to run tests. <code>systemProperties: map</code> JVM system properties for the test process. <code>freeJvmArgs: string list</code> Free JVM arguments for the test process."},{"location":"reference/module/#settingskotlin","title":"<code>settings.kotlin</code>","text":"<p><code>settings.kotlin</code> configures the Kotlin language and the compiler.</p> Attribute Description Default <code>languageVersion: enum</code> Provide source compatibility with the specified version of Kotlin. 2.1 <code>apiVersion: enum</code> Allow using declarations only from the specified version of Kotlin bundled libraries. (languageVersion) <code>allWarningsAsErrors: boolean</code> Turn any warnings into a compilation error. <code>false</code> <code>suppressWarnings: boolean</code> Suppress the compiler from displaying warnings during compilation. <code>false</code> <code>verbose: boolean</code> Enable verbose logging output which includes details of the compilation process. <code>false</code> <code>progressiveMode: boolean</code> Enable the progressive mode for the compiler. <code>false</code> <code>optIns: enum list</code> Enable usages of API that requires opt-in with a requirement annotation with the given fully qualified name. (empty) <code>freeCompilerArgs: string list</code> Pass any compiler option directly. <code>debug: boolean</code> (Only for native targets) Enable emitting debug information. <code>true</code> <code>serialization: object \\| enum</code> Configure Kotlin serialization. <code>allOpen: object</code> Configure the Kotlin all-open compiler plugin. <code>noArg: object</code> Configure the Kotlin no-arg compiler plugin. <p>The <code>serialization:</code> attribute is an object with the following properties:</p> Attribute Description Default <code>enabled: boolean</code> Enable the <code>@Serializable</code> annotation processing, and add the core serialization library. When enabled, a built-in catalog for kotlinx.serialization format dependencies is provided. <code>false</code> <code>format: enum</code> A shortcut for <code>enabled: true</code> and adding the given serialization format dependency. For instance, <code>json</code> adds the JSON format in addition to enabling serialization. <code>version: string</code> The version to use for the core serialization library and the serialization formats. <code>1.9.0</code> <p>You can also use a short form and directly specify <code>serialization: enabled</code> or <code>serialization: json</code>.</p> <p>Examples:</p> <pre><code># Set Kotlin language version and opt-ins\nsettings:\n  kotlin:\n    languageVersion: 1.8\n    optIns: [ kotlin.io.path.ExperimentalPathApi ]\n</code></pre> <pre><code># Enable Kotlin Serialization with the JSON format\nsettings:\n  kotlin:\n    serialization: json\n</code></pre> <pre><code># Enable Kotlin Serialization with the JSON format and a specific version \nsettings:\n  kotlin:\n    serialization: \n      format: json\n      version: 1.9.0\n</code></pre> <pre><code># Enable Kotlin Serialization with multiple formats\nsettings:\n  kotlin:\n    serialization: enabled\n\ndependencies:\n  - $kotlin.serialization.json\n  - $kotlin.serialization.protobuf\n</code></pre> <pre><code># Enable Kotlin Serialization with multiple formats and a specific version \nsettings:\n  kotlin:\n    serialization: \n      enabled: true\n      version: 1.9.0\n\ndependencies:\n  - $kotlin.serialization.json\n  - $kotlin.serialization.protobuf\n</code></pre>"},{"location":"reference/module/#settingskotlinallopen","title":"<code>settings.kotlin.allOpen</code>","text":"<p><code>settings.kotlin.allOpen</code> configures the Kotlin all-open compiler plugin, which makes classes annotated with specific annotations open automatically without the explicit <code>open</code> keyword.</p> Attribute Description Default <code>enabled: boolean</code> Enable the Kotlin all-open compiler plugin <code>false</code> <code>annotations: string list</code> List of annotations that trigger open class/method generation (empty) <code>presets: enum list</code> Predefined sets of annotations for common frameworks (available presets: <code>spring</code>, <code>micronaut</code>, and <code>quarkus</code>) (empty) <p>Examples:</p> All-open with custom annotations<pre><code>settings:\n  kotlin:\n    allOpen:\n      enabled: true\n      annotations: [ com.example.MyOpen, com.example.MyFramework.Open ]\n</code></pre> All-open with Spring preset<pre><code>settings:\n  kotlin:\n    allOpen:\n      enabled: true\n      presets: [ spring ]\n</code></pre>"},{"location":"reference/module/#settingskotlinnoarg","title":"<code>settings.kotlin.noArg</code>","text":"<p><code>settings.kotlin.noArg</code> configures the Kotlin no-arg compiler plugin, which generates no-arg constructors for classes with specific annotations.</p> Attribute Description Default <code>enabled: boolean</code> Enable the Kotlin no-arg compiler plugin <code>false</code> <code>annotations: string list</code> List of annotations that trigger no-arg constructor generation (empty) <code>invokeInitializers: boolean</code> Whether to call initializers in the synthesized constructor <code>false</code> <code>presets: enum list</code> Predefined sets of annotations (currently only <code>jpa</code> preset for JPA entity annotations) (empty) <p>Examples:</p> No-arg with JPA preset<pre><code># Enable no-arg for JPA entities\nsettings:\n  kotlin:\n    noArg:\n      enabled: true\n      presets: [ jpa ]\n</code></pre> No-arg with custom annotations<pre><code>settings:\n  kotlin:\n    noArg:\n      enabled: true\n      annotations: [ com.example.NoArg ]\n      invokeInitializers: true\n</code></pre>"},{"location":"reference/module/#settingsktor","title":"<code>settings.ktor</code>","text":"<p><code>settings.ktor</code> configures the Ktor.</p> Attribute Description Default <code>enabled: boolean</code> Enable Ktor <code>false</code> <code>version: string</code> Ktor version <code>3.2.3</code> <code>applyBom: boolean</code> Whether to apply the Ktor BOM <code>true</code> <p>Example:</p> <pre><code>settings:\n  ktor:\n    enabled: true\n    version: 2.3.2 # version customization\n</code></pre>"},{"location":"reference/module/#settingslombok","title":"<code>settings.lombok</code>","text":"<p><code>settings.lombok</code> configures Lombok.</p> Attribute Description Default <code>enabled: boolean</code> Enable Lombok <code>false</code> <code>version: string</code> Lombok version for runtime and annotation processor <code>1.18.38</code> <p>Example:</p> <pre><code>settings:\n  lombok:\n    enabled: true\n</code></pre>"},{"location":"reference/module/#settingsnative","title":"<code>settings.native</code>","text":"<p><code>settings.native</code> configures settings specific to native applications.</p> Attribute Description Default <code>entryPoint: string</code> The fully-qualified name of the application's entry point function <code>null</code> <p>Example:</p> <pre><code># Configure native settings for the module\nsettings:\n  native:\n    entryPoint: com.example.MainKt.main\n</code></pre>"},{"location":"reference/module/#settingsspringboot","title":"<code>settings.springBoot</code>","text":"<p><code>settings.springBoot</code> configures the Spring Boot framework (JVM platform only).</p> Attribute Description Default <code>enabled: boolean</code> Enable Spring Boot <code>false</code> <code>version: string</code> Spring Boot version <code>3.5.5</code> <code>applyBom: boolean</code> Whether to apply the Spring Boot BOM <code>true</code> <p>Example:</p> <pre><code>settings:\n  springBoot:\n    enabled: true\n    version: 3.1.0 # version customization\n</code></pre>"},{"location":"reference/module/#plugininfo","title":"<code>pluginInfo</code>","text":"<p><code>pluginInfo:</code> is only available if the <code>product.type</code> is <code>jvm/amper-plugin</code>. It configures plugin-specific build settings.</p> Attribute Description Default <code>id: string</code> Plugin id that is going to be used to refer to the plugin in the configuration files. Module name <code>description: string</code> Plugin description. Can be used by tooling to provide documentation on plugin references in configuration files. <code>null</code> <code>settingsClass: string</code> Fully qualified name of the @Configurable-annotated interface to be used as plugin configuration. This interface can't come from a dependency, it must be declared in the source directory. <code>null</code>"},{"location":"reference/project/","title":"Project file reference","text":""},{"location":"reference/project/#modules","title":"<code>modules</code>","text":"<p>The <code>modules:</code> section lists all the modules in the project, except the root module. If a <code>module.yaml</code> is present at the root of the project, the root module is implicitly included and doesn't need to be listed.</p> <p>Each element in the list must be the path to a module directory, relative to the project root. A module directory must contain a <code>module.yaml</code> file.</p> <p>Example:</p> <pre><code># include the `app` and `lib1` modules explicitly:\nmodules:\n  - ./app\n  - ./libs/lib1\n</code></pre> <p>You can also use Glob patterns to include multiple module directories at the same time. Only directories that contain a <code>module.yaml</code> file will be considered when matching a glob pattern.</p> <ul> <li><code>*</code> matches zero or more characters of a path name component without crossing directory boundaries</li> <li><code>?</code> matches exactly one character of a path name component</li> <li><code>[abc]</code> matches exactly one character of the given set (here <code>a</code>, <code>b</code>, or <code>c</code>). A dash (<code>-</code>) can be used to match a range, such as <code>[a-z]</code>.</li> </ul> <p>Using <code>**</code> to recursively match directories at multiple depth levels is not supported.</p> <p>Example:</p> <pre><code># include all direct subfolders in the `plugins` dir that contain `module.yaml` files:\nmodules:\n  - ./plugins/*\n</code></pre>"},{"location":"reference/project/#plugins","title":"<code>plugins</code>","text":"<p><code>plugins:</code> section lists all the plugins that are available in the project. The list of plugin dependencies to make available in the project modules.</p> <p>Example: <pre><code>plugins:\n  - ./my-plugin\n  - ./plugins/my-another-plugin\n</code></pre></p> <p>Info</p> <p>Currently, only dependencies on local plugin modules are supported here, as there are no published Amper plugins, and it's not possible to publish them yet. So, the elements of this list use the same format as module dependencies.</p> <p>Listing the plugins here does not enable them yet. Each plugin from this list can then be enabled and configured on a per-module basis.</p> <p>Learn more about the plugin structure.</p>"},{"location":"user-guide/","title":"User guide","text":"<p>This is the comprehensive documentation of Amper. Here, you can learn everything about Amper concepts and built-in support for some popular technologies.</p> <p>Not sure where to start?</p> <p>The sections are organized in a logical order, so if you're not sure how to proceed, you can use the  \"Next \" button at the bottom of the pages to go with the flow.</p> <p>For a more hands-on experience, check out the Getting started guide.</p>"},{"location":"user-guide/basics/","title":"Basic concepts","text":""},{"location":"user-guide/basics/#project-and-modules","title":"Project and modules","text":"<p>An Amper project is defined by a <code>project.yaml</code> file. This file contains the list of modules and the project-wide configuration. The folder with the <code>project.yaml</code> file is the project root. Modules can only be located under the  project root (at any depth). If there is only one module in the project, the <code>project.yaml</code> file is not required.</p> <p>An Amper module is a directory with a <code>module.yaml</code> configuration file, and optionally sources and resources. A module configuration file describes what to produce: e.g. a reusable library or a platform-specific application. Each module describes a single product. Several modules can't share the same sources or resources, but they can depend  on each other. How to produce the desired product, that is, the build rules, is the responsibility of the Amper build engine.</p> <p>If you are not familiar with YAML, see our brief YAML primer.</p>"},{"location":"user-guide/basics/#project-layout","title":"Project layout","text":""},{"location":"user-guide/basics/#single-module-project","title":"Single-module project","text":"<p>A single-module Amper project doesn't need a <code>project.yaml</code> file. Just create a single valid module, and it is also a valid project<sup>1</sup>:</p> Single-module project layout<pre><code>my-project/ #(1)!\n\u251c\u2500 src/\n\u2502  \u251c\u2500 main.kt\n\u251c\u2500 test/\n\u2502  \u2570\u2500 MainTest.kt\n\u2570\u2500 module.yaml\n</code></pre> <ol> <li>This is the project root but also the root of the only module in the project.</li> </ol> <p>See the Module layout section for more details about the module structure itself. </p>"},{"location":"user-guide/basics/#multi-module-project","title":"Multi-module project","text":"<p>If there are multiple modules, the <code>project.yaml</code> file specifies the list of modules:</p> Multi-module project layout<pre><code>\u251c\u2500 app/\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u251c\u2500 main.kt\n\u2502  \u2502  \u2570\u2500 ...\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 libs/ #(1)!\n\u2502  \u251c\u2500 lib1/\n\u2502  \u2502  \u251c\u2500 src/\n\u2502  \u2502  \u2502  \u2570\u2500 myLib1.kt\n\u2502  \u2502  \u2570\u2500 module.yaml\n\u2502  \u2570\u2500 lib2/\n\u2502     \u251c\u2500 src/\n\u2502     \u2502  \u2570\u2500 myLib2.kt\n\u2502     \u2570\u2500 module.yaml\n\u2570\u2500 project.yaml\n</code></pre> <ol> <li>This hierarchy is arbitrary, it can be organized however you like. The structure is understood by Amper based on       the list of module paths in <code>project.yaml</code> \u2014 there is no convention for multi-module projects.</li> </ol> project.yaml<pre><code>modules:\n  - ./app\n  - ./libs/lib1 #(1)!\n  - ./libs/lib2\n</code></pre> app/module.yaml<pre><code>product: jvm/app\n\ndependencies:\n  - ./libs/lib1\n  - ./libs/lib2\n</code></pre> <ol> <li>It is also possible to use globs to list multiple modules at once (e.g., <code>./libs/*</code>), although we encourage       listing them explicitly. See details in the project file reference.</li> </ol> <p>See the Module layout section for more details about what goes inside each module directory.</p> Multi-module project with root module <p>It is also possible to have a root module even if there are multiple modules in the project, although this is  generally discouraged.</p> <pre><code>\u251c\u2500 lib/\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u2570\u2500 util.kt\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 src/  # src of the root module\n\u2502  \u251c\u2500 main.kt\n\u2502  \u2570\u2500 ...\n\u251c\u2500 module.yaml  # the module file of the root module\n\u2570\u2500 project.yaml\n</code></pre> project.yaml<pre><code>modules:  # The root module is included implicitly\n  - ./lib\n</code></pre>"},{"location":"user-guide/basics/#module-layout","title":"Module layout","text":"<p>Here are typical module structures at a glance:</p>  JVM  Kotlin Multiplatform Android app iOS app <pre><code>my-module/\n\u251c\u2500 resources/ # (1)!\n\u2502  \u2570\u2500 logback.xml # (2)!\n\u251c\u2500 src/\n\u2502  \u251c\u2500 main.kt\n\u2502  \u2570\u2500 Util.java # (3)!\n\u251c\u2500 test/\n\u2502  \u2570\u2500 MainTest.java # (4)!\n\u2502  \u2570\u2500 UtilTest.kt\n\u251c\u2500 testResources/\n\u2502  \u2570\u2500 logback-test.xml # (5)!\n\u2570\u2500 module.yaml\n</code></pre> <ol> <li>Resources placed here are copied into the resulting jar.</li> <li>This is just an example resource and can be omitted.</li> <li>You can mix Kotlin and Java source files in a single module, all in the <code>src</code> folder.</li> <li>You can test Java code with Kotlin tests or Kotlin code with Java tests.</li> <li>This is just an example resource and can be omitted.</li> </ol> <p>Maven compatibility layout for JVM-only modules</p> <p>If you're migrating from Maven, you can also configure the Maven-like layout</p> <pre><code>my-module/\n\u251c\u2500 resources/       # common resources, used in all targets\n\u251c\u2500 resources@ios/   # resources that are only available to the iOS code\n\u251c\u2500 resources@jvm/   # resources that are only available to the JVM code\n\u251c\u2500 src/             # common code, compiled for all targets\n\u2502  \u251c\u2500 main.kt\n\u2502  \u2570\u2500 util.kt # (1)!\n\u251c\u2500 src@native/      # code to be compiled for all native targets\n\u251c\u2500 src@apple/       # code to be compiled for all Apple targets\n\u251c\u2500 src@ios/         # code to be compiled only for iOS targets\n\u2502  \u2570\u2500 util.kt # (2)!\n\u251c\u2500 src@jvm/         # code to be compiled only for JVM targets\n\u2502  \u251c\u2500 util.kt\n\u2502  \u2570\u2500 MyClass.java # (3)!\n\u251c\u2500 test/            # common tests, compiled for all targets\n\u2502  \u2570\u2500 MainTest.kt   \n\u251c\u2500 test@ios/        # tests that are only run on iOS simulator\n\u2502  \u2570\u2500 SomeIosTest.kt\n\u251c\u2500 test@jvm/        # tests that are only run on JVM\n\u2502  \u2570\u2500 SomeJvmTest.kt\n\u251c\u2500 testResources/       # common test resources, used in all targets\n\u251c\u2500 testResources@ios/   # test resources that are only available to the iOS code\n\u251c\u2500 testResources@jvm/   # test resources that are only available to the JVM code\n\u2570\u2500 module.yaml\n</code></pre> <ol> <li>This file may define <code>expect</code> declarations to be implemented differently on different platforms.</li> <li>This file defines the <code>actual</code> implementations corresponding to the <code>expect</code> declarations from <code>src</code>.</li> <li>It's ok to have Java sources in JVM-only source directories.</li> </ol> <p>Read more in the dedicated Multiplatform modules section.</p> <pre><code>my-android-app/\n\u251c\u2500 assets/ # (1)!\n\u251c\u2500 res/ # (2)!\n\u2502  \u251c\u2500 drawable/\n\u2502  \u2502  \u2570\u2500 graphic.png\n\u2502  \u251c\u2500 layout/\n\u2502  \u2502  \u251c\u2500 main.xml\n\u2502  \u2502  \u2570\u2500 info.xml\n\u2502  \u2570\u2500 ...\n\u251c\u2500 resources/\n\u251c\u2500 src/\n\u2502  \u251c\u2500 AndroidManifest.xml # (3)!\n\u2502  \u2570\u2500 MainActivity.kt # (4)!\n\u251c\u2500 test/\n\u2502  \u2570\u2500 MainTest.kt\n\u251c\u2500 module.yaml\n\u2570\u2500 proguard-rules.pro # (5)!\n</code></pre> <ol> <li><code>assets</code> and <code>res</code> are standard Android resource directories. See the official Android docs.</li> <li><code>assets</code> and <code>res</code> are standard Android resource directories. See the official Android docs.</li> <li>The manifest file of your application.</li> <li>An activity (screen) of your application.</li> <li>Optional configuration for R8 code shrinking and obfuscation. See code shrinking.</li> </ol> <p>Read more in the dedicated Android section.</p> <pre><code>my-ios-app/\n\u251c\u2500 src/\n\u2502  \u251c\u2500 KotlinCode.kt # (1)!\n\u2502  \u251c\u2500 EntryPoint.swift # (2)!\n\u2502  \u2570\u2500 Info.plist\n\u251c\u2500 module.yaml\n\u2570\u2500 module.xcodeproj # (3)!\n</code></pre> <ol> <li>Kotlin code is optional. Everything could come from dependencies.</li> <li>The entrypoint of iOS apps must be a <code>@main</code> struct in a Swift file.    Read more</li> <li>An Xcode project is required but it can be automatically generated by Amper the first time.    Read more</li> </ol> <p>Read more in the dedicated iOS section.</p> <p>All sources and resources are optional: only the <code>module.yaml</code> file is required. For example, your module could get all its code from dependencies and have no <code>src</code> folder.</p> <p>Sources and resources can't be defined as part of multiple modules \u2014 they must belong to a single module, which other  modules can depend on. This ensures that the IDE always knows how to analyze and refactor the code, as it always has a  single well-defined set of settings and dependencies.</p>"},{"location":"user-guide/basics/#module-file-anatomy","title":"Module file anatomy","text":"<p>A <code>module.yaml</code> file has several main sections: <code>product</code>, <code>dependencies</code> and <code>settings</code>.</p> <p>A module can produce a single product, such as a reusable library or an application. Read more on the supported product types below.</p> <p>Here are some example module files for different types of modules:</p>  JVM application KMP library <pre><code>product: jvm/app #(1)!\n\ndependencies:\n  - io.ktor:ktor-client-java:2.3.0 #(2)!\n\nsettings: #(3)!\n  kotlin:\n    version: 2.2.21 #(4)!\n    allWarningsAsErrors: true #(5)!\n</code></pre> <ol> <li>This short form is equivalent to:    <pre><code> product:\n   type: jvm/app\n</code></pre>    The <code>jvm/app</code> product type means that the module produces a JVM application.</li> <li>The <code>dependencies</code> section contains the list of dependencies for this module.     Here <code>io.ktor:ktor-client-core:2.3.0</code> are the     Maven coordinates  of     the Ktor client library (with Java engine).    Read more about dependencies in general in the Dependencies section.</li> <li>The <code>settings</code> section contains the configuration of different toolchains. </li> <li>An example setting: the Kotlin compiler version used for this module.</li> <li>An example setting: a compiler setting to consider warnings as errors and fail the build on any warning.</li> </ol> <pre><code>product:\n  type: lib #(1)!\n  platforms: [android, iosArm64, iosSimulatorArm64] #(2)!\n\ndependencies:\n  - io.ktor:ktor-client-core:2.3.0 #(3)!\n\ndependencies@android:\n  - io.ktor:ktor-client-android:2.3.0 #(4)!\n\ndependencies@ios:\n  - io.ktor:ktor-client-darwin:2.3.0 #(5)!\n\nsettings: #(6)!\n  kotlin:\n    version: 2.2.21 #(7)!\n    allWarningsAsErrors: true #(8)!\n\nsettings@ios: #(9)!\n  kotlin:\n    allWarningsAsErrors: false #(10)!\n</code></pre> <ol> <li>The <code>lib</code> product type means that the module produces a   Kotlin Multiplatform     library.</li> <li>The <code>platforms</code> list contains the platforms that this module is built for.</li> <li>The <code>dependencies</code> section contains the list of common dependencies for this module.     Here <code>io.ktor:ktor-client-core:2.3.0</code> are the     Maven coordinates  of     the Ktor client core library.    Read more about dependencies in general in the Dependencies section.    Read more about multiplatform dependencies in the Multiplatform dependencies section.</li> <li>The <code>dependencies@android</code> section contains the list of dependencies that are only used when building the module     for the Android target.     Here the <code>io.ktor:ktor-client-android:2.3.0</code> will not be present when building the module for the iOS targets.    Read more about dependencies in general in the Dependencies section.    Read more about multiplatform dependencies in the Multiplatform dependencies section.</li> <li>The <code>dependencies@ios</code> section contains the list of dependencies that are only used when building the module     for the iOS target.     Here the <code>io.ktor:ktor-client-darwin:2.3.0</code> will not be present when building the module for the Android target.    Read more about dependencies in general in the Dependencies section.    Read more about multiplatform dependencies in the Multiplatform dependencies section.</li> <li>The <code>settings</code> section contains the configuration of different toolchains for common code, and also serves as     default for platform-specific code.. </li> <li>An example setting: the Kotlin compiler version used for this module.</li> <li>An example setting: a compiler setting to consider warnings as errors and fail the build on any warning.</li> <li>The <code>settings@ios</code> section contains the configuration of different toolchains for iOS-specific compilation.</li> <li>This setting overrides the one that we set in the <code>settings</code> section.     Read more about this in the settings propagation section.</li> </ol>"},{"location":"user-guide/basics/#product-types","title":"Product types","text":"<p>Product type describes the target platform and the type of the project at the same time. Below is the list of supported product types:</p> <ul> <li><code>lib</code> - a reusable Kotlin Multiplatform library which can be used as a dependency by other modules in the Amper project</li> <li><code>jvm/lib</code> - a reusable JVM library which can be used as a dependency by other modules in the Amper project</li> <li><code>jvm/app</code> - a JVM console or desktop application</li> <li><code>windows/app</code> - a mingw64 application</li> <li><code>linux/app</code> - a native Linux application</li> <li><code>macos/app</code> - a native macOS application</li> <li><code>android/app</code> - an Android application</li> <li><code>ios/app</code> - an iOS application</li> </ul>"},{"location":"user-guide/basics/#dependencies","title":"Dependencies","text":"<p>The <code>dependencies</code> section contains the list of dependencies for this module. They can be external maven libraries, other modules in the project, and more.</p> <p>Please see the Dependencies section for more details.</p>"},{"location":"user-guide/basics/#settings","title":"Settings","text":"<p>The <code>settings</code> section contains toolchains settings. A toolchain is an SDK (Kotlin, Java, Android, iOS) or a simpler tool (linter, code generator).</p> <p>All toolchain settings are specified in dedicated groups in the <code>settings</code> section: <pre><code>settings:\n  kotlin:\n    languageVersion: 1.8\n  android:\n    compileSdk: 31\n</code></pre></p> <p>Check out the Reference page for the full list of supported settings.</p> <p>See the multiplatform section for more details about how multiple settings sections interact in multiplatform modules.</p>"},{"location":"user-guide/basics/#configuring-entry-points","title":"Configuring entry points","text":""},{"location":"user-guide/basics/#jvm","title":"JVM","text":"<p>By default, the entry point of JVM applications (the <code>main</code> function) is expected to be in a <code>main.kt</code> file (case-insensitive) in the <code>src</code> folder.</p> <p>This can be overridden by specifying a main class explicitly in the module settings: <pre><code>product: jvm/app\n\nsettings:\n  jvm:\n    mainClass: org.example.myapp.MyMainKt\n</code></pre></p> <p>Note</p> <p>In Kotlin, unlike Java, the <code>main</code> function doesn't have to be declared in a class, and is usually at the top level of the file. However, the JVM still expects a main class when running any application. Kotlin always compiles  top-level declarations to a class, and the name of that class is derived from the name of the file by capitalizing  the name and turning the <code>.kt</code> extension into a <code>Kt</code> suffix.</p> <p>For example, the top-level declarations of <code>myMain.kt</code> will be in a class named <code>MyMainKt</code>.</p>"},{"location":"user-guide/basics/#native","title":"Native","text":"<p>By default, the entry point of Kotlin native applications (the <code>main</code> function) is expected to be in a <code>main.kt</code> file (case-insensitive) in the <code>src</code> folder.</p> <p>This can be overridden by specifying the fully qualified name of the <code>main</code> function explicitly in the module settings:</p> <pre><code>product: linux/app\n\nsettings:\n  native:\n    entryPoint: org.example.myapp.main\n</code></pre>"},{"location":"user-guide/basics/#android","title":"Android","text":"<p>Android apps have their own way to configure the entry point, see the  dedicated Android section.</p>"},{"location":"user-guide/basics/#ios","title":"iOS","text":"<p>iOS apps have their own way to configure the entry point, see the dedicated iOS section.</p>"},{"location":"user-guide/basics/#packaging","title":"Packaging","text":"<p>Amper provides a <code>package</code> command to build a project for distribution.</p> <p>For <code>jvm/app</code> modules it produces executable jars which follow  The Executable Jar Format. The executable JAR format, while commonly associated with Spring applications, is a universal packaging solution suitable for any JVM application. This format provides a convenient, runnable self-contained deployment unit that includes all necessary dependencies, but unlike the \"fat jar\" approach, it doesn't suffer from the problems of handling duplicate files.</p> <p>For <code>android/app</code> modules, see the dedicated Android packaging section.</p> <ol> <li> <p>As long as it is not included in a <code>project.yaml</code> higher in the directory tree.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/dependencies/","title":"Dependencies","text":"<p>Dependencies are pieces of code (e.g., libraries or other modules) that your module depends on.</p>"},{"location":"user-guide/dependencies/#declaring-dependencies","title":"Declaring dependencies","text":"<p>Dependencies are declared in the <code>dependencies</code> list of the <code>module.yaml</code> file:</p> <pre><code>dependencies:\n  - ./my-other-module #(1)!\n  - org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.1 #(2)!\n  - $libs.apache.commons.lang3 #(3)!\n  - $kotlin.reflect #(4)!\n</code></pre> <ol> <li>Dependency on another module of the project (see Module dependencies).</li> <li>Dependency on an external Maven library, with the provided coordinates (see External Maven dependencies).</li> <li>Dependency on a library from the project's Library Catalog.</li> <li>Dependency on a library from a built-in Library Catalog    (in this case, the catalog brought by the Kotlin \"toolchain\").</li> </ol>"},{"location":"user-guide/dependencies/#module-dependencies","title":"Module dependencies","text":"<p>To depend on another module of your project, use the path to that module, relative to the current module's root directory. The path must start either with <code>./</code> or <code>../</code>.</p> <p>For example, here the <code>app</code> module declares a dependency on the <code>nested-lib</code> and <code>ui/utils</code> modules:</p> app/module.yaml<pre><code>product: jvm/app\n\ndependencies:\n- ./nested-lib\n- ../ui/utils\n</code></pre> project.yaml<pre><code>modules:\n  - app\n  - app/nested-lib\n  - ui/utils\n</code></pre> Project structure<pre><code>root/\n\u251c\u2500 app/\n\u2502  \u251c\u2500 nested-lib/\n\u2502  \u2502  \u251c\u2500 src/\n\u2502  \u2502  \u2570\u2500 module.yaml\n\u2502  \u251c\u2500 src/\n\u2502  \u2570\u2500 module.yaml\n\u251c\u2500 ui/\n\u2502  \u2570\u2500 utils/\n\u2502     \u251c\u2500 src/\n\u2502     \u2570\u2500 module.yaml\n\u2570\u2500 project.yaml\n\u200e \n</code></pre> <p>Note</p> <p>Dependencies between modules are only allowed within the project scope. That is, they must be listed in the <code>project.yaml</code> file and cannot be outside the project root directory.</p>"},{"location":"user-guide/dependencies/#external-maven-dependencies","title":"External Maven dependencies","text":"<p>Maven dependencies can be added via their coordinates<sup>1</sup> in the usual <code>group:artifact:version</code> notation:</p> <pre><code>dependencies:\n  - org.jetbrains.kotlin:kotlin-serialization:1.8.0\n  - io.ktor:ktor-client-core:2.2.0\n</code></pre> <p>Maven dependencies are fetched from a Maven repository<sup>2</sup> before being cached locally. Default repositories are provided out of the box, so you don't have to configure anything. If you need to customize the repositories, see Managing Maven repositories.</p>"},{"location":"user-guide/dependencies/#catalog-dependencies","title":"Catalog dependencies","text":"<p>See Library Catalogs.</p>"},{"location":"user-guide/dependencies/#transitivity-and-scope","title":"Transitivity and scope","text":""},{"location":"user-guide/dependencies/#scope","title":"Scope","text":"<p>The scope of a dependency defines whether it is available during compilation (compile classpath) and/or  available at runtime (runtime classpath):</p> Scope Compilation Runtime <code>all</code> (default) <code>compile-only</code> <code>runtime-only</code> <p>By default, the scope is <code>all</code>. You can restrict a dependency's scope as follows:</p> Short formLong form <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0: compile-only  \n  - ../ui/utils: runtime-only\n</code></pre> <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0:\n      scope: compile-only \n  - ../ui/utils:\n      scope: runtime-only \n</code></pre> <p>Note</p> <p>The long form is necessary when you also need to mark the dependency as <code>exported</code>:</p> <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0:\n      exported: true\n      scope: compile-only\n</code></pre>"},{"location":"user-guide/dependencies/#transitivity","title":"Transitivity","text":"<p>By default, dependencies of your module are not added to the compilation of dependent modules. In the following setup, <code>app</code> cannot directly use Ktor classes in its code:</p> lib/module.yaml<pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0\n</code></pre> app/module.yaml<pre><code>dependencies:\n  - ../lib #(1)! \n</code></pre> <ol> <li>The <code>../lib</code> dependency is added to the compilation and runtime of the <code>app</code> module (scope <code>all</code> by default). It    brings the transitive dependency on <code>ktor-client-core</code> at runtime, but doesn't expose it at compile time.</li> </ol> <p>To make a dependency accessible to all dependent modules during their compilation, you need to explicitly mark it as  <code>exported</code> (this is equivalent to declaring a dependency using the <code>api()</code> configuration in Gradle).</p> Short formLong form <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0: exported\n  - ../ui/utils: exported\n</code></pre> <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0:\n      exported: true \n  - ../ui/utils:\n      exported: true \n</code></pre> <p>Note</p> <p>The long form is necessary when you also need to customize the scope</p> <pre><code>dependencies:\n  - io.ktor:ktor-client-core:2.2.0:\n      exported: true\n      scope: compile-only\n</code></pre> <code>exported</code> is like a scope for transitive consumers <p>We can see <code>exported</code> as a way to modify the scope of a transitive dependency in the context of the consuming  module. For example, say <code>app</code> depends on <code>lib</code>, which depends on <code>ktor</code>. The <code>ktor</code> dependency is transitively  part of the dependencies of <code>app</code>.</p> <ul> <li>If <code>lib</code> doesn't export <code>ktor</code>, the <code>ktor</code> dependency effectively has a <code>scope: runtime-only</code> in <code>app</code></li> <li>If <code>lib</code> marks <code>ktor</code> as <code>exported</code>, the <code>ktor</code> dependency effectively has a <code>scope: all</code> in <code>app</code></li> </ul>"},{"location":"user-guide/dependencies/#when-to-use-exported","title":"When to use <code>exported</code>","text":"<p>Ideally, you should use <code>exported</code> dependencies as little as possible. The rule of thumb is that, if your module uses some types from the dependency in its public API, you should mark it as <code>exported</code>. If not, you should probably avoid it.</p> <p>For example, if you depend on <code>ktor-client-core</code> in your module, and you have the following class:</p> <pre><code>class MyApi(private val client: HttpClient) {\n    // ...\n}\n</code></pre> <p>The <code>HttpClient</code> type is used in your public constructor, so your consumers will need to see it at compile time. You should therefore mark <code>ktor-client-core</code> as <code>exported</code>.</p>"},{"location":"user-guide/dependencies/#library-catalogs","title":"Library Catalogs","text":"<p>A library catalog associates keys to library coordinates (including the version), and allows adding the same libraries as dependencies to multiple modules without having to repeat the coordinates or the versions of the libraries.</p> <p>Amper currently supports the following library catalogs:</p> <ul> <li>one project catalog (user-defined)</li> <li>several toolchain catalogs (a.k.a built-in catalogs, such as Kotlin or Compose Multiplatform)</li> </ul>"},{"location":"user-guide/dependencies/#project-catalog","title":"Project catalog","text":"<p>The project catalog is the user-defined catalog for the project.</p> <p>It is defined in a file named <code>libs.versions.toml</code>, and is written in the TOML format<sup>3</sup> of Gradle version catalogs. It can be located at the root of the project or at <code>gradle/libs.versions.toml</code> (the default from Gradle, to ease  migration).</p> <p>You can only have one project catalog</p> <p>You have to choose between <code>libs.versions.toml</code> and <code>gradle/libs.versions.toml</code>\", but cannot use both at the same  time.</p> <p>To use dependencies from the project catalog, use the syntax <code>$libs.&lt;key&gt;</code> instead of the coordinates, where <code>$libs</code> is the catalog name of the project catalog, and <code>&lt;key&gt;</code> is defined according to the Gradle name mapping rules.</p> <p>Example:</p> libs.versions.toml<pre><code>[versions]\nktor = \"3.3.2\"\n\n[libraries]\nktor-client-auth = { module = \"io.ktor:ktor-client-auth\", version.ref = \"ktor\" }\nktor-client-cio = { module = \"io.ktor:ktor-client-cio\", version.ref = \"ktor\" }\nktor-client-contentNegotiation = { module = \"io.ktor:ktor-client-content-negotiation\", version.ref = \"ktor\" }\n</code></pre> app/module.yaml<pre><code>dependencies:\n  - $libs.ktor.client.auth\n  - $libs.ktor.client.cio\n  - $libs.ktor.client.contentNegotiation\n</code></pre>"},{"location":"user-guide/dependencies/#toolchain-catalogs","title":"Toolchain catalogs","text":"<p>The toolchain catalogs are implicitly defined, and contain libraries that relate to the corresponding toolchain. The name of such a catalog corresponds to the name of the toolchain in the settings section. All dependencies in such catalogs usually have the same version, which is the toolchain version.</p> <p>For example, dependencies for the Compose Multiplatform framework are accessible using the <code>$compose</code> catalog name, and take their versions from the <code>settings.compose.version</code> setting.</p> <p>To use dependencies from toolchain catalogs, use the syntax <code>$&lt;catalog-name&gt;.&lt;key&gt;</code> instead of the coordinates, for example: <pre><code>dependencies:\n  - $kotlin.reflect      # dependency from the Kotlin catalog\n  - $compose.material3   # dependency from the Compose Multiplatform catalog\n</code></pre></p> <p>Catalog dependencies can still have a scope and visibility even when coming from a catalog:</p> <pre><code>dependencies:\n  - $compose.foundation: exported\n  - $my-catalog.db-engine: runtime-only \n</code></pre>"},{"location":"user-guide/dependencies/#managing-maven-repositories","title":"Managing Maven repositories","text":"<p>By default, Maven Central and Google Android repositories are pre-configured. To add extra repositories, use the following options:</p> module.yaml<pre><code>repositories:\n  - https://repo.spring.io/ui/native/release\n  - url: https://dl.google.com/dl/android/maven2/\n  - id: jitpack\n    url: https://jitpack.io\n</code></pre> <p>For private repositories, you can configure credentials this way:</p> module.yaml<pre><code>repositories:\n  - url: https://repo.company.com\n    credentials:\n      file: ../local.properties # (1)!\n      usernameKey: my.username\n      passwordKey: my.password\n</code></pre> <ol> <li>The relative path to a <code>.properties</code> file containing the repository's credentials</li> </ol> local.properties<pre><code>my.username=joffrey.bion\nmy.password=YouWishYouKnewIt\n</code></pre> <p>Note</p> <p>Currently only <code>*.properties</code> files with credentials are supported.</p>"},{"location":"user-guide/dependencies/#using-a-maven-bom","title":"Using a Maven BOM","text":"<p>To import a BOM, specify its coordinates prefixed by <code>bom:</code></p> <pre><code>dependencies:\n  - bom: io.ktor:ktor-bom:2.2.0\n  - io.ktor:ktor-client-core \n</code></pre> <p>The effects are the following:</p> <ul> <li>Maven dependencies that are listed in the BOM no longer need a version (e.g., <code>io.ktor:ktor-client-core</code>).   The version from the BOM is used in this case.</li> <li>Dependency versions declared in the BOM participate in version conflict resolution.</li> </ul> <p>This also applies to catalog dependencies!</p> <p>If a dependency in the library catalog is only used in modules that  declare a BOM that provides a version for it, then the version can be omitted there:</p> <p> libs.versions.toml<pre><code>[libraries]\nktor-client-core = \"io.ktor:ktor-client-core\"\n</code></pre> module.yaml<pre><code>dependencies:\n  - bom: io.ktor:ktor-bom:3.2.0\n  - $libs.ktor.client.core\n</code></pre> </p> <ol> <li> <p>If you're not familiar with Maven coordinates, check out Maven's  POM reference .\u00a0\u21a9</p> </li> <li> <p>If you're not familiar with Maven repositories, check out Maven's Introduction to repositories .\u00a0\u21a9</p> </li> <li> <p>Only <code>[versions]</code> and <code>[libraries]</code> sections are supported from the Gradle format, not <code>[bundles]</code> and <code>[plugins]</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/multiplatform/","title":"Multiplatform modules","text":"<p>Amper was built from the start with Kotlin Multiplatform in mind. Kotlin Multiplatform is a technology that allows building a single module for different target platforms.</p>"},{"location":"user-guide/multiplatform/#supported-platforms","title":"Supported platforms","text":"<p>In the diagram below, you'll find all supported platforms. Some target platforms belong to the same family and share some common APIs.</p> <p>The following diagram shows the hierarchy between all platform families (intermediate nodes) and platforms (leaf nodes):</p> Defaut platforms hierarchy<pre><code>common\n \u251c\u2500 jvm\n \u251c\u2500 android\n \u251c\u2500 web\n \u2502   \u251c\u2500 js\n \u2502   \u2570\u2500 wasmJs\n \u251c\u2500 wasmWasi\n \u2570\u2500 native\n     \u251c\u2500 linux\n     \u2502   \u251c\u2500 linuxX64\n     \u2502   \u2570\u2500 linuxArm64\n     \u251c\u2500 mingw\n     \u2502   \u2570\u2500 mingwX64\n     \u251c\u2500 apple\n     \u2502   \u251c\u2500 macos\n     \u2502   \u2502   \u251c\u2500 macosX64\n     \u2502   \u2502   \u2570\u2500 macosArm64\n     \u2502   \u251c\u2500 ios\n     \u2502   \u2502   \u251c\u2500 iosArm64\n     \u2502   \u2502   \u251c\u2500 iosSimulatorArm64\n     \u2502   \u2502   \u2570\u2500 iosX64\n     \u2502   \u251c\u2500 watchos\n     \u2502   \u2502   \u251c\u2500 watchosArm32\n     \u2502   \u2502   \u251c\u2500 watchosArm64\n     \u2502   \u2502   \u251c\u2500 watchosDeviceArm64\n     \u2502   \u2502   \u2570\u2500 watchosSimulatorArm64\n     \u2502   \u2570\u2500 tvos\n     \u2502       \u251c\u2500 tvosArm64\n     \u2502       \u251c\u2500 tvosSimulatorArm64\n     \u2502       \u2570\u2500 tvosX64\n     \u2570\u2500 androidNative\n         \u251c\u2500 androidNativeArm32\n         \u251c\u2500 androidNativeArm64\n         \u251c\u2500 androidNativeX64\n         \u2570\u2500 androidNativeX86\n</code></pre> <p>The platforms listed here are not all equally supported or tested.</p>"},{"location":"user-guide/multiplatform/#choosing-target-platforms","title":"Choosing target platforms","text":"<p>Not all multiplatform modules support all target platforms. Most modules define a limited subset of the target platforms. To do so, use the <code>product.platforms</code> list:</p> <pre><code>product:\n  type: lib\n  platforms: [iosArm64, android, jvm]\n</code></pre> No platform family shortcuts here <p>The <code>product.platforms</code> list may only contain platform names, not platform family names. This is to ensure the stability of the platforms list when Kotlin is bumped to a higher version. Using family shortcuts could change the list of platforms in a very subtle and implicit way.</p>"},{"location":"user-guide/multiplatform/#platform-qualifier","title":"Platform qualifier","text":"<p>In multiplatform modules, some source directories and sections in the configuration files can be platform-specific. Amper defines a special suffix, called the <code>@platform</code> qualifier, to mark such platform-specific things.</p> <p>What follows the <code>@</code> sign is the name of a platform or platform family. The available platform and platform families are described in the Platforms hierarchy section.</p> <p>We'll see in the next sections how these directories and settings interact.</p>"},{"location":"user-guide/multiplatform/#module-layout","title":"Module layout","text":"<p>Here is an overview of what the layout of a multiplatform module looks like when <code>jvm</code>, <code>iosArm64</code>, <code>iosSimulatorArm64</code>, and <code>iosX64</code> platforms are enabled:</p> <pre><code>my-module/\n\u251c\u2500 resources/       # common resources, used in all targets\n\u251c\u2500 resources@ios/   # resources that are only available to the iOS code\n\u251c\u2500 resources@jvm/   # resources that are only available to the JVM code\n\u251c\u2500 src/             # common code, compiled for all targets\n\u2502  \u251c\u2500 main.kt\n\u2502  \u2570\u2500 util.kt # (1)!\n\u251c\u2500 src@native/      # code to be compiled for all native targets\n\u251c\u2500 src@apple/       # code to be compiled for all Apple targets\n\u251c\u2500 src@ios/         # code to be compiled only for iOS targets\n\u2502  \u2570\u2500 util.kt # (2)!\n\u251c\u2500 src@jvm/         # code to be compiled only for JVM targets\n\u2502  \u251c\u2500 util.kt\n\u2502  \u2570\u2500 MyClass.java # (3)!\n\u251c\u2500 test/            # common tests, compiled for all targets\n\u2502  \u2570\u2500 MainTest.kt   \n\u251c\u2500 test@ios/        # tests that are only run on iOS simulator\n\u2502  \u2570\u2500 SomeIosTest.kt\n\u251c\u2500 test@jvm/        # tests that are only run on JVM\n\u2502  \u2570\u2500 SomeJvmTest.kt\n\u251c\u2500 testResources/       # common test resources, used in all targets\n\u251c\u2500 testResources@ios/   # test resources that are only available to the iOS code\n\u251c\u2500 testResources@jvm/   # test resources that are only available to the JVM code\n\u2570\u2500 module.yaml\n</code></pre> <ol> <li>This file may define <code>expect</code> declarations to be implemented differently on different platforms.</li> <li>This file defines the <code>actual</code> implementations corresponding to the <code>expect</code> declarations from <code>src</code>.</li> <li>It's ok to have Java sources in JVM-only source directories.</li> </ol> <p>Note</p> <p>Some other @platform directories were omitted for brevity.</p> <p>We'll explain what's going on here in the following sections.</p>"},{"location":"user-guide/multiplatform/#source-dirs","title":"Source dirs","text":"<p>Based on the platforms hierarchy, more common code is visible from more platform-specific code,  but not vice versa:</p> <pre><code>\u251c\u2500 src/\n\u251c\u2500 src@native/            # sees declarations from src\n\u251c\u2500 src@apple/             # sees declarations from src + src@native\n\u251c\u2500 src@ios/               # sees declarations from src + src@native + src@apple\n\u251c\u2500 src@iosArm64/          # sees declarations from src + src@native + src@apple + src@ios\n\u251c\u2500 src@iosSimulatorArm64/ # sees declarations from src + src@native + src@apple + src@ios\n\u251c\u2500 src@jvm/               # sees declarations from src\n\u2570\u2500 module.yaml\n</code></pre> <p>You can therefore share code between platforms by placing it in a common ancestor in the hierarchy: code placed in <code>src@ios</code> is shared between <code>iosArm64</code> and <code>iosSimulatorArm64</code>, for instance.</p> <p>For Kotlin Multiplatform expect/actual declarations, put your <code>expected</code> declarations into the <code>src/</code> folder, and <code>actual</code> declarations into the corresponding <code>src@&lt;platform&gt;/</code> folders.</p>"},{"location":"user-guide/multiplatform/#resources","title":"Resources","text":"<p>The final artifact for each platform gets its resources from <code>resources</code> and all <code>resources@platform</code> directories that correspond to this platform of its parent families:</p> <pre><code>\u251c\u2500 resources/          # these resources are copied into the Android and JVM artifact\n\u251c\u2500 resources@android/  # these resources are copied into the Android artifact\n\u2570\u2500 resources@jvm/      # these resources are copied into the JVM artifact\n</code></pre> <p>If different resource directories contain a resource with the same name, the more common resource is overwritten by the  more specific ones. That is <code>resources/foo.txt</code> will be overwritten by <code>resources@android/foo.txt</code>.</p>"},{"location":"user-guide/multiplatform/#aliases","title":"Aliases","text":"<p>If the default hierarchy is not enough, you can define new groups of platforms by giving them  an alias. You can then use the alias in places where <code>@platform</code> suffixes usually appear to share code, settings, or dependencies:</p> <pre><code>product:\n  type: lib\n  platforms: [iosArm64, android, jvm]\n\naliases:\n  - jvmAndAndroid: [jvm, android] # defines a custom alias for this group of platforms\n\n# these dependencies will be visible in jvm and android code\ndependencies@jvmAndAndroid:\n  - org.lighthousegames:logging:1.3.0\n\n# these dependencies will be visible in jvm code only\ndependencies@jvm:\n  - org.lighthousegames:logging:1.3.0\n\n# these settings will affect both jvm and android code, and the shared code placed in src@jvmAndAndroid\nsettings@jvmAndAndroid:\n  kotlin:\n    freeCompilerArgs: [ -jvm-default=no-compatibility ]\n</code></pre> <pre><code>\u251c\u2500 src/\n\u251c\u2500 src@jvmAndAndroid/ # sees declarations from src/\n\u251c\u2500 src@jvm/           # sees declarations from src/ and src@jvmAndAndroid/\n\u2570\u2500 src@android/       # sees declarations from src/ and src@jvmAndAndroid/\n</code></pre>"},{"location":"user-guide/multiplatform/#multiplatform-dependencies","title":"Multiplatform dependencies","text":"<p>When you use a Kotlin Multiplatform library, its platforms-specific parts are automatically configured for each module platform.</p> <p>Example: To add the KmLogging library to a multiplatform module, simply write</p> <pre><code>product:\n  type: lib\n  platforms: [android, iosArm64, jvm]\n\ndependencies:\n  - com.diamondedge:logging:2.1.0\n</code></pre> <p>The effective dependency lists are:</p> <p><pre><code>dependencies@android:\n  - com.diamondedge:logging:2.1.0\n  - com.diamondedge:logging-android:2.1.0\n</code></pre> <pre><code>dependencies@iosArm64:\n  - com.diamondedge:logging:2.1.0\n  - com.diamondedge:logging-iosarm64:2.1.0\n</code></pre> <pre><code>dependencies@jvm:\n  - com.diamondedge:logging:2.1.0\n  - com.diamondedge:logging-jvm:2.1.0\n</code></pre></p> <p>For the explicitly specified dependencies in the <code>@platform</code>-sections the general  propagation rules apply. That is, for the given configuration:</p> <pre><code>product:\n  type: lib\n  platforms: [android, iosArm64, iosSimulatorArm64]\n\ndependencies:\n  - ../foo\ndependencies@ios:\n  - ../bar\ndependencies@iosArm64:\n  - ../baz\n</code></pre> <p>The effective dependency lists are:</p> <p><pre><code>dependencies@android:\n  ../foo\n</code></pre> <pre><code>dependencies@iosSimulatorArm64:\n  ../foo\n  ../bar\n</code></pre> <pre><code>dependencies@iosArm64:\n  ../foo\n  ../bar\n  ../baz\n</code></pre></p>"},{"location":"user-guide/multiplatform/#multiplatform-settings","title":"Multiplatform settings","text":"<p>All toolchain settings, even platform-specific can be placed in the <code>settings:</code> section: <pre><code>product:\n  type: lib\n  platforms: [android, iosArm64]\n\nsettings:\n  # Kotlin toolchain settings that are used for both platforms\n  kotlin:\n    languageVersion: 1.8\n\n  # Android-specific settings are used only when building for android\n  android:\n    compileSdk: 33\n</code></pre></p> <p>There are situations when you need to override certain settings for a specific platform only. You can use <code>@platform</code>-qualifier.</p> <p>Note that certain platform names match the toolchain names, e.g. Android:</p> <ul> <li><code>settings@android</code> qualifier specifies settings for all Android target platforms</li> <li><code>settings.android</code> is an Android toolchain settings</li> </ul> <p>This could lead to confusion in cases like:</p> <pre><code>product: android/app\n\nsettings@android:    # settings to be used for Android target platform\n  android:           # Android toolchain settings\n    compileSdk: 33\n  kotlin:        # Kotlin toolchain settings\n    languageVersion: 1.8\n</code></pre> <p>Luckily, there should rarely be a need for such a configuration. We also plan to address this by linting with conversion to a more readable form:</p> <pre><code>product: android/app\n\nsettings:\n  android:           # Android toolchain settings\n    compileSdk: 33\n  kotlin:        # Kotlin toolchain settings\n    languageVersion: 1.8\n</code></pre> <p>For settings with the <code>@platform</code>-qualifiers, the propagation rules apply. E.g., for the given configuration:</p> <pre><code>product:\n  type: lib\n  platforms: [android, iosArm64, iosSimulatorArm64]\n\nsettings:           # common toolchain settings\n  kotlin:           # Kotlin toolchain\n    languageVersion: 1.8\n    freeCompilerArgs: [x]\n  android:              # Android toolchain\n    compileSdk: 33\n\nsettings@android:   # specialization for Android platform\n  compose: enabled  # Compose toolchain\n\nsettings@ios:       # specialization for all iOS platforms\n  kotlin:           # Kotlin toolchain\n    languageVersion: 1.9\n    freeCompilerArgs: [y]\n\nsettings@iosArm64:  # specialization for iOS arm64 platform \n  ios:              # iOS toolchain\n    freeCompilerArgs: [z]\n</code></pre> <p>The effective settings are:</p> <p><pre><code>settings@android:\n  kotlin:\n    languageVersion: 1.8   # from settings:\n    freeCompilerArgs: [x]  # from settings:\n  compose: enabled         # from settings@android:\n  android:                \n    compileSdk: 33         # from settings@android:\n</code></pre> <pre><code>settings@iosArm64:\n  kotlin:\n    languageVersion: 1.9      # from settings@ios:\n    freeCompilerArgs: [x, y]  # merged from settings: and settings@ios:\n</code></pre> <pre><code>settings@iosSimulatorArm64:\n  kotlin:\n    languageVersion: 1.9      # from settings@ios:\n    freeCompilerArgs: [x, y, z]  # merged from settings: and settings@ios: and settings@iosArm64:\n</code></pre></p>"},{"location":"user-guide/multiplatform/#dependencysettings-propagation","title":"Dependency/Settings propagation","text":"<p>Common <code>dependencies:</code> and <code>settings:</code> are automatically propagated to the platform families and platforms in <code>@platform</code>-sections, using the following rules:</p> <ul> <li>Scalar values (strings, numbers etc.) are overridden by more specialized <code>@platform</code>-sections.</li> <li>Mappings and lists are appended.</li> </ul> <p>Think of the rules like adding merging Java/Kotlin Maps.</p>"},{"location":"user-guide/multiplatform/#interoperability-between-languages","title":"Interoperability between languages","text":"<p>Kotlin Multiplatform implies smooth interoperability with platform languages, APIs, and frameworks. There are three distinct scenarios where such interoperability is needed:</p> <ul> <li>Consuming: Kotlin code can use APIs from existing platform libraries, e.g. jars on JVM (later CocoaPods on iOS too).</li> <li>Publishing: Kotlin code can be compiled and published as platform libraries to be consumed by the target platform's   tooling; such as jars on JVM, frameworks on iOS (maybe later .so on linux).</li> <li>Joint compilation: Kotlin code be compiled and linked into a final product together with the platform languages, like   JVM, Objective-C, and Swift.</li> </ul> <p>Joint compilation is already supported for Java and Kotlin, with 2-way interoperability: Java code can reference Kotlin declarations, and vice versa. So Java code can be placed alongside Kotlin code in the same source folder that is compiled for JVM/Android:</p> <pre><code>\u251c\u2500 src/\n\u2502  \u251c\u2500 main.kt\n\u251c\u2500 src@jvm/\n\u2502  \u251c\u2500 KotlinCode.kt\n\u2502  \u251c\u2500 JavaCode.java\n\u251c\u2500 src@android/\n\u2502  \u251c\u2500 KotlinCode.kt\n\u2502  \u251c\u2500 JavaCode.java\n\u251c\u2500 src@ios/\n\u2502  \u2570\u2500 ...\n\u2570\u2500 module.yaml\n</code></pre> <p>In the future, Kotlin Native will also support joint Kotlin+Swift compilation in the same way, but this is not the case yet. At the moment, Kotlin code is first compiled into a single framework per <code>ios/app</code> module, and then Swift is compiled using the Xcode toolchain with a dependency on that framework. This means that Swift code can reference Kotlin declarations, but Kotlin cannot reference Swift declarations. See more in the dedicated Swift support section.</p>"},{"location":"user-guide/templates/","title":"Templates","text":"<p>In modularized projects, there is often a need to have a certain common configuration for all or some modules. Typical examples could be a testing framework used in all modules or a Kotlin language version.</p> <p>Amper offers a way to extract whole sections or their parts into reusable template files.  These files are named <code>&lt;name&gt;.module-template.yaml</code> and have the same structure as <code>module.yaml</code> files.</p> <p>A templates is applied to a <code>module.yaml</code> file by it to the <code>apply:</code> section:</p> module.yaml<pre><code>product: jvm/app\n\napply: \n  - ../common.module-template.yaml\n</code></pre> ../common.module-template.yaml<pre><code>test-dependencies:\n  - org.jetbrains.kotlin:kotlin-test:1.8.10\n\nsettings:\n  kotlin:\n    languageVersion: 1.8\n</code></pre> <p>Sections in the template can also have <code>@platform</code>-qualifiers.</p> <p>Note</p> <p>Template files can't have <code>product:</code> and <code>apply:</code> sections (they can't be recursive).</p> <p>Templates are applied one by one, using the same rules as  platform-specific dependencies and settings:</p> <ul> <li>Scalar values (strings, numbers etc.) are overridden.</li> <li>Mappings and lists are appended.</li> </ul> <p>Settings and dependencies from the <code>module.yaml</code> file are applied last. The position of the <code>apply:</code> section doesn't matter, the <code>module.yaml</code> file content always has precedence E.g.</p> common.module-template.yaml<pre><code>dependencies:\n  - ../shared\n\nsettings:\n  kotlin:\n    languageVersion: 1.8\n  compose: enabled\n</code></pre> module.yaml<pre><code>product: jvm/app\n\napply:\n  - ./common.module-template.yaml\n\ndependencies:\n  - ../jvm-util\n\nsettings:\n  kotlin:\n    languageVersion: 1.9\n  jvm:\n    release: 8\n</code></pre> <p>After applying the template the resulting effective module is:</p> module.yaml<pre><code>product: jvm/app\n\ndependencies:  # lists appended\n  - ../shared\n  - ../jvm-util\n\nsettings:  # objects merged\n  kotlin:\n    languageVersion: 1.9  # module.yaml overwrites value\n  compose: enabled        # from the template\n  jvm:\n    release: 8   # from the module.yaml\n</code></pre>"},{"location":"user-guide/testing/","title":"Testing","text":"<p>Test code is located in the <code>test/</code> folder:</p> <pre><code>\u251c\u2500 src/            # production code\n\u251c\u2500 test/           # test code\n\u2502  \u251c\u2500 MainTest.kt\n\u2502  \u2570\u2500 ...\n\u2570\u2500 module.yaml\n</code></pre> <p>By default, the Kotlin test framework is preconfigured for each platform. Additional test-only dependencies should be added to the <code>test-dependencies:</code> section of your module configuration file:</p> module.yaml<pre><code>product: jvm/app\n\n# these dependencies are available in main and test code\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0\n\n# additional dependencies for test code\ntest-dependencies:\n  - io.ktor:ktor-server-test-host:2.2.0\n</code></pre> <p>To add or override toolchain settings in tests, use the <code>test-settings:</code> section: module.yaml<pre><code># these dependencies are available in main and test code\nsetting:\n  kotlin:\n    ...\n\n# additional test-specific setting \ntest-settings:\n  kotlin:\n    ...\n</code></pre></p> <p>Test settings and dependencies by default are inherited from the main configuration according to the  configuration propagation rules. Example: <pre><code>\u251c\u2500 src/\n\u251c\u2500 src@ios/\n\u251c\u2500 test/           # Sees declarations from src/. Executed on all platforms.\n\u2502  \u251c\u2500 MainTest.kt\n\u2502  \u2570\u2500 ...\n\u251c\u2500 test@ios/       # Sees declarations from src/, src@ios/, and `test/`. Executed on iOS platforms only.\n\u2502  \u251c\u2500 IOSTest.kt\n\u2502  \u2570\u2500 ...\n\u2570\u2500 module.yaml\n</code></pre></p> module.yaml<pre><code>product:\n  type: lib\n  platforms: [android, iosArm64]\n\n# these dependencies are available in main and test code\ndependencies:\n  - io.ktor:ktor-client-core:2.2.0\n\n# dependencies for test code\ntest-dependencies:\n  - org.jetbrains.kotlin:kotlin-test:1.8.10\n\n# these settings affect the main and test code\nsettings: \n  kotlin:\n    languageVersion: 1.8\n\n# these settings affect tests only\ntest-settings:\n  kotlin:\n    languageVersion: 1.9 # overrides settings.kotlin.languageVersion 1.8\n</code></pre>"},{"location":"user-guide/yaml-primer/","title":"Brief YAML primer","text":"<p>Amper uses (a subset of) the YAML language for configuration files.</p> <p>YAML describes a tree of mappings and values. Mappings have key-value pairs and can be nested. Values can be scalars (string, numbers, booleans) and sequences (lists, sets). YAML is indent-sensitive.</p> <p>Here is a cheat-sheet and YAML 1.2 specification.</p> <p>Strings can be quoted or unquoted. These are equivalent:</p> <pre><code>string1: foo bar\nstring2: \"foo bar\"\nstring3: 'foo bar'\n</code></pre> <p>Mapping:</p> <pre><code>mapping-name:\n  field1: foo bar\n  field2: 1.2  \n</code></pre> <p>List of values (strings):</p> <pre><code>list-name:\n  - foo bar\n  - \"bar baz\"  \n</code></pre> <p>List of mapping:</p> <pre><code>list-name:\n  - named-mapping:\n      field1: x\n      field2: y\n  - field1: x\n    field2: y\n</code></pre>"},{"location":"user-guide/advanced/java-annotation-processing/","title":"Java annotation processing","text":"<p>To add java annotation processors to your module, add their maven coordinates to the <code>settings.java.annotationProcessing.processors</code> list:</p> <pre><code>settings:\n  java:\n    annotationProcessing:\n      processors:\n        - org.mapstruct:mapstruct-processor:1.6.3\n</code></pre> <p>This option is only available for java or android modules (it's a platform-specific).</p> <p>As with KSP, it's possible to reference a local Amper module as a processor. See the KSP section for more information. Using library catalog entry is also supported.</p> <p>Some annotation processors can be customized by passing options. You can pass these options using the <code>processorOptions</code> map:</p> <pre><code>settings:\n  java:\n    annotationProcessing:\n      processors:\n        - $libs.auto.service # using catalog reference \n      processorOptions:\n        debug: true\n</code></pre>"},{"location":"user-guide/advanced/kotlin-compiler-plugins/","title":"Kotlin compiler plugins","text":"<p>Compiler plugins are a powerful feature of Kotlin that allow you to extend the language with new features. There is a handful of bundled compiler plugins that can be enabled in Amper.</p> <p>Third-party compiler plugins are not supported at the moment</p>"},{"location":"user-guide/advanced/kotlin-compiler-plugins/#all-open","title":"All-open","text":"<p>The All-open compiler plugin allows you to mark entire groups of classes as <code>open</code> automatically, without having to mark each class with the <code>open</code> keyword in your sources.</p> <p>To enable All-open, add the following configuration to your module file:</p> <pre><code>settings:\n  kotlin:\n    allOpen:\n      enabled: true\n      annotations: # (1)!\n        - org.springframework.context.annotation.Configuration\n        - org.springframework.stereotype.Service\n        - org.springframework.stereotype.Component\n        - org.springframework.stereotype.Controller\n        - ...\n</code></pre> <ol> <li>Lists the annotations that mark classes as open.</li> </ol> <p>Or you can use one of the preconfigured presets that contain all-open annotations related to specific frameworks:</p> <pre><code>settings:\n  kotlin:\n    allOpen:\n      enabled: true\n      presets:\n        - spring\n        - micronaut\n</code></pre> <p>Already covered by the Spring Boot support</p> <p>The All-open plugin is invaluable for Spring projects, because Spring needs to create proxy classes that extend the original classes. This is why using <code>springBoot: enabled</code> automatically enables the All-open plugin with the Spring preset.</p>"},{"location":"user-guide/advanced/kotlin-compiler-plugins/#no-arg","title":"No-arg","text":"<p>The No-arg compiler plugin automatically generates a no-arg  constructor for all classes marked with the configured annotations.</p> <p>To enable No-arg, add the following configuration:</p> <pre><code>settings:\n  kotlin:\n    noArg:\n      enabled: true\n      annotations: \n        - jakarta.persistence.Entity\n        - ...\n</code></pre> <p>Or you can use one of the preconfigured presets that contain no-arg annotations related to specific frameworks:</p> <pre><code>settings:\n  kotlin:\n    noArg:\n      enabled: true\n      presets: \n        - jpa\n</code></pre>"},{"location":"user-guide/advanced/kotlin-compiler-plugins/#power-assert","title":"Power Assert","text":"<p>The Power Assert compiler plugin enhances the output of failed  assertions with additional information about the values of variables and expressions:</p> <pre><code>Incorrect length\nassert(hello.length == world.substring(1, 4).length) { \"Incorrect length\" }\n       |     |      |  |     |               |\n       |     |      |  |     |               3\n       |     |      |  |     orl\n       |     |      |  world!\n       |     |      false\n       |     5\n       Hello\n</code></pre> <p>To enable Power Assert, add the following configuration:</p> <pre><code>settings:\n  kotlin:\n    powerAssert: enabled\n</code></pre> <p>By default, Power Assert is enabled for <code>kotlin.assert</code> function. You can enable it for other functions as well:</p> <pre><code>settings:\n  kotlin:\n    powerAssert:\n      enabled: true\n      functions: [ kotlin.test.assertTrue, kotlin.test.assertEquals, kotlin.test.assertNull ]\n</code></pre>"},{"location":"user-guide/advanced/kotlin-compiler-plugins/#compose","title":"Compose","text":"<p>The Compose compiler plugin is covered in the mode general Compose Multiplatform section.</p>"},{"location":"user-guide/advanced/kotlin-compiler-plugins/#kotlinx-serialization","title":"Kotlinx Serialization","text":"<p>The Kotlinx Serialization compiler plugin is covered in the more general  Kotlin Serialization section.</p>"},{"location":"user-guide/advanced/kotlin-compiler-plugins/#parcelize","title":"Parcelize","text":"<p>The Parcelize compiler plugin is covered in the Android section.</p>"},{"location":"user-guide/advanced/kotlin-compiler-plugins/#lombok","title":"Lombok","text":"<p>The Lombok compiler plugin is covered in the more general Lombok section.</p>"},{"location":"user-guide/advanced/ksp/","title":"Kotlin Symbol Processing (KSP)","text":"<p>Kotlin Symbol Processing is a tool that allows feeding Kotlin source code to processors, which can in turn use this information to generate code, classes, or resources, for instance. Amper provides built-in support for KSP.</p> <p>Some popular libraries also include a KSP processor to enhance their capabilities, such as Room or Moshi.</p> <p>Info</p> <p>Amper works with KSP2, so any processors used must be compatible with KSP2. We\u2019re expecting most processors to make this upgrade soon, as KSP1 is no longer part of KSP releases. However, at the moment, you might still see some gaps in support, such as issues with native targets.</p> <p>To add KSP processors to your module, add their maven coordinates to the <code>settings.kotlin.ksp.processors</code> list:</p> module.yaml<pre><code>settings:\n  kotlin:\n    ksp:\n      processors:\n        - androidx.room:room-compiler:2.7.0-alpha12\n</code></pre>"},{"location":"user-guide/advanced/ksp/#multiplatform-support","title":"Multiplatform support","text":"<p>In multiplatform modules, all settings from the <code>settings</code> section apply to all platforms by default, including KSP  processors. If you only want to add KSP processors for a specific platform, use a <code>settings</code> block with a <code>@platform</code> qualifier:</p> module.yaml<pre><code># the Room processor will only process code that compiles to the Android platform\nsettings@android:\n  kotlin:\n    ksp:\n      processors:\n        - androidx.room:room-compiler:2.7.0-alpha12\n</code></pre> <p>Generated code is not available in common sources</p> <p>In multiplatform modules, KSP is called for each platform separately. This means that any code generated by KSP processors will be available only for the corresponding platform. There is no way at the moment to access the  generated code from the common fragment (<code>src</code>) or intermediate fragments (e.g. <code>src@native</code>).</p> <p>This limitation comes from the Kotlin compilation model and how KSP aligns with it. Please follow  the relevant KSP issue for more information.</p>"},{"location":"user-guide/advanced/ksp/#passing-options-to-ksp-processors","title":"Passing options to KSP processors","text":"<p>Some processors can be customized by passing options. You can pass these options using the <code>processorOptions</code> section:</p> <pre><code>settings:\n  kotlin:\n    ksp:\n      processors:\n        - androidx.room:room-compiler:2.7.0-alpha12\n      processorOptions:\n        room.schemaLocation: ./schema\n</code></pre> <p>Consult the documentation of the processor you want to use for more information about the available options.</p> <p>Note</p> <p>Note: all options are passed to all processors by KSP. It's the processor's responsibility to use unique option names to avoid clashes with other processor options.</p>"},{"location":"user-guide/advanced/ksp/#using-your-own-local-ksp-processor","title":"Using your own local KSP processor","text":"<p>You can implement your own processor in an Amper module as a regular JVM library, and then use it to process code from other modules in your project.</p> <p>Usually, 3 modules are involved:</p> <ul> <li>The processor module, with the actual processor implementation</li> <li>The annotations module (optional), which contains annotations that the processor looks for in the consumer code</li> <li>The consumer module, which uses KSP with the custom processor</li> </ul> <p>The annotations module is a very simple JVM library module without any required dependencies (it's just here to provide some annotations to work with, if necessary):</p> my-processor-annotations/module.yaml<pre><code>product:\n  type: lib\n  platforms: [ jvm ]\n</code></pre> <p>The processor module is a JVM library with a <code>compile-only</code> dependency on KSP facilities, and on the custom annotations module:</p> my-processor/module.yaml<pre><code>product:\n  type: lib\n  platforms: [ jvm ]\n\ndependencies:\n  - ../my-processor-annotations\n  - com.google.devtools.ksp:symbol-processing-api:2.0.21-1.0.25: compile-only\n</code></pre> <p>The consumer module adds a regular dependency on the annotations module, and a reference to the processor module:</p> my-consumer/module.yaml<pre><code>product: jvm/app\n\ndependencies:\n  - ../my-processor-annotations # to be able to annotate the consumer code\n\nsettings:\n  kotlin:\n    ksp:\n      processors:\n        - ../my-processor # path to the module implementing the KSP processor\n</code></pre> <p>For more information about how to write your own processor, check out the KSP documentation.</p>"},{"location":"user-guide/advanced/maven-like-layout/","title":"Maven-like module layout","text":"<p>Amper is opinionated about where to put your sources, resources, and tests (see the  standard project layout).</p> <p>When transitioning from other tools, it would be tedious to move all (re)source files around in addition to converting the build configuration files. To smoothen the transition, Amper provides an alternative layout that is compatible with Maven and Gradle. The layout conforms to the Maven Standard Directory Layout.</p> <p>Example:</p> <pre><code>module/\n\u251c\u2500\u2500 module.yaml\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 main/\n    \u2502   \u251c\u2500\u2500 java/\n    \u2502   \u2502   \u2514\u2500\u2500 Main.java\n    \u2502   \u251c\u2500\u2500 kotlin/\n    \u2502   \u2502   \u2514\u2500\u2500 func.kt\n    \u2502   \u2514\u2500\u2500 resources/\n    \u2502       \u2514\u2500\u2500 input.txt\n    \u2514\u2500\u2500 test/\n        \u251c\u2500\u2500 java/\n        \u2502   \u2514\u2500\u2500 JavaTest.java\n        \u251c\u2500\u2500 kotlin/\n        \u2502   \u2514\u2500\u2500 KotlinTest.kt\n        \u2514\u2500\u2500 resources/\n            \u2514\u2500\u2500 test-input.txt\n</code></pre> <p>Note</p> <p>There is no difference between <code>java/</code> and <code>kotlin/</code> folders, Amper will look for java and kotlin sources in both folders. It is only necessary for the sake of transitioning simplicity.</p> <p>Choosing the file layout is possible per module.</p> <p>To enable the maven-like module layout, add the following to the <code>module.yaml</code> file:</p> <pre><code>layout: maven-like\n</code></pre>"},{"location":"user-guide/builtin-tech/android/","title":"Android","text":"<p>Use the <code>android/app</code> product type in a module to build an Android application.</p>"},{"location":"user-guide/builtin-tech/android/#module-layout","title":"Module layout","text":"<p>Here is an overview of the module layout for an Android application:</p> <pre><code>my-android-app/\n\u251c\u2500 assets/ # (1)!\n\u251c\u2500 res/ # (2)!\n\u2502  \u251c\u2500 drawable/\n\u2502  \u2502  \u2570\u2500 graphic.png\n\u2502  \u251c\u2500 layout/\n\u2502  \u2502  \u251c\u2500 main.xml\n\u2502  \u2502  \u2570\u2500 info.xml\n\u2502  \u2570\u2500 ...\n\u251c\u2500 resources/\n\u251c\u2500 src/\n\u2502  \u251c\u2500 AndroidManifest.xml # (3)!\n\u2502  \u2570\u2500 MainActivity.kt # (4)!\n\u251c\u2500 test/\n\u2502  \u2570\u2500 MainTest.kt\n\u251c\u2500 module.yaml\n\u2570\u2500 proguard-rules.pro # (5)!\n</code></pre> <ol> <li><code>assets</code> and <code>res</code> are standard Android resource directories. See the official Android docs.</li> <li><code>assets</code> and <code>res</code> are standard Android resource directories. See the official Android docs.</li> <li>The manifest file of your application.</li> <li>An activity (screen) of your application.</li> <li>Optional configuration for R8 code shrinking and obfuscation. See code shrinking.</li> </ol>"},{"location":"user-guide/builtin-tech/android/#entry-point","title":"Entry point","text":"<p>The application's entry point is specified in the <code>AndroidManifest.xml</code> file according to the official Android documentation:</p> src/AndroidManifest.xml<pre><code>&lt;manifest ... &gt;\n  &lt;application ... &gt;\n    &lt;activity android:name=\"com.example.myapp.MainActivity\" ... &gt;\n    &lt;/activity&gt;\n  &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <p>You can run your application using the <code>./amper run</code> command.</p> Run in IntelliJ IDEA <p>IntelliJ IDEA with the Amper plugin automatically detects the <code>android/app</code> product type and provides a run configuration for it:</p> <p></p>"},{"location":"user-guide/builtin-tech/android/#packaging","title":"Packaging","text":"<p>You can use the <code>build</code> command to create an APK, or the <code>package</code> command to create an Android Application Bundle (AAB).</p> <p>The <code>package</code> command will not only build the APK, but also minify/obfuscate it with ProGuard, and sign it. See the dedicated signing and code shrinking sections to learn how to configure this.</p>"},{"location":"user-guide/builtin-tech/android/#code-shrinking","title":"Code shrinking","text":"<p>When creating a release build with Amper, R8 will be used automatically, with minification and shrinking enabled. This is equivalent to the following Gradle configuration:</p> <pre><code>// in Gradle\nisMinifyEnabled = true\nisShrinkResources = true\nproguardFiles(getDefaultProguardFile(\"proguard-android-optimize.txt\"))\n</code></pre> <p>You can create a <code>proguard-rules.pro</code> file in the module folder to add custom rules for R8.</p> <pre><code>\u251c\u2500 src/\n\u251c\u2500 test/\n\u251c\u2500 proguard-rules.pro\n\u2570\u2500 module.yaml\n</code></pre> <p>It is automatically used by Amper if present.</p> <p>An example of how to add custom R8 rules can be found in the android-app module of the <code>compose-multiplatform</code> example project.</p>"},{"location":"user-guide/builtin-tech/android/#signing","title":"Signing","text":"<p>In a module containing an Android application (using the <code>android/app</code> product type) you can enable signing under settings:</p> <pre><code>settings:\n  android:\n    signing: enabled\n</code></pre> <p>This will use a <code>keystore.properties</code> file located in the module folder for the signing details by default. This properties file must contain the following signing details. Remember that these details should usually not be added to version control.</p> <pre><code>storeFile=/Users/example/.keystores/release.keystore\nstorePassword=store_password\nkeyAlias=alias\nkeyPassword=key_password\n</code></pre> <p>To customize the path to this file, you can use the <code>propertiesFile</code> option:</p> <pre><code>settings:\n  android:\n    signing:\n      enabled: true\n      propertiesFile: ./keystore.properties # default value\n</code></pre> <p>You can use <code>./amper tool generate-keystore</code> to generate a new keystore if you don't have one yet. This will create a new self-signed certificate, using the details in the <code>keystore.properties</code> file.</p> <p>Note</p> <p>You can also pass in these details to <code>generate-keystore</code> as command line arguments. Invoke the tool with <code>--help</code> to learn more.</p>"},{"location":"user-guide/builtin-tech/android/#parcelize","title":"Parcelize","text":"<p>If you want to automatically generate your <code>Parcelable</code> implementations, you can enable Parcelize as follows:</p> <pre><code>settings:\n  android:\n    parcelize: enabled\n</code></pre> <p>With this simple toggle, the following class gets its <code>Parcelable</code> implementation automatically without spelling it out in the code, just thanks to the <code>@Parcelize</code> annotation: <pre><code>import kotlinx.parcelize.Parcelize\n\n@Parcelize\nclass User(val firstName: String, val lastName: String, val age: Int): Parcelable\n</code></pre></p> <p>While this is only relevant on Android, sometimes you need to share your data model between multiple platforms. However, the <code>Parcelable</code> interface and <code>@Parcelize</code> annotation are only present on Android. But fear not, there is a solution described in the official documentation. In short:</p> <ul> <li>For <code>android.os.Parcelable</code>, you can use the <code>expect</code>/<code>actual</code> mechanism to define your own interface as typealias of   <code>android.os.Parcelable</code> (for Android), and as an empty interface for other platforms.</li> <li>For <code>@Parcelize</code>, you can simply define your own annotation instead, and then tell Parcelize about it (see below).</li> </ul> <p>For example, in common code: <pre><code>@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class MyParcelize\n\nexpect interface MyParcelable\n</code></pre> Then in Android code: <pre><code>actual typealias MyParcelable = android.os.Parcelable\n</code></pre> And in other platforms: <pre><code>// empty because nothing is generated on non-Android platforms\nactual interface MyParcelable\n</code></pre></p> <p>You can then make Parcelize recognize this custom annotation using the <code>additionalAnnotations</code> option:</p> <pre><code>settings:\n  kotlin:\n    # for the expect/actual MyParcelable interface\n    freeCompilerArgs: [ -Xexpect-actual-classes ]\n  android:\n    parcelize:\n      enabled: true\n      additionalAnnotations: [ com.example.MyParcelize ]\n</code></pre>"},{"location":"user-guide/builtin-tech/android/#google-services-and-firebase","title":"Google Services and Firebase","text":"<p>To enable the <code>google-services</code> plugin, place your <code>google-services.json</code> file in the module containing an <code>android/app</code> product, next to <code>module.yaml</code>.</p> <pre><code>\u2570\u2500 androidApp/\n   \u251c\u2500 src/\n   \u251c\u2500 google-services.json\n   \u2570\u2500 module.yaml\n</code></pre> <p>This file will be found and consumed automatically.</p>"},{"location":"user-guide/builtin-tech/compose-multiplatform/","title":"Compose Multiplatform","text":"<p>Compose Multiplatform is a declarative UI framework developed by JetBrains for sharing Kotlin UI code across multiple platforms.</p>"},{"location":"user-guide/builtin-tech/compose-multiplatform/#enabling-compose","title":"Enabling Compose","text":"<p>Use <code>settings.compose.enabled</code> to enable Compose:</p>  JVM Desktop Android  Shared library <pre><code>product: jvm/app\n\ndependencies:\n  - $compose.desktop.currentOs # (1)!\n\nsettings: \n  compose: enabled # (2)!\n</code></pre> <ol> <li>This library is from the built-in <code>$compose</code> catalog, accessible when Compose is enabled</li> <li>Enables the Compose toolchain (compiler plugin and runtime dependencies)</li> </ol> <pre><code>product: android/app\n\ndependencies:\n  - $compose.foundation # (1)!\n  - $compose.material3\n\nsettings:\n  compose: enabled # (2)!\n</code></pre> <ol> <li>These libraries are from the built-in <code>$compose</code> catalog, accessible when Compose is enabled</li> <li>Enables the Compose toolchain (compiler plugin and runtime dependencies)</li> </ol> <pre><code>product:\n  type: lib\n  platforms: [ jvm, android, iosSimulatorArm64, iosX64, iosArm64 ]\n\ndependencies:\n  - $compose.foundation: exported # (1)!\n  - $compose.material3: exported\n\nsettings:\n  compose:\n    enabled: true # (2)!\n</code></pre> <ol> <li>These libraries are from the built-in <code>$compose</code> catalog, accessible when Compose is enabled. We export them       to consumers because we use types from these libraries in our own public API.  </li> <li>Enables the Compose toolchain (compiler plugin and runtime dependencies)</li> </ol> <p>Enabling Compose does the following:</p> <ul> <li>configures the Compose compiler plugin for the Kotlin compiler</li> <li>adds the required <code>org.jetbrains.compose.runtime:runtime</code> dependency (implicitly)</li> <li>enables the built-in <code>$compose.*</code> library catalog for all optional Compose modules</li> </ul>"},{"location":"user-guide/builtin-tech/compose-multiplatform/#custom-compose-version","title":"Custom Compose version","text":"<p>You can specify the exact version of the Compose framework to use this way:</p> <pre><code>settings:\n  compose:\n    enabled: true\n    version: 1.5.10\n</code></pre>"},{"location":"user-guide/builtin-tech/compose-multiplatform/#using-multiplatform-resources","title":"Using multiplatform resources","text":"<p>Amper supports Compose Multiplatform resources.</p> <p>Place your resources in the <code>composeResources</code> folder at the root of your module: <pre><code>my-kmp-module/\n\u251c\u2500 src/\n\u2502  \u2570\u2500 ... # (1)!\n\u251c\u2500 composeResources/\n\u2502  \u251c\u2500 values/\n\u2502  \u2502  \u2570\u2500 strings.xml\n\u2502  \u2570\u2500 drawable/\n\u2502     \u2570\u2500 image.jpg\n\u2570\u2500 module.yaml\n</code></pre></p> <ol> <li>Your Kotlin code is here</li> </ol> <p>Amper then automatically generates the Kotlin accessors for these resources, and you can use them in your Kotlin code:</p> <pre><code>import my_kmp_module.generated.resources.Res\nimport my_kmp_module.generated.resources.hello\n// other imports\n\n@Composable\nprivate fun displayHelloText() {\n    BasicText(stringResource(Res.string.hello))\n}\n</code></pre> <p>Read more about setting up and using compose resources in the documentation.</p>"},{"location":"user-guide/builtin-tech/compose-multiplatform/#generated-accessors-package","title":"Generated accessors package","text":"<p>By default, resources accessors are generated in the package <code>&lt;sanitized-module-name&gt;.generated.resources</code>, where  <code>&lt;sanitized-module-name&gt;</code> is the module name with all non-letter symbols replaced with <code>_</code>.</p> <p>In the above example where the module name is <code>my-kmp-module</code>, the package name for the generated resources is  therefore <code>my_kmp_module.generated.resources</code>.</p> <p>You can customize the package name by setting the <code>settings.compose.resources.packageName</code> property in your module file:</p> <pre><code>settings:\n  compose:\n    resources:\n      packageName: com.example.gen\n</code></pre>"},{"location":"user-guide/builtin-tech/compose-multiplatform/#compose-hot-reload-experimental","title":"Compose Hot Reload (experimental)","text":"<p>Amper supports Compose Hot Reload, allowing you to see UI changes in real-time without restarting the application. This significantly improves the developer experience by shortening the feedback loop during UI development.</p>"},{"location":"user-guide/builtin-tech/compose-multiplatform/#hot-run-your-application","title":"Hot-run your application","text":"IntelliJ IDEA CLI <p>To run your application with Compose Hot Reload, simply select the Run with Compose Hot Reload option from the  IDE:</p> <p></p> I don't have this option, please help! <p>Make sure that:</p> <ul> <li>you have installed and enabled the Amper IDEA plugin</li> <li>your module has the <code>jvm</code> target (<code>jvm/app</code> product type, or a library module with <code>jvm</code> platform)</li> </ul> <p>In this mode, IDEA will recompile and hot-reload your application based on file system changes.</p> <p>To run your application with Compose Hot Reload from the command line, use the <code>--compose-hot-reload-mode</code> flag:</p> <pre><code>./amper run --compose-hot-reload-mode\n</code></pre> <p>No file-system watch</p> <p>At the moment, the Amper CLI doesn't watch the file system for changes, so the only way to reap the benefits of Compose Hot Reload is to run the application from the IDE.</p> <p>When you run your application with Compose Hot Reload enabled:</p> <ul> <li>Amper automatically downloads and runs JetBrains Runtime to maximize   hot-swap capabilities</li> <li>The Java agent for Compose Hot Reload is attached during execution</li> <li>A small Compose Hot Reload devtools icon appears next to the application window, indicating that the feature is active</li> </ul> <p> </p>"},{"location":"user-guide/builtin-tech/compose-multiplatform/#hot-run-specific-components","title":"Hot-run specific components","text":"<p>It's also possible to run specific composables in Compose Hot Reload mode instead of your entire application. This is especially useful to check library components or just individual parts of your apps.</p> <p>To do that, add the Compose Hot Reload runtime API dependency to your module:</p> <pre><code>dependencies:\n  - $compose.hotReload.runtimeApi # for @DevelopmentEntryPoint\n</code></pre> <p>And add the <code>@DevelopmentEntryPoint</code> annotation on any parameter-less <code>@Composable</code> function:</p> <pre><code>@DevelopmentEntryPoint // (1)!\n@Composable\nfun MySuperComponent() { // (2)!\n    MyComponentWithParams(title = \"Dummy title\", description = \"Lorem ipsum dolor sit amet\")\n}\n</code></pre> <ol> <li>Makes the component runnable on its own</li> <li>The component must not have parameters</li> </ol> <p>A clickable gutter icon will appear on the left side of the composable. </p> Hot-reloading components with parameters <p>If your component needs parameters, you can create a wrapper component that just creates your component with  the parameter values you want to use for the hot run, and annotate the wrapper with <code>@DevelopmentEntryPoint</code>:</p> <pre><code>@DevelopmentEntryPoint\n@Composable\nfun MyComponentPreview() {\n    MyComponentWithParams(title = \"Dummy title\", description = \"Lorem ipsum dolor sit amet\")\n}\n\n@Composable\nfun MyComponentWithParams(title: String, description: String) {\n    // Your composable code here\n}\n</code></pre>"},{"location":"user-guide/builtin-tech/compose-multiplatform/#custom-compose-hot-reload-version","title":"Custom Compose Hot Reload version","text":"<p>You can optionally customize the version of Compose Hot Reload used by Amper this way:</p> <pre><code>settings:\n  compose:\n    enabled: true\n    experimental:\n      hotReload:\n        version: 1.0.0-rc3\n</code></pre>"},{"location":"user-guide/builtin-tech/ios/","title":"iOS","text":""},{"location":"user-guide/builtin-tech/ios/#module-layout","title":"Module layout","text":"<p>Here is an overview of the module layout for iOS application:</p> <pre><code>my-ios-app/\n\u251c\u2500 src/\n\u2502  \u251c\u2500 KotlinCode.kt # (1)!\n\u2502  \u251c\u2500 EntryPoint.swift # (2)!\n\u2502  \u2570\u2500 Info.plist\n\u251c\u2500 module.yaml\n\u2570\u2500 module.xcodeproj # (3)!\n</code></pre> <ol> <li>Kotlin code is optional. Everything could come from dependencies.</li> <li>The entrypoint of iOS apps must be a <code>@main</code> struct in a Swift file.    Read more</li> <li>An Xcode project is required but it can be automatically generated by Amper the first time.    Read more</li> </ol>"},{"location":"user-guide/builtin-tech/ios/#xcode-project","title":"Xcode Project","text":"<p>Currently, an Xcode project is required to build an iOS application in Amper. It has to be named <code>module.xcodeproj</code> and located in the <code>ios/app</code> module root directory.</p> <p>Normally, when the Amper project is created via <code>amper init</code> or via the IDE's Wizard, the appropriate Xcode project is already there. This is currently the recommended way of creating projects that have an iOS app module.</p> <p>However, if the Amper project is created from scratch, the default buildable Xcode project will be created automatically after the first project build. This project can later be customized and checked into a VCS.</p> <p>If you want to migrate an existing Xcode project so it has Amper support, you must manually ensure that:</p> <ol> <li>it is named <code>module.xcodeproj</code> and is located in the root of the <code>ios/app</code> module</li> <li>it has a single iOS application target</li> <li>the target has <code>Debug</code> &amp; <code>Release</code> build configurations, each containing <code>AMPER_WRAPPER_PATH = &lt;relative path to amper wrapper script&gt;</code>.    The path is relative to the Amper module root.</li> <li>the target has a script build phase called <code>Build Kotlin with Amper</code> with the code:    <pre><code> # !AMPER KMP INTEGRATION STEP!\n # This script is managed by Amper, do not edit manually!\n \"${AMPER_WRAPPER_PATH}\" tool xcode-integration\n</code></pre></li> <li>The Framework Search Paths (<code>FRAMEWORK_SEARCH_PATHS</code>) option contains the <code>$(TARGET_BUILD_DIR)/AmperFrameworks</code> value</li> </ol> <p>Changes to the Xcode project that do not break these requirements are allowed.</p> <p>So the iOS app module layout looks like this: <pre><code>\u251c\u2500 src/\n\u2502  \u251c\u2500 KotlinCode.kt      # optional, if all the code is in the libraries\n\u2502  \u251c\u2500 EntryPoint.swift\n\u2502  \u251c\u2500 Info.plist\n\u251c\u2500 module.yaml           # ios/app\n\u2570\u2500 module.xcodeproj      # xcode project\n</code></pre></p> <p>Tip</p> <p>The Xcode project can be built normally from the Xcode IDE, if needed.</p>"},{"location":"user-guide/builtin-tech/ios/#application-entry-point","title":"Application entry point","text":"<p>For iOS applications, the entry point is expected to be a <code>@main</code> struct in any Swift file in the <code>src</code> folder.</p> <pre><code>\u251c\u2500 src/\n\u2502  \u251c\u2500 main.swift\n\u2502  \u2570\u2500 ...\n\u251c\u2500 module.yaml\n\u2570\u2500 module.xcodeproj\n</code></pre> <p>src/main.swift: <pre><code>...\n@main\nstruct iosApp: App {\n   ...\n}\n</code></pre></p> <p>This is not customizable at the moment.</p>"},{"location":"user-guide/builtin-tech/ios/#swift-support","title":"Swift support","text":"<p>Info</p> <p>Swift sources are only fully supported in the <code>src</code> directory of the <code>ios/app</code> module.</p> <p>While swift sources are, strictly speaking, managed by the Xcode project and, as such, can reside in arbitrary locations, it's not recommended to have them anywhere outside the <code>src</code> directory - the tooling might not work correctly.</p> <p>To use Kotlin code from Swift, one must import the <code>KotlinModules</code> framework. This framework is built from:</p> <ol> <li>the code inside the <code>ios/app</code> module itself</li> <li>the modules that <code>ios/app</code> module depends on (e.g. <code>- ../shared</code>)</li> <li>all the external dependencies, transitively</li> </ol> <p>Note</p> <p>All declarations from the source Kotlin code are accessible to Swift, but external dependencies are not.</p>"},{"location":"user-guide/builtin-tech/kotlin-serialization/","title":"Kotlin Serialization","text":"<p>Kotlin Serialization is the official multiplatform and multi-format serialization library for Kotlin.</p> <p>If you need to (de)serialize Kotlin classes to/from JSON, you can enable Kotlin Serialization it in its simplest form: <pre><code>settings:\n  kotlin:\n    serialization: json  # JSON or other format\n</code></pre> This snippet configures the compiler to process <code>@Serializable</code> classes, and adds dependencies on the serialization runtime and JSON format libraries.</p> <p>You can also customize the version of the Kotlin Serialization libraries using the full form of the configuration:</p> <pre><code>settings:\n  kotlin:\n    serialization:\n      format: json\n      version: 1.7.3\n</code></pre>"},{"location":"user-guide/builtin-tech/kotlin-serialization/#more-control-over-serialization-formats","title":"More control over serialization formats","text":"<p>If you don't need serialization format dependencies or if you need more control over them, you can use the following: <pre><code>settings:\n  kotlin:\n    serialization: enabled # configures the compiler and serialization runtime library\n</code></pre> This snippet on its own only configures the compiler and the serialization runtime library, but doesn't add any format dependency. However, it adds a built-in catalog with official serialization formats libraries, which you can use in your <code>dependencies</code> section. This is useful in multiple cases:</p> <ul> <li> <p>if you need a format dependency only in tests:   <pre><code>settings:\n  kotlin:\n    serialization: enabled\n\ntest-dependencies:\n  - $kotlin.serialization.json\n</code></pre></p> </li> <li> <p>if you need to customize the scope of the format dependencies:   <pre><code>settings:\n  kotlin:\n    serialization: enabled\n\ndependencies:\n  - $kotlin.serialization.json: compile-only\n</code></pre></p> </li> <li> <p>if you need to expose format dependencies transitively:   <pre><code>settings:\n  kotlin:\n    serialization: enabled\n\ndependencies:\n  - $kotlin.serialization.json: exported\n</code></pre></p> </li> <li> <p>if you need multiple formats:   <pre><code>settings:\n  kotlin:\n    serialization: enabled\n\ndependencies:\n  - $kotlin.serialization.json\n  - $kotlin.serialization.protobuf\n</code></pre></p> </li> </ul>"},{"location":"user-guide/builtin-tech/ktor/","title":"Ktor","text":"<p>Ktor is a Kotlin framework for building asynchronous server-side and client-side applications.</p> <p>To enable Ktor support, add the following to the <code>module.yaml</code> file: <pre><code>settings:\n  ktor: enabled\n</code></pre></p> <p>Setting <code>ktor: enabled</code> performs the following actions:</p> <ul> <li>Applies Ktor BOM</li> <li>Contributes Ktor-related entries to a built-in library catalog</li> <li>Adds the <code>io.ktor.development=true</code> system property when running the app with <code>amper run</code></li> </ul> <p>Examples of Ktor projects:</p> <ul> <li>ktor-simplest-sample</li> </ul> <p>You can also customize the version of the Ktor libraries using the full form of the configuration: <pre><code>settings:\n  ktor:\n    enabled: true\n    version: 3.3.2\n</code></pre></p> <p>If you don't want the Ktor BOM to be applied, you can disable it explicitly: <pre><code>settings:\n  ktor:\n    enabled: true\n    applyBom: false\n</code></pre></p>"},{"location":"user-guide/builtin-tech/lombok/","title":"Lombok","text":"<p>Project Lombok is a Java library that generates getters, setters, builders,  and other boilerplate code from annotations.</p> <p>Amper provides the <code>settings.lombok</code> option to configure Lombok conveniently in your project: <pre><code>settings:\n  lombok: enabled\n</code></pre></p> <p>When Lombok is enabled, Amper adds the <code>lombok</code> dependency, the annotation processor for Java,  and the Kotlin compiler plugin.</p> <p>You can also customize the version of the Lombok library using the full form of the configuration: <pre><code>settings:\n  lombok:\n    enabled: true\n    version: 1.18.42\n</code></pre></p>"},{"location":"user-guide/builtin-tech/spring/","title":"icon-spring-boot        Spring Boot","text":"<p>Spring Boot is a framework that simplifies the creation of stand-alone, Spring based applications.</p> <p>To enable Spring Boot support, add the following to the <code>module.yaml</code> file: <pre><code>settings:\n  springBoot: enabled\n</code></pre></p> <p>Setting <code>springBoot: enabled</code> performs the following actions:</p> <ul> <li>Applies the Spring Boot Dependencies BOM</li> <li>Adds the <code>spring-boot-starter</code> dependency</li> <li>Adds the <code>spring-boot-starter-test</code> test dependency</li> <li>Configures <code>all-open</code> and <code>no-arg</code> Kotlin compiler plugins with the <code>spring</code> preset</li> <li>Adds the necessary compiler arguments for <code>kotlinc</code> and <code>javac</code>:</li> <li>For Java, <code>-parameters</code> is passed to the compiler to preserve parameter names.</li> <li>For Kotlin, <code>-java-parameters</code> is passed to the compiler for the same reason. Also <code>-Xjsr305</code> is set to <code>strict</code>     to favor the null-safety annotations.</li> <li>Contributes Spring Boot-related entries to the built-in library catalog</li> <li>Makes <code>amper run</code> run with classes instead of JARs (aka the <code>jvm.runtimeClasspathMode</code> setting).   This way the Spring Dev Tools can provide automatic restarts.</li> </ul> <p>Mixed projects (containing Java and Kotlin sources simultaneously) are supported.</p> <p>Examples of Spring Boot projects:</p> <ul> <li>spring-petclinic</li> <li>spring-petclinic-kotlin</li> </ul> <p>You can also customize the version of the Spring Boot libraries using the full form of the configuration: <pre><code>settings:\n  springBoot:\n    enabled: true\n    version: 3.5.7\n</code></pre></p> <p>If you don't want the Spring Boot Dependencies BOM to be applied, you can disable it explicitly: <pre><code>settings:\n  springBoot:\n    enabled: true\n    applyBom: false\n</code></pre></p>"}]}