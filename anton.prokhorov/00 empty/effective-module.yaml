# see teamcity parameters (how it looks like (inherited))
# maybe it makes sense to create types of modules and different defaults depend on type
# reference to default
# how plain java project looks like?
# where to write new template
# explicit inheritance is more preferable
# multiple inheritance is complex
# rethink about parents (conception) maybe better name, maybe better description
# boundaries: packaging, deployment, run, etc
groupId: 00empty
artifactId: 00empty
version: 0.1.0-SNAPSHOT


# it's hard to mentally find effective model
kotlin:
  compiler-settings:
    compatibility:
      api-version: 1.8
      language-version: 1.8

platforms:
  - type: jvm
    kotlin:
      # unobvious
      compiler-settings:
        jdk-release: 8
    artifacts:
      - type: binary
        name: main
        main-class: ${.main-class}
      - type: binary
        name: test
        main-class: ${.test-main-class}
      - type: container
        main-class: ${.main-class}
        test-platform-coordinates: junit-jupiter-engine:org.junit.jupiter:5.3.2
        tag: dsfds
        vm-settings:
          xms: 256m
          xmx: 768m

# reference to name maybe
# what does it mean to switch between toolchains and between kmod versions
toolchain:
  - name: default
    kmod: 0.0.1-alpha # maybe split environment of kmod and build
    kotlin-sdk: 1.8.0
    jdk:
      distribution: openjdk
      version: 11

# there is sugar for this:
# repositories:
#   - maven-central
repositories:
  - type: maven
    name: maven-central
    url: https://repo.maven.apache.org/maven2/

# there is sugar
# dependencies:
#  - kotlin-stdlib
#  - kotlin-test

dependencies:
  conflict-manager: gradle-like

kotlin-dependencies:
  - type: maven
    notation: org.jetbrains.kotlin:kotlin-stdlib:1.8.0
    scope: compile # same as in IDEA
    exposed: false
    hosted-by: maven-central # avoid supply chain vulnerability
  - type: maven
    notation: org.jetbrains.kotlin:kotlin-test:1.8.0
    scope: test
    exposed: false
    hosted-by: maven-central


runtime-classpath: ${native-implementation} # resolve(dependencies.jvm + kotlin-dependencies)
runtime-test-classpath: ${native-implementation} # resolve(select(dependencies.jvm + kotlin-dependencies)
compile-classpath: ${native-implementation} # resolve(dependencies.jvm + kotlin-dependencies)

# potential for mistakes
main-class: MainKt

module:
   project-layout: thin
   source:
    - path-pattern: src/commonMain/kotlin/*
      test: false
      type: source
      platform: common
    - path-pattern: src/commonTest/kotlin/*
      test: true
      type: source
      platform: common
    - path-pattern: src/jvmMain/kotlin/*
      test: false
      type: source
      platform: jvm
    - path-pattern: src/jvmTest/kotlin/*
      test: true
      type: source
      platform: jvm

plugin-repository: https://kmod-plugins.jetbrains.org